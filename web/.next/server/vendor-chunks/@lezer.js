"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n    /**\n    Create a new node prop type.\n    */\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n        this.combine = config.combine || null;\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/\nNodeProp.isolate = new NodeProp({ deserialize: value => {\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\")\n            throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    } });\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({ perNode: true });\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n    constructor(\n    /**\n    The inner tree.\n    */\n    tree, \n    /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */\n    overlay, \n    /**\n    The parser used to create this subtree.\n    */\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */\n    static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */\n    name, \n    /**\n    @internal\n    */\n    props, \n    /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */\n    id, \n    /**\n    @internal\n    */\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */\n    prop(prop) { return this.props[prop.id]; }\n    /**\n    True when this is the top node of a grammar.\n    */\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /**\n    True when this node is produced by a skip rule.\n    */\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /**\n    Indicates whether this is an error node.\n    */\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */\n    constructor(\n    /**\n    The node types in this set, by id.\n    */\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    let value = add[1], prop = add[0];\n                    if (prop.combine && prop.id in newProps)\n                        value = prop.combine(newProps[prop.id], value);\n                    newProps[prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */\n    constructor(\n    /**\n    The type of the top node.\n    */\n    type, \n    /**\n    This node's child nodes.\n    */\n    children, \n    /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */\n    positions, \n    /**\n    The total length of this tree\n    */\n    length, \n    /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */\n    resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && (anon || !c.type.isAnonymous))\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */\n    static build(data) { return buildTree(data); }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n    /**\n    Create a tree buffer.\n    */\n    constructor(\n    /**\n    The buffer's content.\n    */\n    buffer, \n    /**\n    The total length of the group of nodes in the buffer.\n    */\n    length, \n    /**\n    The node set used in this buffer.\n    */\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */\n    get type() { return NodeType.none; }\n    /**\n    @internal\n    */\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while (scan) {\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to)\n                break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            }\n            else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() { return this; }\n    get next() { return this.parent; }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    /**\n    @internal\n    */\n    toString() { return this._tree.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        for (let found = false; !found;) {\n            found = cur.type.is(before);\n            if (!cur.nextSibling())\n                return result;\n        }\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */\n    toString() { return this.context.buffer.childString(this.index); }\n}\nfunction iterStack(heads) {\n    if (!heads.length)\n        return null;\n    let pick = 0, picked = heads[0];\n    for (let i = 1; i < heads.length; i++) {\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next)\n        newHeads[pick] = next;\n    else\n        newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node) {\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() { return iterStack(this.heads); }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {\n        if (scan.index < 0) { // This is an overlay root\n            let parent = scan.parent;\n            (layers || (layers = [inner])).push(parent.resolve(pos, side));\n            scan = parent;\n        }\n        else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */\n    get name() { return this.type.name; }\n    /**\n    @internal\n    */\n    constructor(node, \n    /**\n    @internal\n    */\n    mode = 0) {\n        this.mode = mode;\n        /**\n        @internal\n        */\n        this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to this node's last child.\n    */\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /**\n    Move to the last child that starts before `pos`.\n    */\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */\n    nextSibling() { return this.sibling(1); }\n    /**\n    Move to this node's previous sibling, if any.\n    */\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */\n    next(enter = true) { return this.move(1, enter); }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */\n    prev(enter = true) { return this.move(-1, enter); }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth)\n                    return;\n                if (this.nextSibling())\n                    break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        if (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else if (depth > 2500 /* CutOff.Depth */) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while (cursor.pos > minPos) {\n            let { id, start, end, size } = cursor;\n            if (size > 4) { // Not a leaf\n                cursor.next();\n            }\n            else if (stopAt > -1 && start < stopAt) {\n                break;\n            }\n            else {\n                if (stopAt < 0)\n                    stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */\n    constructor(\n    /**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */\n    from, \n    /**\n    The end of the unchanged range.\n    */\n    to, \n    /**\n    The tree that this fragment is based on.\n    */\n    tree, \n    /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some(r => r.from >= r.to))\n        throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered;;) {\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            }\n            else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&\n                (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) {\n                    materialize(cursor);\n                    // materialize create one more level of nesting\n                    // we need to add depth to active overlay for going backwards\n                    if (overlay)\n                        overlay.depth++;\n                    if (covered)\n                        covered.depth++;\n                }\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay ||\n                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));\n                    if (ranges.length)\n                        checkRanges(ranges);\n                    if (ranges.length || !nest.overlay)\n                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)\n                            : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from)\n                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };\n                    else\n                        overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [i];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos\n            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)\n            : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack) {\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQ0FBa0M7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGFyZWlmeS1jb2RlLXdlYi8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/NGQ0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbmZpZy5jb21iaW5lIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYWRkWzFdLCBwcm9wID0gYWRkWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5jb21iaW5lICYmIHByb3AuaWQgaW4gbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3AuY29tYmluZShuZXdQcm9wc1twcm9wLmlkXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1twcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpLCBDYWNoZWRJbm5lck5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5PcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbm9wZXJhdG9yIHRvIGVuYWJsZSBtdWx0aXBsZSBvbmVzLlxuKi9cbnZhciBJdGVyTW9kZTtcbihmdW5jdGlvbiAoSXRlck1vZGUpIHtcbiAgICAvKipcbiAgICBXaGVuIGVuYWJsZWQsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgdmlzaXQgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIFtgVHJlZUJ1ZmZlcmBdKCNjb21tb24uVHJlZUJ1ZmZlcilzLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJFeGNsdWRlQnVmZmVyc1wiXSA9IDFdID0gXCJFeGNsdWRlQnVmZmVyc1wiO1xuICAgIC8qKlxuICAgIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgdGhlIG5vZGVzIHRoYXQgd3JhcCByZXBlYXRlZCBncmFtbWFyIGNvbnN0cnVjdHMgaW50byBhIGJhbGFuY2VkXG4gICAgdHJlZSkuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8qKlxuICAgIEJ5IGRlZmF1bHQsIHJlZ3VsYXIgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgbm9kZXNcbiAgICByZXBsYWNlIHRoZWlyIGJhc2Ugbm9kZSBpbiBpdGVyYXRpb24uIEVuYWJsZSB0aGlzIHRvIGlnbm9yZSB0aGVtXG4gICAgaW5zdGVhZC5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlTW91bnRzXCJdID0gNF0gPSBcIklnbm9yZU1vdW50c1wiO1xuICAgIC8qKlxuICAgIFRoaXMgb3B0aW9uIG9ubHkgYXBwbGllcyBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIGxpYnJhcnkgdG8gbm90IGVudGVyIG1vdW50ZWQgb3ZlcmxheXMgaWYgb25lIGNvdmVycyB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKEl0ZXJNb2RlIHx8IChJdGVyTW9kZSA9IHt9KSk7XG4vKipcbkEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxudHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuY29udmVuaWVudCB3YXkuXG5cblN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxub2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxubm9kZXMsIHRoZSByZXByZXNlbnRhdGlvbiBpcyBtYWRlIGEgbG90IG1vcmUgbWVtb3J5LWVmZmljaWVudC5cblxuSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xucmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xudXNlIHRoZSBbYFRyZWVDdXJzb3JgXSgjY29tbW9uLlRyZWVDdXJzb3IpIG9yXG5bYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xuYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbm1vdmUgYXJvdW5kIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWUge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBTZWUgYWxzbyBbYFRyZWUuYnVpbGRgXSgjY29tbW9uLlRyZWVeYnVpbGQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgKi9cbiAgICBjaGlsZHJlbiwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9ucyAob2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhpcyB0cmVlKSBvZlxuICAgIHRoZSBjaGlsZHJlbi5cbiAgICAqL1xuICAgIHBvc2l0aW9ucywgXG4gICAgLyoqXG4gICAgVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRyZWVcbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHByb3BzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWx1ZV0gb2YgcHJvcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc1t0eXBlb2YgcHJvcCA9PSBcIm51bWJlclwiID8gcHJvcCA6IHByb3AuaWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQodGhpcyk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb3NpdGlvbmVkIGF0IHRoZSB0b3Agb2ZcbiAgICB0aGUgdHJlZS4gTW9kZSBjYW4gYmUgdXNlZCB0byBbY29udHJvbF0oI2NvbW1vbi5JdGVyTW9kZSkgd2hpY2hcbiAgICBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICAqL1xuICAgIGN1cnNvcihtb2RlID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvaW50aW5nIGludG8gdGhpcyB0cmVlXG4gICAgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICBbYG1vdmVUb2BdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pLlxuICAgICovXG4gICAgY3Vyc29yQXQocG9zLCBzaWRlID0gMCwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IHNjb3BlID0gQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgdHJlZS5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgZnJvbSBib3RoIHNpZGVzLlxuICAgIFxuICAgIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVudGVyXG4gICAgW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpIGluc3RlYWQuXG4gICAgKi9cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICBwb2ludGluZyBpbnRvIHRoZSBpbm5lcm1vc3Qgb3ZlcmxhaWQgdHJlZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgdGhlIGhvc3QgdHJlZXMpLlxuICAgICovXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWRJbm5lck5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgQ2FjaGVkSW5uZXJOb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEluIHNvbWUgc2l0dWF0aW9ucywgaXQgY2FuIGJlIHVzZWZ1bCB0byBpdGVyYXRlIHRocm91Z2ggYWxsXG4gICAgbm9kZXMgYXJvdW5kIGEgcG9zaXRpb24sIGluY2x1ZGluZyB0aG9zZSBpbiBvdmVybGF5cyB0aGF0IGRvbid0XG4gICAgZGlyZWN0bHkgY292ZXIgdGhlIHBvc2l0aW9uLiBUaGlzIG1ldGhvZCBnaXZlcyB5b3UgYW4gaXRlcmF0b3JcbiAgICB0aGF0IHdpbGwgcHJvZHVjZSBhbGwgbm9kZXMsIGZyb20gc21hbGwgdG8gYmlnLCBhcm91bmQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICByZXNvbHZlU3RhY2socG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gc3RhY2tJdGVyYXRvcih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRyZWUgYW5kIGl0cyBjaGlsZHJlbiwgY2FsbGluZyBgZW50ZXJgIGZvciBhbnlcbiAgICBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIGxlYXZpbmcgdGhlIG5vZGUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIHRoYXQgbm9kZSB3aWxsXG4gICAgbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICAqL1xuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBsZXQgbW9kZSA9IHNwZWMubW9kZSB8fCAwLCBhbm9uID0gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA+IDA7XG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcihtb2RlIHwgSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmICghYW5vbiAmJiBjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYykgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudGVyZWQgJiYgbGVhdmUgJiYgKGFub24gfHwgIWMudHlwZS5pc0Fub255bW91cykpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMpO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICAqL1xuICAgIHByb3AocHJvcCkge1xuICAgICAgICByZXR1cm4gIXByb3AucGVyTm9kZSA/IHRoaXMudHlwZS5wcm9wKHByb3ApIDogdGhpcy5wcm9wcyA/IHRoaXMucHJvcHNbcHJvcC5pZF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICBjb25zdHJ1Y3Rvci5cbiAgICAqL1xuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgd2hpY2ggbWF5IGhhdmUgY2hpbGRyZW4gZ3JvdXBlZCBpbnRvIHN1YnRyZWVzIHdpdGggdHlwZVxuICAgIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgKi9cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICBvciBhIGN1cnNvciBvdmVyIHN1Y2ggYSBidWZmZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vKipcblRoZSBlbXB0eSB0cmVlXG4qL1xuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLyoqXG5UcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG5ub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbmNoaWxkcmVuIGJlbG9uZyB0byBpdCkuXG4qL1xuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGJ1ZmZlciwgXG4gICAgLyoqXG4gICAgVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgKi9cbiAgICBzZXQpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGlsZFN0cmluZyhpbmRleCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNldC50eXBlc1tpZF0sIHJlc3VsdCA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKC9cXFcvLnRlc3QocmVzdWx0KSAmJiAhdHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgY29weSA9IG5ldyBVaW50MTZBcnJheShlbmRJIC0gc3RhcnRJKSwgbGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSwgaiA9IDA7IGkgPCBlbmRJOykge1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGxldCB0byA9IGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBzdGFydEk7XG4gICAgICAgICAgICBsZW4gPSBNYXRoLm1heChsZW4sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWVCdWZmZXIoY29weSwgbGVuLCB0aGlzLnNldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTaWRlKHNpZGUsIHBvcywgZnJvbSwgdG8pIHtcbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAtMiAvKiBTaWRlLkJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogU2lkZS5BdE9yQmVmb3JlICovOiByZXR1cm4gdG8gPj0gcG9zICYmIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgMCAvKiBTaWRlLkFyb3VuZCAqLzogcmV0dXJuIGZyb20gPCBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMSAvKiBTaWRlLkF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogU2lkZS5BZnRlciAqLzogcmV0dXJuIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDQgLyogU2lkZS5Eb250Q2FyZSAqLzogcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIEJhc2VOb2RlIHtcbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5wYXJlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHtcbiAgICAgICAgbGV0IHNjYW4gPSB0aGlzLmNoaWxkQmVmb3JlKHBvcyksIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XG59XG5jbGFzcyBUcmVlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgZm9yIChsZXQgZm91bmQgPSBmYWxzZTsgIWZvdW5kOykge1xuICAgICAgICAgICAgZm91bmQgPSBjdXIudHlwZS5pcyhiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlOyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgY2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGFmdGVyIDwgKHRoaXMuX3BhcmVudCA/IGJ1ZmZlci5idWZmZXJbdGhpcy5fcGFyZW50LmluZGV4ICsgM10gOiBidWZmZXIuYnVmZmVyLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKDEpO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoLTEpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxufVxuZnVuY3Rpb24gaXRlclN0YWNrKGhlYWRzKSB7XG4gICAgaWYgKCFoZWFkcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBwaWNrID0gMCwgcGlja2VkID0gaGVhZHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGhlYWRzW2ldO1xuICAgICAgICBpZiAobm9kZS5mcm9tID4gcGlja2VkLmZyb20gfHwgbm9kZS50byA8IHBpY2tlZC50bykge1xuICAgICAgICAgICAgcGlja2VkID0gbm9kZTtcbiAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0ID0gcGlja2VkIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgcGlja2VkLmluZGV4IDwgMCA/IG51bGwgOiBwaWNrZWQucGFyZW50O1xuICAgIGxldCBuZXdIZWFkcyA9IGhlYWRzLnNsaWNlKCk7XG4gICAgaWYgKG5leHQpXG4gICAgICAgIG5ld0hlYWRzW3BpY2tdID0gbmV4dDtcbiAgICBlbHNlXG4gICAgICAgIG5ld0hlYWRzLnNwbGljZShwaWNrLCAxKTtcbiAgICByZXR1cm4gbmV3IFN0YWNrSXRlcmF0b3IobmV3SGVhZHMsIHBpY2tlZCk7XG59XG5jbGFzcyBTdGFja0l0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkcywgbm9kZSkge1xuICAgICAgICB0aGlzLmhlYWRzID0gaGVhZHM7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gaXRlclN0YWNrKHRoaXMuaGVhZHMpOyB9XG59XG5mdW5jdGlvbiBzdGFja0l0ZXJhdG9yKHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBpbm5lciA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgc2lkZSksIGxheWVycyA9IG51bGw7XG4gICAgZm9yIChsZXQgc2NhbiA9IGlubmVyIGluc3RhbmNlb2YgVHJlZU5vZGUgPyBpbm5lciA6IGlubmVyLmNvbnRleHQucGFyZW50OyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW4uaW5kZXggPCAwKSB7IC8vIFRoaXMgaXMgYW4gb3ZlcmxheSByb290XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7XG4gICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChwYXJlbnQucmVzb2x2ZShwb3MsIHNpZGUpKTtcbiAgICAgICAgICAgIHNjYW4gPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW91bnQgPSBNb3VudGVkVHJlZS5nZXQoc2Nhbi50cmVlKTtcbiAgICAgICAgICAgIC8vIFJlbGV2YW50IG92ZXJsYXkgYnJhbmNoaW5nIG9mZlxuICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50Lm92ZXJsYXkgJiYgbW91bnQub3ZlcmxheVswXS5mcm9tIDw9IHBvcyAmJiBtb3VudC5vdmVybGF5W21vdW50Lm92ZXJsYXkubGVuZ3RoIC0gMV0udG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvb3QgPSBuZXcgVHJlZU5vZGUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgc2Nhbi5mcm9tLCAtMSwgc2Nhbik7XG4gICAgICAgICAgICAgICAgKGxheWVycyB8fCAobGF5ZXJzID0gW2lubmVyXSkpLnB1c2gocmVzb2x2ZU5vZGUocm9vdCwgcG9zLCBzaWRlLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXllcnMgPyBpdGVyU3RhY2sobGF5ZXJzKSA6IGlubmVyO1xufVxuLyoqXG5BIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbmFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvKipcbiAgICBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5idWZmZXIuc3RhcnQsIHNpZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICAqL1xuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgICovXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgY2hpbGQgbWF5IGVuZCBhdCB0aGF0IHBvc2l0aW9uLCB3aGVuIDEgaXQgbWF5IHN0YXJ0IHRoZXJlLiBUaGlzXG4gICAgd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgc2V0IHRvIGZhbHNlLlxuICAgICovXG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gdGhpcy5tb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgbW9kZSkpO1xuICAgICAgICByZXR1cm4gbW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzID8gZmFsc2UgOiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICAqL1xuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5fdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKDEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcnNhbC4gQVxuICAgIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICAqL1xuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3RyZWVdKCNjb21tb24uVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICAqL1xuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5fdHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgICBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgb25lLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCBhbnkgY2hpbGRyZW4gb2YgdGhhdCBub2RlIGFyZVxuICAgIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICAgKi9cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyBhIGdpdmVuIGNvbnRleHTigJRhIHNlcXVlbmNlXG4gICAgb2YgZGlyZWN0IHBhcmVudCBub2RlIG5hbWVzLiBFbXB0eSBzdHJpbmdzIGluIHRoZSBjb250ZXh0IGFycmF5XG4gICAgYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgICovXG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZS5wYXJlbnQsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMuX3RyZWUsIGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF1dXTtcbiAgICAgICAgICAgIGlmICghdHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCwgZGVwdGgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQsIGNvbnRleHRBdFN0YXJ0ID0gY29udGV4dEhhc2g7XG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFNwZWNpYWxSZWNvcmQuUmV1c2UgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykgeyAvLyBDb250ZXh0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0LCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID4gMjUwMCAvKiBDdXRPZmYuRGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZUZsYXROb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0LCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YWtlRmxhdE5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucykge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTsgLy8gVGVtcG9yYXJ5LCBpbnZlcnRlZCBhcnJheSBvZiBsZWFmIG5vZGVzIGZvdW5kLCB3aXRoIGFic29sdXRlIHBvc2l0aW9uc1xuICAgICAgICBsZXQgbm9kZUNvdW50ID0gMCwgc3RvcEF0ID0gLTE7XG4gICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gbWluUG9zKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7IC8vIE5vdCBhIGxlYWZcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RvcEF0ID4gLTEgJiYgc3RhcnQgPCBzdG9wQXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wQXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQgPSBlbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChpZCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbm9kZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZUNvdW50KSB7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KG5vZGVDb3VudCAqIDQpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMywgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAxXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDJdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVHJlZUJ1ZmZlcihidWZmZXIsIG5vZGVzWzJdIC0gc3RhcnQsIG5vZGVTZXQpKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0SGFzaCkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8sIGNvbnRleHRIYXNoKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0ZXJpYWxpemUgY3JlYXRlIG9uZSBtb3JlIGxldmVsIG9mIG5lc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhZGQgZGVwdGggdG8gYWN0aXZlIG92ZXJsYXkgZm9yIGdvaW5nIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byA/IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldIDogW10pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCB8fCAhbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCByYW5nZXMubGVuZ3RoID8gbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UoXCJcIiksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcy5sZW5ndGggPyByYW5nZXNbMF0uZnJvbSA6IGN1cnNvci5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gb3ZlcmxheS5yYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiBvdmVybGF5LnJhbmdlc1tsYXN0XS50byA9PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXNbbGFzdF0gPSB7IGZyb206IG92ZXJsYXkucmFuZ2VzW2xhc3RdLmZyb20sIHRvOiByYW5nZS50byB9O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzWzBdLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvdmVyLk5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIHN0YWNrID0gW107XG4gICAgbGV0IGJ1ZmZlciA9IG5vZGUuY29udGV4dC5idWZmZXI7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBzdGFjay5wdXNoKGN1cnNvci5pbmRleCk7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGJhc2UgPSBjdXJzb3IudHJlZSwgaSA9IGJhc2UuY2hpbGRyZW4uaW5kZXhPZihidWZmZXIpO1xuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlciwgbmV3U3RhY2sgPSBbaV07XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoLCBzdGFja1Bvcykge1xuICAgICAgICBsZXQgdGFyZ2V0SSA9IHN0YWNrW3N0YWNrUG9zXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgdGFyZ2V0SSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbdGFyZ2V0SSArIDFdLCB0byA9IGJbdGFyZ2V0SSArIDJdO1xuICAgICAgICBuZXdTdGFjay5wdXNoKGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0YWNrUG9zXG4gICAgICAgICAgICA/IHNwbGl0KHRhcmdldEkgKyA0LCBiW3RhcmdldEkgKyAzXSwgYnVmLnNldC50eXBlc1tiW3RhcmdldEldXSwgZnJvbSwgdG8gLSBmcm9tLCBzdGFja1BvcyAtIDEpXG4gICAgICAgICAgICA6IG5vZGUudG9UcmVlKCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbdGFyZ2V0SSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGluZGV4IG9mIG5ld1N0YWNrKSB7XG4gICAgICAgIGxldCB0cmVlID0gY3Vyc29yLnRyZWUuY2hpbGRyZW5baW5kZXhdLCBwb3MgPSBjdXJzb3IudHJlZS5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBjdXJzb3IueWllbGQobmV3IFRyZWVOb2RlKHRyZWUsIHBvcyArIGN1cnNvci5mcm9tLCBpbmRleCwgY3Vyc29yLl90cmVlKSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIEl0ZXJNb2RlLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBOb2RlV2Vha01hcCwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The optional name of the base tag @internal\n    */\n    name, \n    /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)\n            if (mod.name)\n                name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag)\n            parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name) {\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.configure({props: [\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n]})\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Mode.Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Mode.Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n    combine(a, b) {\n        let cur, root, take;\n        while (a || b) {\n            if (!a || b && a.depth >= b.depth) {\n                take = b;\n                b = b.next;\n            }\n            else {\n                take = a;\n                a = a.next;\n            }\n            if (cur && cur.mode == take.mode && !take.context && !cur.context)\n                continue;\n            let copy = new Rule(take.tags, take.mode, take.context);\n            if (cur)\n                cur.next = copy;\n            else\n                root = copy;\n            cur = copy;\n        }\n        return root;\n    }\n});\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Mode.Opaque */; }\n    get inherit() { return this.mode == 1 /* Mode.Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/\nfunction highlightTree(tree, highlighter, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/\nfunction highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos)\n            return;\n        for (let text = code.slice(pos, p), i = 0;;) {\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i)\n                putText(text.slice(i, upto), classes);\n            if (nextBreak < 0)\n                break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes) => {\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            if (mounted)\n                inheritedClass = \"\";\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */\n    lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */\n    blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */\n    docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */\n    variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */\n    tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */\n    attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */\n    className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */\n    labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */\n    namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */\n    macroName: t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */\n    docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */\n    character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */\n    attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */\n    integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */\n    float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */\n    bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */\n    regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */\n    color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */\n    url: t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */\n    null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */\n    unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */\n    modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */\n    controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */\n    moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */\n    derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */\n    arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */\n    logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */\n    bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */\n    compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */\n    typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */\n    controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */\n    heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */\n    heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */\n    heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */\n    heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */\n    heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */\n    heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */\n    contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */\n    list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */\n    quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */\n    emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */\n    strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */\n    link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: t(),\n    /**\n    Deleted text.\n    */\n    deleted: t(),\n    /**\n    Changed text.\n    */\n    changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */\n    processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */\n    definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */\n    constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */\n    local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: Tag.defineModifier(\"special\")\n};\nfor (let name in tags) {\n    let val = tags[name];\n    if (val instanceof Tag)\n        val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLDBCQUEwQixTQUFTLEdBQUcsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSxrRkFBa0Y7QUFDeEYsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTTtBQUNOOztBQUU4RyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYXJlaWZ5LWNvZGUtd2ViLy4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz8yYmFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBiYXNlIHRhZyBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgeyBuYW1lIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBtb2Qgb2YgdGhpcy5tb2RpZmllZClcbiAgICAgICAgICAgIGlmIChtb2QubmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lID0gYCR7bW9kLm5hbWV9KCR7bmFtZX0pYDtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZpbmUobmFtZU9yUGFyZW50LCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGFyZW50ID09IFwic3RyaW5nXCIgPyBuYW1lT3JQYXJlbnQgOiBcIj9cIjtcbiAgICAgICAgaWYgKG5hbWVPclBhcmVudCBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgICAgIHBhcmVudCA9IG5hbWVPclBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcobmFtZSwgW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICB3aWxsIHJldHVybiBhIHRhZyB0aGF0IGlzIGEgc3VidGFnIG9mIHRoZSBvcmlnaW5hbC4gQXBwbHlpbmcgdGhlXG4gICAgc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIG9yZGVyLCBwcm9kdWNlIHRoZSBzYW1lIHRhZyAoYG0xKG0yKHQxKSkgPT0gbTIobTEodDEpKWApLlxuICAgIFxuICAgIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICBleGFtcGxlIGBtMShtMihtMyh0MSkpKWAgaXMgYSBzdWJ0eXBlIG9mIGBtMShtMih0MSkpYCxcbiAgICBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKG5hbWUpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcihuYW1lKTtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhiYXNlLm5hbWUsIHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwb3dlclNldChtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50IG9mIGJhc2Uuc2V0KVxuICAgICAgICAgICAgaWYgKCFwYXJlbnQubW9kaWZpZWQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcG93ZXJTZXQoYXJyYXkpIHtcbiAgICBsZXQgc2V0cyA9IFtbXV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgZSA9IHNldHMubGVuZ3RoOyBqIDwgZTsgaisrKSB7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2V0c1tqXS5jb25jYXQoYXJyYXlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbn1cbi8qKlxuVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIHNldCBvZiB0YWdzIHRvIGEgbGFuZ3VhZ2Ugc3ludGF4XG52aWEgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG5bYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuXG5UaGUgYXJndW1lbnQgb2JqZWN0IG1hcHMgbm9kZSBzZWxlY3RvcnMgdG8gW2hpZ2hsaWdodGluZ1xudGFnc10oI2hpZ2hsaWdodC5UYWcpIG9yIGFycmF5cyBvZiB0YWdzLlxuXG5Ob2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuU3VjaCBhIHBhdGggY2FuIGJlIGEgW25vZGUgbmFtZV0oI2NvbW1vbi5Ob2RlVHlwZS5uYW1lKSwgb3Jcbm11bHRpcGxlIG5vZGUgbmFtZXMgKG9yIGAqYCB3aWxkY2FyZHMpIHNlcGFyYXRlZCBieSBzbGFzaFxuY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxubWF0Y2hlcyB0aGUgZmluYWwgbm9kZSBidXQgb25seSBpZiBpdHMgZGlyZWN0IHBhcmVudCBub2RlcyBhcmUgdGhlXG5vdGhlciBub2RlcyBtZW50aW9uZWQuIEEgYCpgIGluIHN1Y2ggYSBwYXRoIG1hdGNoZXMgYW55IHBhcmVudCxcbmJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuYXJlbid0IHN1cHBvcnRlZCwgYm90aCBmb3IgZWZmaWNpZW5jeSByZWFzb25zIGFuZCBiZWNhdXNlIExlemVyXG50cmVlcyBtYWtlIGl0IHJhdGhlciBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGF0IHRoZXkgd291bGQgbWF0Y2guKVxuXG5BIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxudG8gdGhlIG5vZGUgc2hvdWxkIGFsc28gYXBwbHkgdG8gYWxsIGNoaWxkIG5vZGVzLCBldmVuIGlmIHRoZXlcbm1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXG51c2VkKS5cblxuV2hlbiBhIHBhdGggZW5kcyBpbiBgIWAsIGFzIGluIGBBdHRyaWJ1dGUhYCwgbm8gZnVydGhlciBtYXRjaGluZ1xuaGFwcGVucyBmb3IgdGhlIG5vZGUncyBjaGlsZCBub2RlcywgYW5kIHRoZSBlbnRpcmUgbm9kZSBnZXRzIHRoZVxuZ2l2ZW4gc3R5bGUuXG5cbkluIHRoaXMgbm90YXRpb24sIG5vZGUgbmFtZXMgdGhhdCBjb250YWluIGAvYCwgYCFgLCBgKmAsIG9yIGAuLi5gXG5tdXN0IGJlIHF1b3RlZCBhcyBKU09OIHN0cmluZ3MuXG5cbkZvciBleGFtcGxlOlxuXG5gYGBqYXZhc2NyaXB0XG5wYXJzZXIuY29uZmlndXJlKHtwcm9wczogW1xuICBzdHlsZVRhZ3Moe1xuICAgIC8vIFN0eWxlIE51bWJlciBhbmQgQmlnTnVtYmVyIG5vZGVzXG4gICAgXCJOdW1iZXIgQmlnTnVtYmVyXCI6IHRhZ3MubnVtYmVyLFxuICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4gICAgXCJTdHJpbmcvRXNjYXBlXCI6IHRhZ3MuZXNjYXBlLFxuICAgIC8vIFN0eWxlIGFueXRoaW5nIGluc2lkZSBBdHRyaWJ1dGVzIG5vZGVzXG4gICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4gICAgLy8gQWRkIGEgc3R5bGUgdG8gYWxsIGNvbnRlbnQgaW5zaWRlIEl0YWxpYyBub2Rlc1xuICAgIFwiSXRhbGljLy4uLlwiOiB0YWdzLmVtcGhhc2lzLFxuICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4gICAgXCJJbnZhbGlkU3RyaW5nXCI6IFt0YWdzLnN0cmluZywgdGFncy5pbnZhbGlkXSxcbiAgICAvLyBTdHlsZSB0aGUgbm9kZSBuYW1lZCBcIi9cIiBhcyBwdW5jdHVhdGlvblxuICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbiAgfSlcbl19KVxuYGBgXG4qL1xuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3Aoe1xuICAgIGNvbWJpbmUoYSwgYikge1xuICAgICAgICBsZXQgY3VyLCByb290LCB0YWtlO1xuICAgICAgICB3aGlsZSAoYSB8fCBiKSB7XG4gICAgICAgICAgICBpZiAoIWEgfHwgYiAmJiBhLmRlcHRoID49IGIuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0YWtlID0gYjtcbiAgICAgICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFrZSA9IGE7XG4gICAgICAgICAgICAgICAgYSA9IGEubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXIgJiYgY3VyLm1vZGUgPT0gdGFrZS5tb2RlICYmICF0YWtlLmNvbnRleHQgJiYgIWN1ci5jb250ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgUnVsZSh0YWtlLnRhZ3MsIHRha2UubW9kZSwgdGFrZS5jb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjdXIpXG4gICAgICAgICAgICAgICAgY3VyLm5leHQgPSBjb3B5O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJvb3QgPSBjb3B5O1xuICAgICAgICAgICAgY3VyID0gY29weTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG59KTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vKipcbkRlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxudGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxudGFrZSBwcmVjZWRlbmNlLlxuKi9cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS4gT2Z0ZW4sIHRoZSBoaWdoZXItbGV2ZWxcbltgaGlnaGxpZ2h0Q29kZWBdKCNoaWdobGlnaHQuaGlnaGxpZ2h0Q29kZSkgZnVuY3Rpb24gaXMgZWFzaWVyIHRvXG51c2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vKipcbkFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbm9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbiovXG5wdXRTdHlsZSwgXG4vKipcblRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuKi9cbmZyb20gPSAwLCBcbi8qKlxuVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qL1xudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gdHJlZSB3aXRoIHRoZSBnaXZlbiBoaWdobGlnaHRlciwgY2FsbGluZ1xuYHB1dFRleHRgIGZvciBldmVyeSBwaWVjZSBvZiB0ZXh0LCBlaXRoZXIgd2l0aCBhIHNldCBvZiBjbGFzc2VzIG9yXG53aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiB1bnN0eWxlZCwgYW5kIGBwdXRCcmVha2AgZm9yIGV2ZXJ5IGxpbmVcbmJyZWFrLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgdHJlZSwgaGlnaGxpZ2h0ZXIsIHB1dFRleHQsIHB1dEJyZWFrLCBmcm9tID0gMCwgdG8gPSBjb2RlLmxlbmd0aCkge1xuICAgIGxldCBwb3MgPSBmcm9tO1xuICAgIGZ1bmN0aW9uIHdyaXRlVG8ocCwgY2xhc3Nlcykge1xuICAgICAgICBpZiAocCA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRleHQgPSBjb2RlLnNsaWNlKHBvcywgcCksIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgaSk7XG4gICAgICAgICAgICBsZXQgdXB0byA9IG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaztcbiAgICAgICAgICAgIGlmICh1cHRvID4gaSlcbiAgICAgICAgICAgICAgICBwdXRUZXh0KHRleHQuc2xpY2UoaSwgdXB0byksIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwdXRCcmVhaygpO1xuICAgICAgICAgICAgaSA9IG5leHRCcmVhayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcDtcbiAgICB9XG4gICAgaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgKGZyb20sIHRvLCBjbGFzc2VzKSA9PiB7XG4gICAgICAgIHdyaXRlVG8oZnJvbSwgXCJcIik7XG4gICAgICAgIHdyaXRlVG8odG8sIGNsYXNzZXMpO1xuICAgIH0sIGZyb20sIHRvKTtcbiAgICB3cml0ZVRvKHRvLCBcIlwiKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xuICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgIGlmICh0YWdDbHMpIHtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgY2xzICs9IHRhZ0NscztcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIFtjb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZGVmaW5pdGlvblwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0XG4gICAgc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICAqL1xuICAgIGNvbnN0YW50OiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJjb25zdGFudFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcbiAgICBhcyBhIGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcihcImZ1bmN0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgKi9cbiAgICBzdGFuZGFyZDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3RhbmRhcmRcIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgKi9cbiAgICBsb2NhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwibG9jYWxcIiksXG4gICAgLyoqXG4gICAgQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIHNvbWUgY29tbW9uIHRhZy4gSXQgaXMgcmVjb21tZW5kZWQgZm9yIHRoZW1lcyB0byBkZWZpbmUgc3BlY2lhbFxuICAgIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICBjb21lIHVwIGEgbG90LlxuICAgICovXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3BlY2lhbFwiKVxufTtcbmZvciAobGV0IG5hbWUgaW4gdGFncykge1xuICAgIGxldCB2YWwgPSB0YWdzW25hbWVdO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgIHZhbC5uYW1lID0gbmFtZTtcbn1cbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodENvZGUsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 316,\n  noSemiType = 317,\n  incdec = 1,\n  incdecPrefix = 2,\n  questionDot = 3,\n  JSXStartTag = 4,\n  insertSemi = 318,\n  spaces = 320,\n  newline = 321,\n  LineComment = 5,\n  BlockComment = 6,\n  Dialect_jsx = 0;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44,\n      question = 63, dot = 46, bracketL = 91;\n\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == braceR || next == -1 || stack.context)\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context)\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst noSemicolonType = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);\n}, {contextual: true});\n\nconst operatorToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  } else if (next == question && input.peek(1) == dot) {\n    input.advance(); input.advance();\n    if (input.next < 48 || input.next > 57) // No digit after\n      input.acceptToken(questionDot);\n  }\n}, {contextual: true});\n\nfunction identifierChar(ch, start) {\n  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||\n    !start && ch >= 48 && ch <= 57\n}\n\nconst jsx = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return\n  input.advance();\n  if (input.next == slash) return\n  // Scan for an identifier followed by a comma or 'extends', don't\n  // treat this as a start tag if present.\n  let back = 0;\n  while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n  if (identifierChar(input.next, true)) {\n    input.advance();\n    back++;\n    while (identifierChar(input.next, false)) { input.advance(); back++; }\n    while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n    if (input.next == comma) return\n    for (let i = 0;; i++) {\n      if (i == 7) {\n        if (!identifierChar(input.next, true)) return\n        break\n      }\n      if (input.next != \"extends\".charCodeAt(i)) break\n      input.advance();\n      back++;\n    }\n  }\n  input.acceptToken(JSXStartTag, -back);\n});\n\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case defer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof as satisfies\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"let var const using function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with debugger new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n  null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  \"NewExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n  Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n  \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n\n  TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n  TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n  \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"is keyof unique infer asserts\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n\n  JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:20, as:25, from:33, default:36, async:41, function:42, in:52, out:55, const:56, extends:60, this:64, true:72, false:72, null:84, void:88, typeof:92, super:108, new:142, delete:154, yield:163, await:167, class:172, public:235, private:235, protected:235, readonly:237, instanceof:256, satisfies:259, import:292, keyof:349, unique:353, infer:359, asserts:395, is:397, abstract:417, implements:419, type:421, let:424, var:426, using:429, interface:435, enum:439, namespace:445, module:447, declare:451, global:455, defer:471, for:476, of:485, while:488, with:492, do:496, if:500, else:502, switch:506, case:512, try:518, catch:522, finally:526, return:530, throw:534, break:538, continue:542, debugger:546};\nconst spec_word = {__proto__:null,async:129, get:131, set:133, declare:195, public:197, private:197, protected:197, static:199, abstract:201, override:203, readonly:209, accessor:211, new:401};\nconst spec_LessThan = {__proto__:null,\"<\":193};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]\",\n  stateData: \"()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~\",\n  goto: \"$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_\",\n  nodeNames: \"âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 380,\n  context: trackNewline,\n  nodeProps: [\n    [\"isolate\", -8,5,6,14,37,39,51,53,55,\"\"],\n    [\"group\", -26,9,17,19,68,207,211,215,216,218,221,224,234,237,243,245,247,249,252,258,264,266,268,270,272,274,275,\"Statement\",-34,13,14,32,35,36,42,51,54,55,57,62,70,72,76,80,82,84,85,110,111,120,121,136,139,141,142,143,144,145,147,148,167,169,171,\"Expression\",-23,31,33,37,41,43,45,173,175,177,178,180,181,182,184,185,186,188,189,190,201,203,205,206,\"Type\",-3,88,103,109,\"ClassItem\"],\n    [\"openedBy\", 23,\"<\",38,\"InterpolationStart\",56,\"[\",60,\"{\",73,\"(\",160,\"JSXStartCloseTag\"],\n    [\"closedBy\", -2,24,168,\">\",40,\"InterpolationEnd\",50,\"]\",61,\"}\",74,\")\",165,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,5,6,278],\n  repeatNodeCount: 37,\n  tokenData: \"$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~\", 141, 340), new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~\", 25, 323)],\n  topRules: {\"Script\":[0,7],\"SingleExpression\":[1,276],\"SingleClassItem\":[2,277]},\n  dialects: {jsx: 0, ts: 15175},\n  dynamicPrecedences: {\"80\":1,\"82\":1,\"94\":1,\"169\":1,\"199\":1},\n  specialized: [{term: 327, get: (value) => spec_identifier[value] || -1},{term: 343, get: (value) => spec_word[value] || -1},{term: 95, get: (value) => spec_LessThan[value] || -1}],\n  tokenPrec: 15201\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixxREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDRCQUE0Qix3REFBaUI7QUFDN0MsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBLENBQUMsR0FBRyxpQ0FBaUM7O0FBRXJDLHdCQUF3Qix3REFBaUI7QUFDekMsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUJBQWlCOztBQUVyQiw0QkFBNEIsd0RBQWlCO0FBQzdDO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsMEJBQTBCLHdEQUFpQjtBQUMzQyxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakUsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0JBQW9CLDJEQUFTO0FBQzdCLDBCQUEwQixrREFBSTtBQUM5QixrR0FBa0csa0RBQUk7QUFDdEcsa0VBQWtFLGtEQUFJO0FBQ3RF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QiwwQkFBMEIsb0RBQW9ELEtBQUssR0FBRyxnQkFBZ0IsaUNBQWlDLDhDQUE4QyxLQUFLLEdBQUcsaURBQWlELDhDQUE4QyxLQUFLLEdBQUcsOEVBQThFLE1BQU0sR0FBRyx1Q0FBdUMsS0FBSyxHQUFHLHlGQUF5RixLQUFLLEdBQUcseUVBQXlFLEtBQUssR0FBRyx5RUFBeUUsS0FBSyxHQUFHLHlFQUF5RSxLQUFLLEdBQUcsOEVBQThFLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLGlEQUFpRCxvREFBb0QsS0FBSyxHQUFHLFlBQVkscUNBQXFDLDhDQUE4QyxLQUFLLEdBQUcsMERBQTBELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsaURBQWlELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsbUJBQW1CLGdCQUFnQixjQUFjLHlCQUF5QixnQkFBZ0IsS0FBSyxHQUFHLGlEQUFpRCwyREFBMkQsS0FBSyxHQUFHLG9EQUFvRCw4Q0FBOEMsS0FBSyxHQUFHLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLCtFQUErRSxrQkFBa0IsR0FBRyxzQ0FBc0MsSUFBSSw0SUFBNEksS0FBSyxHQUFHLCtDQUErQyxpQ0FBaUMsa0JBQWtCLEdBQUcsc0NBQXNDLElBQUksaURBQWlELEtBQUssR0FBRztBQUN4aGYsa0lBQWtJLHNEQUFlLCtEQUErRCxLQUFLLEdBQUcsNkVBQTZFLE1BQU0sTUFBTSw2RUFBNkUsaUNBQWlDLHNEQUFlLFdBQVc7QUFDemIsYUFBYSxvRUFBb0U7QUFDakYsYUFBYSxrQkFBa0I7QUFDL0IsdUJBQXVCLHFDQUFxQztBQUM1RCxpQkFBaUIsd0RBQXdELEVBQUUsa0RBQWtELEVBQUUscURBQXFEO0FBQ3BMO0FBQ0EsQ0FBQzs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGFyZWlmeS1jb2RlLXdlYi8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzPzcyMjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IG5vU2VtaSA9IDMxNixcbiAgbm9TZW1pVHlwZSA9IDMxNyxcbiAgaW5jZGVjID0gMSxcbiAgaW5jZGVjUHJlZml4ID0gMixcbiAgcXVlc3Rpb25Eb3QgPSAzLFxuICBKU1hTdGFydFRhZyA9IDQsXG4gIGluc2VydFNlbWkgPSAzMTgsXG4gIHNwYWNlcyA9IDMyMCxcbiAgbmV3bGluZSA9IDMyMSxcbiAgTGluZUNvbW1lbnQgPSA1LFxuICBCbG9ja0NvbW1lbnQgPSA2LFxuICBEaWFsZWN0X2pzeCA9IDA7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBKYXZhU2NyaXB0IHRva2VucyB0aGF0IGNhbid0IGJlXG4gICBleHByZXNzZWQgYnkgbGV6ZXIncyBidWlsdC1pbiB0b2tlbml6ZXIuICovXG5cbmNvbnN0IHNwYWNlID0gWzksIDEwLCAxMSwgMTIsIDEzLCAzMiwgMTMzLCAxNjAsIDU3NjAsIDgxOTIsIDgxOTMsIDgxOTQsIDgxOTUsIDgxOTYsIDgxOTcsIDgxOTgsIDgxOTksIDgyMDAsXG4gICAgICAgICAgICAgICA4MjAxLCA4MjAyLCA4MjMyLCA4MjMzLCA4MjM5LCA4Mjg3LCAxMjI4OF07XG5cbmNvbnN0IGJyYWNlUiA9IDEyNSwgc2VtaWNvbG9uID0gNTksIHNsYXNoID0gNDcsIHN0YXIgPSA0MiwgcGx1cyA9IDQzLCBtaW51cyA9IDQ1LCBsdCA9IDYwLCBjb21tYSA9IDQ0LFxuICAgICAgcXVlc3Rpb24gPSA2MywgZG90ID0gNDYsIGJyYWNrZXRMID0gOTE7XG5cbmNvbnN0IHRyYWNrTmV3bGluZSA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBmYWxzZSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSkge1xuICAgIHJldHVybiB0ZXJtID09IExpbmVDb21tZW50IHx8IHRlcm0gPT0gQmxvY2tDb21tZW50IHx8IHRlcm0gPT0gc3BhY2VzID8gY29udGV4dCA6IHRlcm0gPT0gbmV3bGluZVxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgaW5zZXJ0U2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBicmFjZVIgfHwgbmV4dCA9PSAtMSB8fCBzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKGluc2VydFNlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0LCBhZnRlcjtcbiAgaWYgKHNwYWNlLmluZGV4T2YobmV4dCkgPiAtMSkgcmV0dXJuXG4gIGlmIChuZXh0ID09IHNsYXNoICYmICgoYWZ0ZXIgPSBpbnB1dC5wZWVrKDEpKSA9PSBzbGFzaCB8fCBhZnRlciA9PSBzdGFyKSkgcmV0dXJuXG4gIGlmIChuZXh0ICE9IGJyYWNlUiAmJiBuZXh0ICE9IHNlbWljb2xvbiAmJiBuZXh0ICE9IC0xICYmICFzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBub1NlbWljb2xvblR5cGUgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA9PSBicmFja2V0TCAmJiAhc3RhY2suY29udGV4dCkgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pVHlwZSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBvcGVyYXRvclRva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBwbHVzIHx8IG5leHQgPT0gbWludXMpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKG5leHQgPT0gaW5wdXQubmV4dCkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgbGV0IG1heVBvc3RmaXggPSAhc3RhY2suY29udGV4dCAmJiBzdGFjay5jYW5TaGlmdChpbmNkZWMpO1xuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obWF5UG9zdGZpeCA/IGluY2RlYyA6IGluY2RlY1ByZWZpeCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHQgPT0gcXVlc3Rpb24gJiYgaW5wdXQucGVlaygxKSA9PSBkb3QpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7IGlucHV0LmFkdmFuY2UoKTtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDQ4IHx8IGlucHV0Lm5leHQgPiA1NykgLy8gTm8gZGlnaXQgYWZ0ZXJcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKHF1ZXN0aW9uRG90KTtcbiAgfVxufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuZnVuY3Rpb24gaWRlbnRpZmllckNoYXIoY2gsIHN0YXJ0KSB7XG4gIHJldHVybiBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPT0gOTUgfHwgY2ggPj0gMTkyIHx8XG4gICAgIXN0YXJ0ICYmIGNoID49IDQ4ICYmIGNoIDw9IDU3XG59XG5cbmNvbnN0IGpzeCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ICE9IGx0IHx8ICFzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X2pzeCkpIHJldHVyblxuICBpbnB1dC5hZHZhbmNlKCk7XG4gIGlmIChpbnB1dC5uZXh0ID09IHNsYXNoKSByZXR1cm5cbiAgLy8gU2NhbiBmb3IgYW4gaWRlbnRpZmllciBmb2xsb3dlZCBieSBhIGNvbW1hIG9yICdleHRlbmRzJywgZG9uJ3RcbiAgLy8gdHJlYXQgdGhpcyBhcyBhIHN0YXJ0IHRhZyBpZiBwcmVzZW50LlxuICBsZXQgYmFjayA9IDA7XG4gIHdoaWxlIChzcGFjZS5pbmRleE9mKGlucHV0Lm5leHQpID4gLTEpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgaWYgKGlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGJhY2srKztcbiAgICB3aGlsZSAoaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgZmFsc2UpKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gICAgd2hpbGUgKHNwYWNlLmluZGV4T2YoaW5wdXQubmV4dCkgPiAtMSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGNvbW1hKSByZXR1cm5cbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGkgPT0gNykge1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSByZXR1cm5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5uZXh0ICE9IFwiZXh0ZW5kc1wiLmNoYXJDb2RlQXQoaSkpIGJyZWFrXG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICBiYWNrKys7XG4gICAgfVxuICB9XG4gIGlucHV0LmFjY2VwdFRva2VuKEpTWFN0YXJ0VGFnLCAtYmFjayk7XG59KTtcblxuY29uc3QganNIaWdobGlnaHQgPSBzdHlsZVRhZ3Moe1xuICBcImdldCBzZXQgYXN5bmMgc3RhdGljXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2UgZGVmZXJcIjogdGFncy5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBvZiBhd2FpdCB5aWVsZCB2b2lkIHR5cGVvZiBkZWxldGUgaW5zdGFuY2VvZiBhcyBzYXRpc2ZpZXNcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFwibGV0IHZhciBjb25zdCB1c2luZyBmdW5jdGlvbiBjbGFzcyBleHRlbmRzXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiaW1wb3J0IGV4cG9ydCBmcm9tXCI6IHRhZ3MubW9kdWxlS2V5d29yZCxcbiAgXCJ3aXRoIGRlYnVnZ2VyIG5ld1wiOiB0YWdzLmtleXdvcmQsXG4gIFRlbXBsYXRlU3RyaW5nOiB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpLFxuICBzdXBlcjogdGFncy5hdG9tLFxuICBCb29sZWFuTGl0ZXJhbDogdGFncy5ib29sLFxuICB0aGlzOiB0YWdzLnNlbGYsXG4gIG51bGw6IHRhZ3MubnVsbCxcbiAgU3RhcjogdGFncy5tb2RpZmllcixcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWUgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBMYWJlbDogdGFncy5sYWJlbE5hbWUsXG4gIFByb3BlcnR5TmFtZTogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIFByaXZhdGVQcm9wZXJ0eU5hbWU6IHRhZ3Muc3BlY2lhbCh0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiQ2FsbEV4cHJlc3Npb24vTWVtYmVyRXhwcmVzc2lvbi9Qcm9wZXJ0eU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiRnVuY3Rpb25EZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5mdW5jdGlvbih0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpKSxcbiAgXCJDbGFzc0RlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiB0YWdzLmRlZmluaXRpb24odGFncy5jbGFzc05hbWUpLFxuICBcIk5ld0V4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuY2xhc3NOYW1lLFxuICBQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFByaXZhdGVQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpKSxcbiAgVXBkYXRlT3A6IHRhZ3MudXBkYXRlT3BlcmF0b3IsXG4gIFwiTGluZUNvbW1lbnQgSGFzaGJhbmdcIjogdGFncy5saW5lQ29tbWVudCxcbiAgQmxvY2tDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgQXJpdGhPcDogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIExvZ2ljT3A6IHRhZ3MubG9naWNPcGVyYXRvcixcbiAgQml0T3A6IHRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IHRhZ3MuY29tcGFyZU9wZXJhdG9yLFxuICBSZWdFeHA6IHRhZ3MucmVnZXhwLFxuICBFcXVhbHM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBBcnJvdzogdGFncy5mdW5jdGlvbih0YWdzLnB1bmN0dWF0aW9uKSxcbiAgXCI6IFNwcmVhZFwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIiggKVwiOiB0YWdzLnBhcmVuLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2UsXG4gIFwiSW50ZXJwb2xhdGlvblN0YXJ0IEludGVycG9sYXRpb25FbmRcIjogdGFncy5zcGVjaWFsKHRhZ3MuYnJhY2UpLFxuICBcIi5cIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCJAXCI6IHRhZ3MubWV0YSxcblxuICBUeXBlTmFtZTogdGFncy50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnR5cGVOYW1lKSxcbiAgXCJ0eXBlIGVudW0gaW50ZXJmYWNlIGltcGxlbWVudHMgbmFtZXNwYWNlIG1vZHVsZSBkZWNsYXJlXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogdGFncy5tb2RpZmllcixcbiAgXCJpcyBrZXlvZiB1bmlxdWUgaW5mZXIgYXNzZXJ0c1wiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcblxuICBKU1hBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSlNYVGV4dDogdGFncy5jb250ZW50LFxuICBcIkpTWFN0YXJ0VGFnIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYU2VsZkNsb3NlRW5kVGFnIEpTWEVuZFRhZ1wiOiB0YWdzLmFuZ2xlQnJhY2tldCxcbiAgXCJKU1hJZGVudGlmaWVyIEpTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MudGFnTmFtZSxcbiAgXCJKU1hBdHRyaWJ1dGUvSlNYSWRlbnRpZmllciBKU1hBdHRyaWJ1dGUvSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkpTWEJ1aWx0aW4vSlNYSWRlbnRpZmllclwiOiB0YWdzLnN0YW5kYXJkKHRhZ3MudGFnTmFtZSlcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfaWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxleHBvcnQ6MjAsIGFzOjI1LCBmcm9tOjMzLCBkZWZhdWx0OjM2LCBhc3luYzo0MSwgZnVuY3Rpb246NDIsIGluOjUyLCBvdXQ6NTUsIGNvbnN0OjU2LCBleHRlbmRzOjYwLCB0aGlzOjY0LCB0cnVlOjcyLCBmYWxzZTo3MiwgbnVsbDo4NCwgdm9pZDo4OCwgdHlwZW9mOjkyLCBzdXBlcjoxMDgsIG5ldzoxNDIsIGRlbGV0ZToxNTQsIHlpZWxkOjE2MywgYXdhaXQ6MTY3LCBjbGFzczoxNzIsIHB1YmxpYzoyMzUsIHByaXZhdGU6MjM1LCBwcm90ZWN0ZWQ6MjM1LCByZWFkb25seToyMzcsIGluc3RhbmNlb2Y6MjU2LCBzYXRpc2ZpZXM6MjU5LCBpbXBvcnQ6MjkyLCBrZXlvZjozNDksIHVuaXF1ZTozNTMsIGluZmVyOjM1OSwgYXNzZXJ0czozOTUsIGlzOjM5NywgYWJzdHJhY3Q6NDE3LCBpbXBsZW1lbnRzOjQxOSwgdHlwZTo0MjEsIGxldDo0MjQsIHZhcjo0MjYsIHVzaW5nOjQyOSwgaW50ZXJmYWNlOjQzNSwgZW51bTo0MzksIG5hbWVzcGFjZTo0NDUsIG1vZHVsZTo0NDcsIGRlY2xhcmU6NDUxLCBnbG9iYWw6NDU1LCBkZWZlcjo0NzEsIGZvcjo0NzYsIG9mOjQ4NSwgd2hpbGU6NDg4LCB3aXRoOjQ5MiwgZG86NDk2LCBpZjo1MDAsIGVsc2U6NTAyLCBzd2l0Y2g6NTA2LCBjYXNlOjUxMiwgdHJ5OjUxOCwgY2F0Y2g6NTIyLCBmaW5hbGx5OjUyNiwgcmV0dXJuOjUzMCwgdGhyb3c6NTM0LCBicmVhazo1MzgsIGNvbnRpbnVlOjU0MiwgZGVidWdnZXI6NTQ2fTtcbmNvbnN0IHNwZWNfd29yZCA9IHtfX3Byb3RvX186bnVsbCxhc3luYzoxMjksIGdldDoxMzEsIHNldDoxMzMsIGRlY2xhcmU6MTk1LCBwdWJsaWM6MTk3LCBwcml2YXRlOjE5NywgcHJvdGVjdGVkOjE5Nywgc3RhdGljOjE5OSwgYWJzdHJhY3Q6MjAxLCBvdmVycmlkZToyMDMsIHJlYWRvbmx5OjIwOSwgYWNjZXNzb3I6MjExLCBuZXc6NDAxfTtcbmNvbnN0IHNwZWNfTGVzc1RoYW4gPSB7X19wcm90b19fOm51bGwsXCI8XCI6MTkzfTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIkRnxRJVRRbE9PTyVbUWxPT08nX1FwT09QKGxPYE9PTyp6USEwTXhPJyNDaU8rUk8jdE8nI0NqTythTyZqTycjQ2pPK29PI0BJdE8nI0RhTy5RUWxPJyNEZ08uYlFsTycjRHJPJVtRbE8nI0R6TzBmUWxPJyNFU09PUSEwTGYnI0VbJyNFW08xUFFgTycjRVhPT1FPJyNFcCcjRXBPT1FPJyNJbCcjSWxPMVhRYE8nI0dzTzFkUWBPJyNFb08xaVFgTycjRW9PM2hRITBNeE8nI0pyTzZbUSEwTXhPJyNKc082dVFgTycjRl1PNnpRLFVPJyNGdE9PUSEwTGYnI0ZmJyNGZk83Vk83ZE8nI0ZmTzlYUU1oTycjRnxPOWBRYE8nI0Z7T09RITBMZicjSnMnI0pzT09RITBMYicjSnInI0pyTzllUWBPJyNHd09PUVsnI0tfJyNLX085cFFgTycjSVlPOXVRITBMck8nI0laT09RWycjSmAnI0pgT09RWycjSV8nI0lfUWBRbE9PUWBRbE9PTzl9USFMXk8nI0R2TzpVUWxPJyNFT086XVFsTycjRVFPOWtRYE8nI0dzTzpkUU1oTycjQ29POnJRYE8nI0VuTzp9UWBPJyNFeU87aFFNaE8nI0ZlTzt4UWBPJyNHc09PUU8nI0tgJyNLYE87fVFgTycjS2BPPF1RYE8nI0d7TzxdUWBPJyNHfE88XVFgTycjSE9POWtRYE8nI0hSTz1TUWBPJyNIVU8+a1FgTycjQ2VPPntRYE8nI0hjTz9UUWBPJyNIaU8/VFFgTycjSGtPYFFsTycjSG1PP1RRYE8nI0hvTz9UUWBPJyNIck8/WVFgTycjSHhPP19RITBMc08nI0lPTyVbUWxPJyNJUU8/alEhMExzTycjSVNPP3VRITBMc08nI0lVTzl1USEwTHJPJyNJV09AUVEhME14TycjQ2lPQVNRcE8nI0RsUU9RYE9PTyVbUWxPJyNFUU9BalFgTycjRVRPOmRRTWhPJyNFbk9BdVFgTycjRW5PQlFRIWJPJyNGZU9PUVsnI0NnJyNDZ09PUSEwTGInI0RxJyNEcU9PUSEwTGInI0p2JyNKdk8lW1FsTycjSnZPT1FPJyNKeScjSnlPT1FPJyNJaCcjSWhPQ1FRcE8nI0VnT09RITBMYicjRWYnI0VmT09RITBMYicjSn0nI0p9T0N8USEwTVNPJyNFZ09EV1FwTycjRVdPT1FPJyNKeCcjSnhPRGxRcE8nI0p5T0V5UXBPJyNFV09EV1FwTycjRWdQRldPJjJEak8nI0NiUE9PTylDRH0pQ0R9T09PTycjSWAnI0lgT0ZjTyN0Tyw1OVVPT1EhMExoLDU5VSw1OVVPT09PJyNJYScjSWFPRnFPJmpPLDU5VU9HUFEhTF5PJyNEY09PT08nI0ljJyNJY09HV08jQEl0Tyw1OXtPT1EhMExmLDU5eyw1OXtPR2ZRbE8nI0lkT0d5UWBPJyNKdE9JeFEhZk8nI0p0Tyt9UWxPJyNKdE9KUFFgTyw1OlJPSmdRYE8nI0VwT0p0UWBPJyNLVE9LUFFgTycjS1NPS1BRYE8nI0tTT0tYUWBPLDU7Xk9LXlFgTycjS1JPT1EhMExuLDU6Xiw1Ol5PS2VRbE8sNTpeT01jUSEwTXhPLDU6Zk9OU1FgTyw1Om5PTm1RITBMck8nI0tRT050UWBPJyNLUE85ZVFgTycjS1BPISBZUWBPJyNLUE8hIGJRYE8sNTtdTyEgZ1FgTycjS1BPISNsUSFmTycjSnNPT1EhMExoJyNDaScjQ2lPJVtRbE8nI0VTTyEkW1EhZk8sNTpzT09RUycjSnonI0p6T09RTy1FPGotRTxqTzlrUWBPLDU9X08hJHJRYE8sNT1fTyEkd1FsTyw1O1pPISZ6UU1oTycjRWtPIShlUWBPLDU7Wk8hKGpRbE8nI0R5TyEodFFwTyw1O2RPISh8UXBPLDU7ZE8lW1FsTyw1O2RPT1FbJyNGVCcjRlRPT1FbJyNGVicjRlZPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlT09RWycjRlonI0ZaTyEpW1FsTyw1O3RPT1EhMExmLDU7eSw1O3lPT1EhMExmLDU7eiw1O3pPT1EhMExmLDU7fCw1O3xPJVtRbE8nI0lwTyErX1EhMExyTyw1PGlPJVtRbE8sNTtlTyEmelFNaE8sNTtlTyErfFFNaE8sNTtlTyEtblFNaE8nI0VeTyVbUWxPLDU7d09PUSEwTGYsNTt7LDU7e08hLXVRLFVPJyNGak8hLnJRLFVPJyNLWE8hLl5RLFVPJyNLWE8hLnlRLFVPJyNLWE9PUU8nI0tYJyNLWE8hL19RLFVPLDU8U09PT1csNTxgLDU8YE8hL3BRbE8nI0Z2T09PVycjSW8nI0lvTzdWTzdkTyw1PFFPIS93USxVTycjRnhPT1EhMExmLDU8USw1PFFPITBoUSRJVU8nI0N5T09RITBMaCcjQ30nI0N9TyEwe08jQEl0TycjRFJPITFpUU1qTyw1PGVPITFwUWBPLDU8aE8hM1lRKENXTycjR1hPITNqUWBPJyNHWU8hM29RYE8nI0dZTyE1X1EoQ1dPJyNHXk8hNmRRcE8nI0diT09RTycjR24nI0duTyEsVFFNaE8nI0dtT09RTycjR3AnI0dwTyEsVFFNaE8nI0dvTyE3VlEkSVVPJyNKbE9PUSEwTGgnI0psJyNKbE8hN2FRYE8nI0prTyE3b1FgTycjSmpPITd3UWBPJyNDdU9PUSEwTGgnI0N7JyNDe08hOFlRYE8nI0N9T09RITBMaCcjRFYnI0RWT09RITBMaCcjRFgnI0RYTyE4X1FgTyw1PGVPMVNRYE8nI0RaTyEsVFFNaE8nI0dQTyEsVFFNaE8nI0dSTyE4Z1FgTycjR1RPIThsUWBPJyNHVU8hM29RYE8nI0dbTyEsVFFNaE8nI0dhTzxdUWBPJyNKa08hOHFRYE8nI0VxTyE5YFFgTyw1PGdPT1EhMExiJyNDcicjQ3JPITloUWBPJyNFck8hOmJRcE8nI0VzT09RITBMYicjS1InI0tSTyE6aVEhMExyTycjS2FPOXVRITBMck8sNT1jT2BRbE8sNT50T09RWycjSmgnI0poT09RWyw1PnUsNT51T09RWy1FPF0tRTxdTyE8aFEhME14Tyw1OmJPITpdUXBPLDU6YE8hP1JRITBNeE8sNTpqTyVbUWxPLDU6ak8hQWlRITBNeE8sNTpsT09RTyw1QHosNUB6TyFCWVFNaE8sNT1fTyFCaFEhMExyTycjSmlPOWBRYE8nI0ppTyFCeVEhMExyTyw1OVpPIUNVUXBPLDU5Wk8hQ15RTWhPLDU5Wk86ZFFNaE8sNTlaTyFDaVFgTyw1O1pPIUNxUWBPJyNIYk8hRFZRYE8nI0tkTyVbUWxPLDU7fU8hOl1RcE8sNTxQTyFEX1FgTyw1PXpPIURkUWBPLDU9ek8hRGlRYE8sNT16TyFEd1FgTyw1PXpPOXVRITBMck8sNT16TzxdUWBPLDU9ak9PUU8nI0N5JyNDeU8hRU9RcE8sNT1nTyFFV1FNaE8sNT1oTyFFY1FgTyw1PWpPIUVoUSFiTyw1PW1PIUVwUWBPJyNLYE8/WVFgTycjSFdPOWtRYE8nI0hZTyFFdVFgTycjSFlPOmRRTWhPJyNIW08hRXpRYE8nI0hbT09RWyw1PXAsNT1wTyFGUFFgTycjSF1PIUZiUWBPJyNDb08hRmdRYE8sNTlQTyFGcVFgTyw1OVBPIUh2UWxPLDU5UE9PUVssNTlQLDU5UE8hSVdRITBMck8sNTlQTyVbUWxPLDU5UE8hS2NRbE8nI0hlT09RWycjSGYnI0hmT09RWycjSGcnI0hnT2BRbE8sNT19TyFLeVFgTyw1PX1PYFFsTyw1PlRPYFFsTyw1PlZPIUxPUWBPLDU+WE9gUWxPLDU+Wk8hTFRRYE8sNT5eTyFMWVFsTyw1PmRPT1FbLDU+aiw1PmpPJVtRbE8sNT5qTzl1USEwTHJPLDU+bE9PUVssNT5uLDU+bk8jIWRRYE8sNT5uT09RWyw1PnAsNT5wTyMhZFFgTyw1PnBPT1FbLDU+ciw1PnJPIyNRUXBPJyNEX08lW1FsTycjSnZPIyNzUXBPJyNKdk8jI31RcE8nI0RtTyMkYFFwTycjRG1PIyZxUWxPJyNEbU8jJnhRYE8nI0p1TyMnUVFgTyw1OldPIydWUWBPJyNFdE8jJ2VRYE8nI0tVTyMnbVFgTyw1O19PIydyUXBPJyNEbU8jKFBRcE8nI0VWT09RITBMZiw1Om8sNTpvTyVbUWxPLDU6b08jKFdRYE8sNTpvTz9ZUWBPLDU7WU8hQ1VRcE8sNTtZTyFDXlFNaE8sNTtZTzpkUU1oTyw1O1lPIyhgUWBPLDVAYk8jKGVRMDdkTyw1OnNPT1FPLUU8Zi1FPGZPIylrUSEwTVNPLDU7Uk9EV1FwTyw1OnJPIyl1UXBPLDU6ck9EV1FwTyw1O1JPIUJ5USEwTHJPLDU6ck9PUSEwTGInI0VqJyNFak9PUU8sNTtSLDU7Uk8lW1FsTyw1O1JPIypTUSEwTHJPLDU7Uk8jKl9RITBMck8sNTtSTyFDVVFwTyw1OnJPT1FPLDU7WCw1O1hPIyptUSEwTHJPLDU7UlBPT08nI0leJyNJXlAjK1JPJjJEak8sNTh8UE9PTyw1OHwsNTh8T09PTy1FPF4tRTxeT09RITBMaDFHLnAxRy5wT09PTy1FPF8tRTxfT09PTyw1OX0sNTl9TyMrXlEhYk8sNTl9T09PTy1FPGEtRTxhT09RITBMZjFHL2cxRy9nTyMrY1EhZk8sNT9PTyt9UWxPLDU/T09PUU8sNT9VLDU/VU8jK21RbE8nI0lkT09RTy1FPGItRTxiTyMrelFgTyw1QGBPIyxTUSFmTyw1QGBPIyxaUWBPLDVAbk9PUSEwTGYxRy9tMUcvbU8lW1FsTyw1QG9PIyxjUWBPJyNJak9PUU8tRTxoLUU8aE8jLFpRYE8sNUBuT09RITBMYjFHMHgxRzB4T09RITBMbjFHL3gxRy94T09RITBMbjFHMFkxRzBZTyVbUWxPLDVAbE8jLHdRITBMck8sNUBsTyMtWVEhMExyTyw1QGxPIy1hUWBPLDVAa085ZVFgTyw1QGtPIy1pUWBPLDVAa08jLXdRYE8nI0ltTyMtYVFgTyw1QGtPT1EhMExiMUcwdzFHMHdPISh0UXBPLDU6dU8hKVBRcE8sNTp1T09RUyw1OncsNTp3TyMuaVFkTyw1OndPIy5xUU1oTzFHMnlPOWtRYE8xRzJ5T09RITBMZjFHMHUxRzB1TyMvUFEhME14TzFHMHVPIzBVUSEwTXZPLDU7Vk9PUSEwTGgnI0dXJyNHV08jMHJRITBNek8nI0psTyEkd1FsTzFHMHVPIzJ9USFmTycjSndPJVtRbE8nI0p3TyMzWFFgTyw1OmVPT1EhMExoJyNEXycjRF9PT1EhMExmMUcxTzFHMU9PJVtRbE8xRzFPT09RITBMZjFHMWYxRzFmTyMzXlFgTzFHMU9PIzVyUSEwTXhPMUcxUE8jNXlRITBNeE8xRzFQTyM4YVEhME14TzFHMVBPIzhoUSEwTXhPMUcxUE8jO09RITBNeE8xRzFQTyM9ZlEhME14TzFHMVBPIz1tUSEwTXhPMUcxUE8jPXRRITBNeE8xRzFQTyNAW1EhME14TzFHMVBPI0BjUSEwTXhPMUcxUE8jQnBRP010TycjQ2lPI0RrUT9NdE8xRzFgTyNEclE/TXRPJyNKc08jRVZRITBNeE8sNT9bT09RITBMYi1FPG4tRTxuTyNHZFEhME14TzFHMVBPI0hhUSEwTXpPMUcxUE9PUSEwTGYxRzFQMUcxUE8jSWRRTWpPJyNKfE8jSW5RYE8sNTp4TyNJc1EhME14TzFHMWNPI0pnUSxVTyw1PFdPI0pvUSxVTyw1PFhPI0p3USxVTycjRm9PI0tgUWBPJyNGbk9PUU8nI0tZJyNLWU9PUU8nI0luJyNJbk8jS2VRLFVPMUcxbk9PUSEwTGYxRzFuMUcxbk9PT1cxRzF5MUcxeU8jS3ZRP010TycjSnJPI0xRUWBPLDU8Yk8hKVtRbE8sNTxiT09PVy1FPG0tRTxtT09RITBMZjFHMWwxRzFsTyNMVlFwTycjS1hPT1EhMExmLDU8ZCw1PGRPI0xfUXBPLDU8ZE8jTGRRTWhPJyNEVE9PT08nI0liJyNJYk8jTGtPI0BJdE8sNTltT09RITBMaCw1OW0sNTltTyVbUWxPMUcyUE8hOGxRYE8nI0lyTyNMdlFgTyw1PHpPT1EhMExoLDU8dyw1PHdPISxUUU1oTycjSXVPI01kUU1qTyw1PVhPISxUUU1oTycjSXdPI05WUU1qTyw1PVpPISZ6UU1oTyw1PV1PT1FPMUcyUzFHMlNPI05hUSFkTycjQ3JPI050UShDV08nI0VyTyQgfFFwTycjR2JPJCFkUSFkTyw1PHNPJCFrUWBPJyNLW085ZVFgTycjS1tPJCF5UWBPLDU8dU8kI2FRIWRPJyNDe08hLFRRTWhPLDU8dE8kI2tRYE8nI0daTyQkUFFgTyw1PHRPJCRVUSFkTycjR1dPJCRjUSFkTycjS11PJCRtUWBPJyNLXU8hJnpRTWhPJyNLXU8kJHJRYE8sNTx4TyQkd1FsTycjSnZPJCVSUXBPJyNHY08jJGBRcE8nI0djTyQlZFFgTycjR2dPITNvUWBPJyNHa08kJWlRITBMck8nI0l0TyQldFFwTyw1PHxPT1EhMExwLDU8fCw1PHxPJCV7UXBPJyNHY08kJllRcE8nI0dkTyQma1FwTycjR2RPJCZwUU1qTyw1PVhPJCdRUU1qTyw1PVpPT1EhMExoLDU9Xiw1PV5PISxUUU1oTyw1QFZPISxUUU1oTyw1QFZPJCdiUWBPJyNJeU8kJ3ZRYE8sNUBVTyQoT1FgTyw1OWFPT1EhMExoLDU5aSw1OWlPJChUUWBPLDVAVk8kKVRRJElZTyw1OXVPT1EhMExoJyNKcCcjSnBPJCl2UU1qTyw1PGtPJCppUU1qTyw1PG1PQHpRYE8sNTxvT09RITBMaCw1PHAsNTxwTyQqc1FgTyw1PHZPJCp4UU1qTyw1PHtPJCtZUWBPJyNLUE8hJHdRbE8xRzJSTyQrX1FgTzFHMlJPOWVRYE8nI0tTTzllUWBPJyNFdE8lW1FsTycjRXRPOWVRYE8nI0l7TyQrZFEhMExyTyw1QHtPT1FbMUcyfTFHMn1PT1FbMUc0YDFHNGBPT1EhMExmMUcvfDFHL3xPT1EhMExmMUcvejFHL3pPJC1mUSEwTXhPMUcwVU9PUVsxRzJ5MUcyeU8hJnpRTWhPMUcyeU8lW1FsTzFHMnlPIy50UWBPMUcyeU8kL2pRTWhPJyNFa09PUSEwTGIsNUBULDVAVE8kL3dRITBMck8sNUBUT09RWzFHLnUxRy51TyFCeVEhMExyTzFHLnVPIUNVUXBPMUcudU8hQ15RTWhPMUcudU8kMFlRYE8xRzB1TyQwX1FgTycjQ2lPJDBqUWBPJyNLZU8kMHJRYE8sNT18TyQwd1FgTycjS2VPJDB8UWBPJyNLZU8kMVtRYE8nI0pSTyQxalFgTyw1QU9PJDFyUSFmTzFHMWlPT1EhMExmMUcxazFHMWtPOWtRYE8xRzNmT0B6UWBPMUczZk8kMXlRYE8xRzNmTyQyT1FgTzFHM2ZPIURpUWBPMUczZk85dVEhMExyTzFHM2ZPT1FbMUczZjFHM2ZPIUVjUWBPMUczVU8hJnpRTWhPMUczUk8kMlRRYE8xRzNST09RWzFHM1MxRzNTTyEmelFNaE8xRzNTTyQyWVFgTzFHM1NPJDJiUXBPJyNIUU9PUVsxRzNVMUczVU8hNl9RcE8nI0l9TyFFaFEhYk8xRzNYT09RWzFHM1gxRzNYT09RWyw1PXIsNT1yTyQyalFNaE8sNT10TzlrUWBPLDU9dE8kJWRRYE8sNT12TzlgUWBPLDU9dk8hQ1VRcE8sNT12TyFDXlFNaE8sNT12TzpkUU1oTyw1PXZPJDJ4UWBPJyNLY08kM1RRYE8sNT13T09RWzFHLmsxRy5rTyQzWVEhMExyTzFHLmtPQHpRYE8xRy5rTyQzZVFgTzFHLmtPOXVRITBMck8xRy5rTyQ1bVEhZk8sNUFRTyQ1elFgTyw1QVFPOWVRYE8sNUFRTyQ2VlFsTyw1PlBPJDZeUWBPLDU+UE9PUVsxRzNpMUczaU9gUWxPMUczaU9PUVsxRzNvMUczb09PUVsxRzNxMUczcU8/VFFgTzFHM3NPJDZjUWxPMUczdU8kOmdRbE8nI0h0T09RWzFHM3gxRzN4TyQ6dFFgTycjSHpPP1lRYE8nI0h8T09RWzFHNE8xRzRPTyQ6fFFsTzFHNE9POXVRITBMck8xRzRVT09RWzFHNFcxRzRXT09RITBMYicjR18nI0dfTzl1USEwTHJPMUc0WU85dVEhMExyTzFHNFtPJD9UUWBPLDVAYk8hKVtRbE8sNTtgTzllUWBPLDU7YE8/WVFgTyw1OlhPISlbUWxPLDU6WE8hQ1VRcE8sNTpYTyQ/WVE/TXRPLDU6WE9PUU8sNTtgLDU7YE8kP2RRcE8nI0llTyQ/elFgTyw1QGFPT1EhMExmMUcvcjFHL3JPJEBTUXBPJyNJa08kQF5RYE8sNUBwT09RITBMYjFHMHkxRzB5TyMkYFFwTyw1OlhPT1FPJyNJZycjSWdPJEBmUXBPLDU6cU9PUSEwTG4sNTpxLDU6cU8jKFpRYE8xRzBaT09RITBMZjFHMFoxRzBaTyVbUWxPMUcwWk9PUSEwTGYxRzB0MUcwdE8/WVFgTzFHMHRPIUNVUXBPMUcwdE8hQ15RTWhPMUcwdE9PUSEwTGIxRzV8MUc1fE8hQnlRITBMck8xRzBeT09RTzFHMG0xRzBtTyVbUWxPMUcwbU8kQG1RITBMck8xRzBtTyRAeFEhMExyTzFHMG1PIUNVUXBPMUcwXk9EV1FwTzFHMF5PJEFXUSEwTHJPMUcwbU9PUU8xRzBeMUcwXk8kQWxRITBNeE8xRzBtUE9PTy1FPFstRTxbUE9PTzFHLmgxRy5oT09PTzFHL2kxRy9pTyRBdlEhYk8sNTxpTyRCT1EhZk8xRzRqT09RTzFHNHAxRzRwTyVbUWxPLDU/T08kQllRYE8xRzV6TyRCYlFgTzFHNllPJEJqUSFmTzFHNlpPOWVRYE8sNT9VTyRCdFEhME14TzFHNldPJVtRbE8xRzZXTyRDVVEhMExyTzFHNldPJENnUWBPMUc2Vk8kQ2dRYE8xRzZWTzllUWBPMUc2Vk8kQ29RYE8sNT9YTzllUWBPLDU/WE9PUU8sNT9YLDU/WE8kRFRRYE8sNT9YTyQrWVFgTyw1P1hPT1FPLUU8ay1FPGtPT1FTMUcwYTFHMGFPT1FTMUcwYzFHMGNPIy5sUWBPMUcwY09PUVs3KyhlNysoZU8hJnpRTWhPNysoZU8lW1FsTzcrKGVPJERjUWBPNysoZU8kRG5RTWhPNysoZU8kRHxRITBNek8sNT1YTyRHWFEhME16Tyw1PVpPJElkUSEwTXpPLDU9WE8kS3VRITBNek8sNT1aTyROV1EhME16Tyw1OXVPJSFdUSEwTXpPLDU8a08lJGhRITBNek8sNTxtTyUmc1EhME16Tyw1PHtPT1EhMExmNysmYTcrJmFPJSlVUSEwTXhPNysmYU8lKXhRbE8nI0lmTyUqVlFgTyw1QGNPJSpfUSFmTyw1QGNPT1EhMExmMUcwUDFHMFBPJSppUWBPNysmak9PUSEwTGY3KyZqNysmak8lKm5RP010Tyw1OmZPJVtRbE83KyZ6TyUqeFE/TXRPLDU6Yk8lK1ZRP010Tyw1OmpPJSthUT9NdE8sNTpsTyUra1FNaE8nI0lpTyUrdVFgTyw1QGhPT1EhMExoMUcwZDFHMGRPT1FPMUcxcjFHMXJPT1FPMUcxczFHMXNPJSt9USFqTyw1PFpPISlbUWxPLDU8WU9PUU8tRTxsLUU8bE9PUSEwTGY3KydZNysnWU9PT1c3KydlNysnZU9PT1cxRzF8MUcxfE8lLFlRYE8xRzF8T09RITBMZjFHMk8xRzJPT09PTyw1OW8sNTlvTyUsX1EhZE8sNTlvT09PTy1FPGAtRTxgT09RITBMaDFHL1gxRy9YTyUsZlEhME14TzcrJ2tPT1EhMExoLDU/Xiw1P15PJS1ZUU1oTzFHMmZQJS1hUWBPJyNJclBPUSEwTGgtRTxwLUU8cE8lLX1RTWpPLDU/YU9PUSEwTGgtRTxzLUU8c08lLnBRTWpPLDU/Y09PUSEwTGgtRTx1LUU8dU8lLnpRIWRPMUcyd08lL1JRIWRPJyNDck8lL2lRTWhPJyNLU08kJHdRbE8nI0p2T09RITBMaDFHMl8xRzJfTyUvc1FgTycjSXFPJTBbUWBPLDVAdk8lMFtRYE8sNUB2TyUwZFFgTyw1QHZPJTBvUWBPLDVAdk9PUU8xRzJhMUcyYU8lMH1RTWpPMUcyYE8kK1lRYE8nI0tbTyEsVFFNaE8xRzJgTyUxX1EoQ1dPJyNJc08lMWxRYE8sNUB3TyEmelFNaE8sNUB3TyUxdFEhZE8sNUB3T09RITBMaDFHMmQxRzJkTyU0VVEhZk8nI0NpTyU0YFFgTyw1PVBPT1EhMExiLDU8fSw1PH1PJTRoUXBPLDU8fU9PUSEwTGIsNT1PLDU9T09Dd1FgTyw1PH1PJTRzUXBPLDU8fU9PUSEwTGIsNT1SLDU9Uk8kK1lRYE8sNT1WT09RTyw1P2AsNT9gT09RTy1FPHItRTxyT09RITBMcDFHMmgxRzJoTyMkYFFwTyw1PH1PJCR3UWxPLDU9UE8lNVJRYE8sNT1PTyU1XlFwTyw1PU9PISxUUU1oTycjSXVPJTZXUU1qTzFHMnNPISxUUU1oTycjSXdPJTZ5UU1qTzFHMnVPJTdUUU1qTzFHNXFPJTdfUU1qTzFHNXFPT1FPLDU/ZSw1P2VPT1FPLUU8dy1FPHdPT1FPMUcuezFHLntPISxUUU1oTzFHNXFPISxUUU1oTzFHNXFPITpdUXBPLDU5d08lW1FsTyw1OXdPT1EhMExoLDU8aiw1PGpPJTdsUWBPMUcyWk8hLFRRTWhPMUcyYk8lN3FRITBNeE83KydtT09RITBMZjcrJ203KydtTyEkd1FsTzcrJ21PJThlUWBPLDU7YE9PUSEwTGIsNT9nLDU/Z09PUSEwTGItRTx5LUU8eU8lOGpRIWRPJyNLXk8jKFpRYE83KyhlTzRVUSFmTzcrKGVPJERmUWBPNysoZU8lOHRRITBNdk8nI0NpTyU5WFEhME12Tyw1PVNPJTlsUWBPLDU9U08lOXRRYE8sNT1TT09RITBMYjFHNW8xRzVvT09RWzcrJGE3KyRhTyFCeVEhMExyTzcrJGFPIUNVUXBPNyskYU8hJHdRbE83KyZhTyU5eVFgTycjSlFPJTpiUWBPLDVBUE9PUU8xRzNoMUczaE85a1FgTyw1QVBPJTpiUWBPLDVBUE8lOmpRYE8sNUFQT09RTyw1P20sNT9tT09RTy1FPVAtRT1QT09RITBMZjcrJ1Q3KydUTyU6b1FgTzcrKVFPOXVRITBMck83KylRTzlrUWBPNyspUU9AelFgTzcrKVFPJTp0UWBPNyspUU9PUVs3KylRNyspUU9PUVs3KyhwNysocE8lOnlRITBNdk83KyhtTyEmelFNaE83KyhtTyFFXlFgTzcrKG5PT1FbNysobjcrKG5PISZ6UU1oTzcrKG5PJTtUUWBPJyNLYk8lO2BRYE8sNT1sT09RTyw1P2ksNT9pT09RTy1FPHstRTx7T09RWzcrKHM3KyhzTyU8clFwTycjSFpPT1FbMUczYDFHM2BPISZ6UU1oTzFHM2BPJVtRbE8xRzNgTyU8eVFgTzFHM2BPJT1VUU1oTzFHM2BPOXVRITBMck8xRzNiTyQlZFFgTzFHM2JPOWBRYE8xRzNiTyFDVVFwTzFHM2JPIUNeUU1oTzFHM2JPJT1kUWBPJyNKUE8lPXhRYE8sNUB9TyU+UVFwTyw1QH1PT1EhMExiMUczYzFHM2NPT1FbNyskVjcrJFZPQHpRYE83KyRWTzl1USEwTHJPNyskVk8lPl1RYE83KyRWTyVbUWxPMUc2bE8lW1FsTzFHNm1PJT5iUSEwTHJPMUc2bE8lPmxRbE8xRzNrTyU+c1FgTzFHM2tPJT54UWxPMUcza09PUVs3KylUNyspVE85dVEhMExyTzcrKV9PYFFsTzcrKWFPT1FbJyNLaCcjS2hPT1FbJyNKUycjSlNPJT9QUWxPLDU+YE9PUVssNT5gLDU+YE8lW1FsTycjSHVPJT9eUWBPJyNId09PUVssNT5mLDU+Zk85ZVFgTyw1PmZPT1FbLDU+aCw1PmhPT1FbNyspajcrKWpPT1FbNyspcDcrKXBPT1FbNyspdDcrKXRPT1FbNyspdjcrKXZPJT9jUXBPMUc1fE8lP31RP010TzFHMHpPJUBYUWBPMUcwek9PUU8xRy9zMUcvc08lQGRRP010TzFHL3NPP1lRYE8xRy9zTyEpW1FsTycjRG1PT1FPLDU/UCw1P1BPT1FPLUU8Yy1FPGNPT1FPLDU/Viw1P1ZPT1FPLUU8aS1FPGlPIUNVUXBPMUcvc09PUU8tRTxlLUU8ZU9PUSEwTG4xRzBdMUcwXU9PUSEwTGY3KyV1NysldU8jKFpRYE83KyV1T09RITBMZjcrJmA3KyZgTz9ZUWBPNysmYE8hQ1VRcE83KyZgT09RTzcrJXg3KyV4TyRBbFEhME14TzcrJlhPT1FPNysmWDcrJlhPJVtRbE83KyZYTyVAblEhMExyTzcrJlhPIUJ5USEwTHJPNysleE8hQ1VRcE83KyV4TyVAeVEhMExyTzcrJlhPJUFYUSEwTXhPNysrck8lW1FsTzcrK3JPJUFpUWBPNysrcU8lQWlRYE83KytxT09RTzFHNHMxRzRzTzllUWBPMUc0c08lQXFRYE8xRzRzT09RUzcrJX03KyV9TyMoWlFgTzw8TFBPNFVRIWZPPDxMUE8lQlBRYE88PExQT09RWzw8TFA8PExQTyEmelFNaE88PExQTyVbUWxPPDxMUE8lQlhRYE88PExQTyVCZFEhME16Tyw1P2FPJURvUSEwTXpPLDU/Y08lRnpRITBNek8xRzJgTyVJXVEhME16TzFHMnNPJUtoUSEwTXpPMUcydU8lTXNRIWZPLDU/UU8lW1FsTyw1P1FPT1FPLUU8ZC1FPGRPJU19UWBPMUc1fU9PUSEwTGY8PEpVPDxKVU8lTlZRP010TzFHMHVPJiFeUT9NdE8xRzFQTyYhZVE/TXRPMUcxUE8mJGZRP010TzFHMVBPJiRtUT9NdE8xRzFQTyYmblE/TXRPMUcxUE8mKG9RP010TzFHMVBPJih2UT9NdE8xRzFQTyYofVE/TXRPMUcxUE8mK09RP010TzFHMVBPJitWUT9NdE8xRzFQTyYrXlEhME14Tzw8SmZPJi1VUT9NdE8xRzFQTyYuUlE/TXZPMUcxUE8mL1VRP012TycjSmxPJjFbUT9NdE8xRzFjTyYxaVE/TXRPMUcwVU8mMXNRTWpPLDU/VE9PUU8tRTxnLUU8Z08hKVtRbE8nI0ZxT09RTycjS1onI0taT09RTzFHMXUxRzF1TyYxfVFgTzFHMXRPJjJTUT9NdE8sNT9bT09PVzcrJ2g3KydoT09PTzFHL1oxRy9aTyYyXlEhZE8xRzR4T09RITBMaDcrKFE3KyhRUCEmelFNaE8sNT9eTyEsVFFNaE83KyhjTyYyZVFgTyw1P11POWVRYE8sNT9dTyQrWVFgTyw1P11PT1FPLUU8by1FPG9PJjJzUWBPMUc2Yk8mMnNRYE8xRzZiTyYye1FgTzFHNmJPJjNXUU1qTzcrJ3pPJjNoUSFkTyw1P19PJjNyUWBPLDU/X08hJnpRTWhPLDU/X09PUU8tRTxxLUU8cU8mM3dRIWRPMUc2Y08mNFJRYE8xRzZjTyY0WlFgTzFHMmtPISZ6UU1oTzFHMmtPT1EhMExiMUcyaTFHMmlPT1EhMExiMUcyajFHMmpPJTRoUXBPMUcyaU8hQ1VRcE8xRzJpT0N3UWBPMUcyaU9PUSEwTGIxRzJxMUcycU8mNGBRcE8xRzJpTyY0blFgTzFHMmtPJCtZUWBPMUcyak9Dd1FgTzFHMmpPJCR3UWxPMUcya08mNHZRYE8xRzJqTyY1alFNak8sNT9hT09RITBMaC1FPHQtRTx0TyY2XVFNak8sNT9jT09RITBMaC1FPHYtRTx2TyEsVFFNaE83KytdTyY2Z1FNak83KytdTyY2cVFNak83KytdT09RITBMaDFHL2MxRy9jTyY3T1FgTzFHL2NPT1EhMExoNysndTcrJ3VPJjdUUU1qTzcrJ3xPJjdlUSEwTXhPPDxLWE9PUSEwTGY8PEtYPDxLWE8mOFhRYE8xRzB6TyEmelFNaE8nI0l6TyY4XlFgTyw1QHhPJjpgUSFmTzw8TFBPISZ6UU1oTzFHMm5PJjpnUSEwTHJPMUcybk9PUVs8PEd7PDxHe08hQnlRITBMck88PEd7TyY6eFEhME14Tzw8SXtPT1EhMExmPDxJezw8SXtPT1FPLDU/bCw1P2xPJjtsUWBPLDU/bE8mO3FRYE8sNT9sT09RTy1FPU8tRT1PTyY8UFFgTzFHNmtPJjxQUWBPMUc2a085a1FgTzFHNmtPQHpRYE88PExsT09RWzw8TGw8PExsTyY8WFFgTzw8TGxPOXVRITBMck88PExsTzlrUWBPPDxMbE9PUVs8PExYPDxMWE8lOnlRITBNdk88PExYT09RWzw8TFk8PExZTyFFXlFgTzw8TFlPJjxeUXBPJyNJfE8mPGlRYE8sNUB8TyEpW1FsTyw1QHxPT1FbMUczVzFHM1dPT1FPJyNKTycjSk9POXVRITBMck8nI0pPTyY8cVFwTyw1PXVPT1FbLDU9dSw1PXVPJjx4UXBPJyNFZ08mPVBRcE8nI0dlTyY9VVFgTzcrKHpPJj1aUWBPNysoek9PUVs3Kyh6Nysoek8hJnpRTWhPNysoek8lW1FsTzcrKHpPJj1jUWBPNysoek9PUVs3Kyh8NysofE85dVEhMExyTzcrKHxPJCVkUWBPNysofE85YFFgTzcrKHxPIUNVUXBPNysofE8mPW5RYE8sNT9rT09RTy1FPH0tRTx9T09RTycjSF4nI0heTyY9eVFgTzFHNmlPOXVRITBMck88PEdxT09RWzw8R3E8PEdxT0B6UWBPPDxHcU8mPlJRYE83KyxXTyY+V1FgTzcrLFhPJVtRbE83KyxXTyVbUWxPNyssWE9PUVs3KylWNyspVk8mPl1RYE83KylWTyY+YlFsTzcrKVZPJj5pUWBPNyspVk9PUVs8PEx5PDxMeU9PUVs8PEx7PDxMe09PUVstRT1RLUU9UU9PUVsxRzN6MUczek8mPm5RYE8sNT5hT09RWyw1PmMsNT5jTyY+c1FgTzFHNFFPOWVRYE83KyZmTyEpW1FsTzcrJmZPT1FPNyslXzcrJV9PJj54UT9NdE8xRzZaTz9ZUWBPNyslX09PUSEwTGY8PElhPDxJYU9PUSEwTGY8PEl6PDxJek8/WVFgTzw8SXpPT1FPPDxJczw8SXNPJEFsUSEwTXhPPDxJc08lW1FsTzw8SXNPT1FPPDxJZDw8SWRPIUJ5USEwTHJPPDxJZE8mP1NRITBMck88PElzTyY/X1EhME14Tzw9IF5PJj9vUWBPPD0gXU9PUU83KypfNysqX085ZVFgTzcrKl9PT1FbQU5Ba0FOQWtPJj93USFmT0FOQWtPISZ6UU1oT0FOQWtPIyhaUWBPQU5Ba080VVEhZk9BTkFrTyZAT1FgT0FOQWtPJVtRbE9BTkFrTyZAV1EhME16TzcrJ3pPJkJpUSEwTXpPLDU/YU8mRHRRITBNek8sNT9jTyZHUFEhME16TzcrJ3xPJkliUSFmTzFHNGxPJklsUT9NdE83KyZhTyZLcFE/TXZPLDU9WE8mTXdRP012Tyw1PVpPJk5YUT9Ndk8sNT1YTyZOaVE/TXZPLDU9Wk8mTnlRP012Tyw1OXVPJyNQUT9Ndk8sNTxrTyclU1E/TXZPLDU8bU8nJ2hRP012Tyw1PHtPJyleUT9NdE83KydrTycpa1E/TXRPNysnbU8nKXhRYE8sNTxdT09RTzcrJ2A3KydgT09RITBMaDcrKmQ3KypkTycpfVFNak88PEt9T09RTzFHNHcxRzR3TycqVVFgTzFHNHdPJyphUWBPMUc0d08nKm9RYE83Kyt8Tycqb1FgTzcrK3xPISZ6UU1oTzFHNHlPJyp3USFkTzFHNHlPJytSUWBPNysrfU8nK1pRYE83KyhWTycrZlEhZE83KyhWT09RITBMYjcrKFQ3KyhUT09RITBMYjcrKFU3KyhVTyFDVVFwTzcrKFRPQ3dRYE83KyhUTycrcFFgTzcrKFZPISZ6UU1oTzcrKFZPJCtZUWBPNysoVU8nK3VRYE83KyhWT0N3UWBPNysoVU8nK31RTWpPPDxOd08hLFRRTWhPPDxOd09PUSEwTGg3KyR9NyskfU8nLFhRIWRPLDU/Zk9PUU8tRTx4LUU8eE8nLGNRITBNdk83KyhZTyEmelFNaE83KyhZT09RW0FOPWdBTj1nTzlrUWBPMUc1V09PUU8xRzVXMUc1V08nLHNRYE8xRzVXTycseFFgTzcrLFZPJyx4UWBPNyssVk85dVEhMExyT0FOQldPQHpRYE9BTkJXT09RW0FOQldBTkJXTyctUVFgT0FOQldPT1FbQU5Bc0FOQXNPT1FbQU5BdEFOQXRPJy1WUWBPLDU/aE9PUU8tRTx6LUU8ek8nLWJRP010TzFHNmhPT1FPLDU/aiw1P2pPT1FPLUU8fC1FPHxPT1FbMUczYTFHM2FPJy1sUWBPLDU9UE9PUVs8PExmPDxMZk8hJnpRTWhPPDxMZk8mPVVRYE88PExmTyctcVFgTzw8TGZPJVtRbE88PExmT09RWzw8TGg8PExoTzl1USEwTHJPPDxMaE8kJWRRYE88PExoTzlgUWBPPDxMaE8nLXlRcE8xRzVWTycuVVFgTzcrLFRPT1FbQU49XUFOPV1POXVRITBMck9BTj1dT09RWzw9IHI8PSByT09RWzw9IHM8PSBzTycuXlFgTzw9IHJPJy5jUWBPPD0gc09PUVs8PExxPDxMcU8nLmhRYE88PExxTycubVFsTzw8THFPT1FbMUczezFHM3tPP1lRYE83KylsTycudFFgTzw8SlFPJy9QUT9NdE88PEpRT09RTzw8SHk8PEh5T09RITBMZkFOP2ZBTj9mT09RT0FOP19BTj9fTyRBbFEhME14T0FOP19PT1FPQU4/T0FOP09PJVtRbE9BTj9fT09RTzw8TXk8PE15T09RW0cyN1ZHMjdWTyEmelFNaE9HMjdWTyMoWlFgT0cyN1ZPJy9aUSFmT0cyN1ZPNFVRIWZPRzI3Vk8nL2JRYE9HMjdWTycvalE/TXRPPDxKZk8nL3dRP012TzFHMmBPJzFtUT9Ndk8sNT9hTyczcFE/TXZPLDU/Y08nNXNRP012TzFHMnNPJzd2UT9Ndk8xRzJ1Tyc5eVE/TXRPPDxLWE8nOldRP010Tzw8SXtPT1FPMUcxdzFHMXdPISxUUU1oT0FOQWlPT1FPNysqYzcrKmNPJzplUWBPNysqY08nOnBRYE88PSBoTyc6eFEhZE83KyplT09RITBMYjw8S3E8PEtxTyQrWVFgTzw8S3FPQ3dRYE88PEtxTyc7U1FgTzw8S3FPISZ6UU1oTzw8S3FPT1EhMExiPDxLbzw8S29PIUNVUXBPPDxLb08nO19RIWRPPDxLcU9PUSEwTGI8PEtwPDxLcE8nO2lRYE88PEtxTyEmelFNaE88PEtxTyQrWVFgTzw8S3BPJztuUU1qT0FORGNPJzt4USEwTXZPPDxLdE9PUU83KypyNysqck85a1FgTzcrKnJPJzxZUWBPPD0gcU9PUVtHMjdyRzI3ck85dVEhMExyT0cyN3JPQHpRYE9HMjdyTyEpW1FsTzFHNVNPJzxiUWBPNyssU08nPGpRYE8xRzJrTyY9VVFgT0FOQlFPT1FbQU5CUUFOQlFPISZ6UU1oT0FOQlFPJzxvUWBPQU5CUU9PUVtBTkJTQU5CU085dVEhMExyT0FOQlNPJCVkUWBPQU5CU09PUU8nI0hfJyNIX09PUU83KypxNysqcU9PUVtHMjJ3RzIyd09PUVtBTkVeQU5FXk9PUVtBTkVfQU5FX09PUVtBTkJdQU5CXU8nPHdRYE9BTkJdT09RWzw8TVc8PE1XTyEpW1FsT0FOP2xPT1FPRzI0eUcyNHlPJEFsUSEwTXhPRzI0eU8jKFpRYE9MRCxxT09RW0xELHFMRCxxTyEmelFNaE9MRCxxTyc8fFEhZk9MRCxxTyc9VFE/TXZPNysnek8nPnlRP012Tyw1P2FPJ0B8UT9Ndk8sNT9jTydDUFE/TXZPNysnfE8nRHVRTWpPRzI3VE9PUU88PE19PDxNfU9PUSEwTGJBTkFdQU5BXU8kK1lRYE9BTkFdT0N3UWBPQU5BXU8nRVZRIWRPQU5BXU9PUSEwTGJBTkFaQU5BWk8nRV5RYE9BTkFdTyEmelFNaE9BTkFdTydFaVEhZE9BTkFdT09RITBMYkFOQVtBTkFbT09RTzw8Tl48PE5eT09RW0xELV5MRC1eTzl1USEwTHJPTEQtXk8nRXNRP010TzcrKm5PT1FPJyNHZicjR2ZPT1FbRzI3bEcyN2xPJj1VUWBPRzI3bE8hJnpRTWhPRzI3bE9PUVtHMjduRzI3bk85dVEhMExyT0cyN25PT1FbRzI3d0cyN3dPJ0V9UT9NdE9HMjVXT09RT0xEKmVMRCplT09RWyEkKCFdISQoIV1PIyhaUWBPISQoIV1PISZ6UU1oTyEkKCFdTydGWFEhME16T0cyN1RPT1EhMExiRzI2d0cyNndPJCtZUWBPRzI2d08nSGpRYE9HMjZ3T0N3UWBPRzI2d08nSHVRIWRPRzI2d08hJnpRTWhPRzI2d09PUVshJCgheCEkKCF4T09RW0xELVdMRC1XTyY9VVFgT0xELVdPT1FbTEQtWUxELVlPT1FbISk5RXchKTlFd08jKFpRYE8hKTlFd09PUSEwTGJMRCxjTEQsY08kK1lRYE9MRCxjT0N3UWBPTEQsY08nSHxRYE9MRCxjTydJWFEhZE9MRCxjT09RWyEkKCFyISQoIXJPT1FbIS5LO2MhLks7Y08nSWBRP012T0cyN1RPT1EhMExiISQoIH0hJCggfU8kK1lRYE8hJCggfU9Dd1FgTyEkKCB9TydLVVFgTyEkKCB9T09RITBMYiEpOUVpISk5RWlPJCtZUWBPISk5RWlPQ3dRYE8hKTlFaU9PUSEwTGIhLks7VCEuSztUTyQrWVFgTyEuSztUT09RITBMYiE0LzBvITQvMG9PISlbUWxPJyNEek8xUFFgTycjRVhPJ0thUSFmTycjSnJPJ0toUSFMXk8nI0R2TydLb1FsTycjRU9PJ0t2USFmTycjQ2lPJ05eUSFmTycjQ2lPISlbUWxPJyNFUU8nTm5RbE8sNTtaTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPJyNJcE8oIXFRYE8sNTxpTyEpW1FsTyw1O2VPKCF5UU1oTyw1O2VPKCRkUU1oTyw1O2VPISlbUWxPLDU7d08hJnpRTWhPJyNHbU8oIXlRTWhPJyNHbU8hJnpRTWhPJyNHb08oIXlRTWhPJyNHb08xU1FgTycjRFpPMVNRYE8nI0RaTyEmelFNaE8nI0dQTygheVFNaE8nI0dQTyEmelFNaE8nI0dSTygheVFNaE8nI0dSTyEmelFNaE8nI0dhTygheVFNaE8nI0dhTyEpW1FsTyw1OmpPKCRrUXBPJyNEX08oJHVRcE8nI0p2TyEpW1FsTyw1QG9PJ05uUWxPMUcwdU8oJVBRP010TycjQ2lPISlbUWxPMUcyUE8hJnpRTWhPJyNJdU8oIXlRTWhPJyNJdU8hJnpRTWhPJyNJd08oIXlRTWhPJyNJd08oJVpRIWRPJyNDck8hJnpRTWhPLDU8dE8oIXlRTWhPLDU8dE8nTm5RbE8xRzJSTyEpW1FsTzcrJnpPISZ6UU1oTzFHMmBPKCF5UU1oTzFHMmBPISZ6UU1oTycjSXVPKCF5UU1oTycjSXVPISZ6UU1oTycjSXdPKCF5UU1oTycjSXdPISZ6UU1oTzFHMmJPKCF5UU1oTzFHMmJPJ05uUWxPNysnbU8nTm5RbE83KyZhTyEmelFNaE9BTkFpTygheVFNaE9BTkFpTyglblFgTycjRW9PKCVzUWBPJyNFb08oJXtRYE8nI0ZdTygmUVFgTycjRXlPKCZWUWBPJyNLVE8oJmJRYE8nI0tSTygmbVFgTyw1O1pPKCZyUU1qTyw1PGVPKCZ5UWBPJyNHWU8oJ09RYE8nI0dZTygnVFFgTyw1PGVPKCddUWBPLDU8Z08oJ2VRYE8sNTtaTygnbVE/TXRPMUcxYE8oJ3RRYE8sNTx0TygneVFgTyw1PHRPKChPUWBPLDU8dk8oKFRRYE8sNTx2TygoWVFgTzFHMlJPKChfUWBPMUcwdU8oKGRRTWpPPDxLfU8oKGtRTWpPPDxLfU8oKHJRTWhPJyNGfE85YFFgTycjRntPQXVRYE8nI0VuTyEpW1FsTyw1O3RPITNvUWBPJyNHWU8hM29RYE8nI0dZTyEzb1FgTycjR1tPITNvUWBPJyNHW08hLFRRTWhPNysoY08hLFRRTWhPNysoY08lLnpRIWRPMUcyd08lLnpRIWRPMUcyd08hJnpRTWhPLDU9XU8hJnpRTWhPLDU9XVwiLFxuICBzdGF0ZURhdGE6IFwiKCl4fk8nfE9TJ31PU1RPUyhPUlF+T1BZT1FZT1NmT1khVk9hcU9kek9leU9sIVBPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfWE8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdXdPIXh4TyF8XU8kV3xPJG5pTyVofU8laiFRTyVsIU9PJW0hT08lbiFPTyVxIVJPJXMhU08ldiFUTyV3IVRPJXkhVU8mVyFXTyZeIVhPJmAhWU8mYiFaTyZkIVtPJmchXU8mbSFeTyZzIV9PJnUhYE8mdyFhTyZ5IWJPJnshY08oVFNPKFZUTyhZVU8oYVZPKG9bT35PV3RPflBgT1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PYSF3T3Mhbk8hUyFvTyFiIXlPIWMhdk8hZCF2TyF8PFZPI1QhcE8jVSFwTyNWIXhPI1chcE8jWCFwTyNbIXpPI10hek8oVSFsTyhWVE8oWVVPKGUhbU8obyFzT35PKE8he09+T1BdWFJdWFtdWGFdWGpdWHJdWCFRXVghU11YIV1dWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgnel1YKGFdWChyXVgoeV1YKHpdWH5PIWclUlh+UChxT18hfU8oViNQTyhXIX1PKFgjUE9+T18jUU8oWCNQTyhZI1BPKFojUU9+T3gjU08hVSNUTyhiI1RPKGMjVk9+T1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUPFpPKFZUTyhZVU8oYVZPKG9bT35PIVsjWk8hXSNXTyFZKGhQIVkodlB+UCt9TyFeI2NPflBgT1BZT1FZT1NmT2Qhak9lIWlPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhWVE8oWVVPKGFWTyhvW09+T3AjbU8hWyNpTyF8XU8jaSNsTyNqI2lPKFQ8W08hayhzUH5QLmlPIWwjb08oVCNuT35PIXgjc08hfF1PJWgjdE9+TyNrI3VPfk8hZyN2TyNrI3VPfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hXSRfTyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPI3okV08jeyRYTyhhVk8ociRZTyh5I3xPKHojfU9+T2EoZlgneihmWCd3KGZYIWsoZlghWShmWCFfKGZYJWkoZlghZyhmWH5QMXFPI1MkZE8jYCRlTyRRJGVPUChnWFIoZ1hbKGdYaihnWHIoZ1ghUShnWCFTKGdYIV0oZ1ghbChnWCFwKGdYI1IoZ1gjbihnWCNvKGdYI3AoZ1gjcShnWCNyKGdYI3MoZ1gjdChnWCN1KGdYI3YoZ1gjeChnWCN6KGdYI3soZ1goYShnWChyKGdYKHkoZ1goeihnWCFfKGdYJWkoZ1h+T2EoZ1gneihnWCd3KGdYIVkoZ1ghayhnWHYoZ1ghZyhnWH5QNFVPI2AkZU9+TyRdJGhPJF8kZ08kZiRtT35PU2ZPIV8kbk8kaSRvTyRrJHFPfk9oJVZPaiVkT2slZE9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTyVdTyFTJHtPIV8kfE8haSViTyFsJHhPI2olY08kVyVgTyR0JV5PJHYlX08keSVhTyhUJHNPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9nKF5Qfk9sJVtPflA3ZU8hbCVlT35PIVMlaE8hXyVpTyhUJWdPfk8hZyVtT35PYSVuTyd6JW5Pfk8hUSVyT35QJVtPKFUhbE9+UCVbTyVuJXZPflAlW09oJVZPIWwlZU8oVCVnTyhVIWxPfk9lJX1PIWwlZU8oVCVnT35PaiRST35PIV8mUE8oVCVnTyhVIWxPKFZUTyhZVU9gKVdQfk8hUSZTTyFsJlJPJWomVk8mVCZXT35QO1NPIXgjc09+TyVzJllPIVMpU1ghXylTWChUKVNYfk8oVCZaT35PbCFQTyF1JmBPJWohUU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUT35PZCZlT2UmZE8heCZiTyVoJmNPJXsmYU9+UDxiT2QmaE9leU9sIVBPIV8mZ08hdSZgTyF4eE8hfF1PJWh9TyVsIU9PJW0hT08lbiFPTyVxIVJPJXMhU08ldiFUTyV3IVRPJXkhVU9+T2Ima08jYCZuTyVqJmlPKFUhbE9+UD1nTyFsJm9PIXUmc09+TyFsI29Pfk8hX1hPfk9hJW5PJ3gme08neiVuT35PYSVuTyd4J09PJ3olbk9+T2Elbk8neCdRTyd6JW5Pfk8nd11YIVldWHZdWCFrXVgmW11YIV9dWCVpXVghZ11YflAocU8hYidfTyFjJ1dPIWQnV08oVSFsTyhWVE8oWVVPfk9zJ1VPIVMnVE8hWydYTyhlJ1NPIV4oaVAhXih4UH5QQG5PbidiTyFfJ2BPKFQlZ09+T2UnZ08hbCVlTyhUJWdPfk8hUSZTTyFsJlJPfk9zIW5PIVMhb08hfDxWTyNUIXBPI1UhcE8jVyFwTyNYIXBPKFUhbE8oVlRPKFlVTyhlIW1PKG8hc09+TyFiJ21PIWMnbE8hZCdsTyNWIXBPI1snbk8jXSduT35QQllPYSVuT2glVk8hZyN2TyFsJWVPJ3olbk8ocidwT35PIXAndE8jYCdyT35QQ2hPcyFuTyFTIW9PKFZUTyhZVU8oZSFtTyhvIXNPfk8hX1hPcyhtWCFTKG1YIWIobVghYyhtWCFkKG1YIXwobVgjVChtWCNVKG1YI1YobVgjVyhtWCNYKG1YI1sobVgjXShtWChVKG1YKFYobVgoWShtWChlKG1YKG8obVh+TyFjJ2xPIWQnbE8oVSFsT35QRFdPKFAneE8oUSd4TyhSJ3pPfk9fIX1PKFYnfE8oVyF9TyhYJ3xPfk9fI1FPKFgnfE8oWSd8TyhaI1FPfk92KE9PflAlW094I1NPIVUjVE8oYiNUTyhjKFJPfk8hWyhUTyFZJ1dYIVknXlghXSdXWCFdJ15YflArfU8hXShWTyFZKGhYfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hXShWTyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPI3okV08jeyRYTyhhVk8ociRZTyh5I3xPKHojfU9+TyFZKGhYflBIUk8hWShbT35PIVkodVghXSh1WCFnKHVYIWsodVgocih1WH5PI2AodVgjayNkWCFeKHVYflBKVU8jYChdTyFZKHdYIV0od1h+TyFdKF5PIVkodlh+TyFZKGFPfk8jYCRlT35QSlVPIV4oYk9+UGBPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIW5hWyFuYWohbmFyIW5hIV0hbmEhcCFuYSNSIW5hI24hbmEjbyFuYSNwIW5hI3EhbmEjciFuYSNzIW5hI3QhbmEjdSFuYSN2IW5hI3ghbmEjeiFuYSN7IW5hKHIhbmEoeSFuYSh6IW5hfk9hIW5hJ3ohbmEndyFuYSFZIW5hIWshbmF2IW5hIV8hbmElaSFuYSFnIW5hflBLbE8hayhjT35PIWcjdk8jYChkTyhyJ3BPIV0odFhhKHRYJ3oodFh+TyFrKHRYflBOWE8hUyVoTyFfJWlPIXxdTyNpKGlPI2ooaE8oVCVnT35PIV0oak8hayhzWH5PIWsobE9+TyFTJWhPIV8laU8jaihoTyhUJWdPfk9QKGdYUihnWFsoZ1hqKGdYcihnWCFRKGdYIVMoZ1ghXShnWCFsKGdYIXAoZ1gjUihnWCNuKGdYI28oZ1gjcChnWCNxKGdYI3IoZ1gjcyhnWCN0KGdYI3UoZ1gjdihnWCN4KGdYI3ooZ1gjeyhnWChhKGdYKHIoZ1goeShnWCh6KGdYfk8hZyN2TyFrKGdYflAhIHVPUihuTyFRKG1PIWwjeE8jUyRkTyF8IXthIVMhe2F+TyF4IXthJWghe2EhXyF7YSNpIXthI2ohe2EoVCF7YX5QISN2TyF4KHJPfk9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hX1hPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHNPIVMke08hXyR8TyFpPlZPIWwkeE8jajx5TyRXJWBPJHQ8dU8kdjx3TyR5JWFPKFQodk8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PI2soeE9+TyFbKHpPIWsoa1B+UCVbTyhlKHxPKG9bT35PIVMpT08hbCN4TyhlKHxPKG9bT35PUDxVT1E8VU9TZk9kPlJPZSFpT3BrT3I8VU9za090a096a098PFVPIU88VU8hU1dPIVdrTyFYa08hXyFlTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVCldTyhWVE8oWVVPKGFWTyhvW09+TyFdJF9PYSRxYSd6JHFhJ3ckcWEhayRxYSFZJHFhIV8kcWElaSRxYSFnJHFhfk9sKWRPflAhJnpPaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPJV1PIVMke08hXyR8TyFpJWJPIWwkeE8jaiVjTyRXJWBPJHQlXk8kdiVfTyR5JWFPKFQodk8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PZyhwUH5QISxUTyFRKWlPIWcpaE8hXyReWCRaJF5YJF0kXlgkXyReWCRmJF5Yfk8hZyloTyFfKHtYJFooe1gkXSh7WCRfKHtYJGYoe1h+TyFRKWlPflAhLl5PIVEpaU8hXyh7WCRaKHtYJF0oe1gkXyh7WCRmKHtYfk8hXylrTyRaKW9PJF0pak8kXylqTyRmKXBPfk8hWylzT35QISlbTyRdJGhPJF8kZ08kZil3T35PbiR6WCFRJHpYI1MkelgneSR6WCh5JHpYKHokelh+T2dtWGckelhubVghXW1YI2BtWH5QITBTT3gpeU8oYil6TyhjKXxPfk9uKlZPIVEqT08neSpQTyh5JH1PKHolUE9+T2cpfU9+UCExV09nKldPfk9oJVZPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxzTyFTKllPIV8qWk8haT5WTyFsJHhPI2o8eU8kVyVgTyR0PHVPJHY8d08keSVhTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk9wKmBPIVsqXk8oVCpYTyFrKU9QflAhMXVPI2sqYU9+TyFsKmJPfk9oJVZPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUyR7TyFfJHxPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVCpkTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk8hWypnTyFZKVBQflAhM3RPcipzT3Mhbk8hUyppTyFiKnFPIWMqa08hZCprTyFsKmJPI1sqck8lYCptTyhVIWxPKFZUTyhZVU8oZSFtT35PIV4qcE9+UCE1aU8jUyRkT24oYFghUShgWCd5KGBYKHkoYFgoeihgWCFdKGBYI2AoYFh+T2coYFgkTyhgWH5QITZrT24qeE8jYCp3T2coX1ghXShfWH5PIV0qeU9nKF5Yfk9qJWRPayVkT2wlZE8oVCZaT2coXlB+T3MqfE9+T2cpfU8oVCZaT35PIWwrU09+TyhUKHZPfk9wK1dPIVMlaE8hWyNpTyFfJWlPIXxdTyNpI2xPI2ojaU8oVCVnTyFrKHNQfk8hZyN2TyNrK1hPfk8hUyVoTyFbK1pPIV0oXk8hXyVpTyhUJWdPIVkodlB+T3MnW08hUytdTyFbK1tPKFZUTyhZVU8oZSh8T35PIV4oeFB+UCE5fE8hXSteT2EpVFgneilUWH5PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8jeiRXTyN7JFhPKGFWTyhyJFlPKHkjfE8oeiN9T35PYSFqYSFdIWphJ3ohamEndyFqYSFZIWphIWshamF2IWphIV8hamElaSFqYSFnIWphflAhOnRPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXJhWyFyYWohcmFyIXJhIV0hcmEhcCFyYSNSIXJhI24hcmEjbyFyYSNwIXJhI3EhcmEjciFyYSNzIXJhI3QhcmEjdSFyYSN2IXJhI3ghcmEjeiFyYSN7IXJhKHIhcmEoeSFyYSh6IXJhfk9hIXJhJ3ohcmEndyFyYSFZIXJhIWshcmF2IXJhIV8hcmElaSFyYSFnIXJhflAhPVtPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXRhWyF0YWohdGFyIXRhIV0hdGEhcCF0YSNSIXRhI24hdGEjbyF0YSNwIXRhI3EhdGEjciF0YSNzIXRhI3QhdGEjdSF0YSN2IXRhI3ghdGEjeiF0YSN7IXRhKHIhdGEoeSF0YSh6IXRhfk9hIXRhJ3ohdGEndyF0YSFZIXRhIWshdGF2IXRhIV8hdGElaSF0YSFnIXRhflAhP3JPaCVWT24rZ08hXydgTyVpK2ZPfk8hZytpT2EoXVghXyhdWCd6KF1YIV0oXVh+T2Elbk8hX1hPJ3olbk9+T2glVk8hbCVlT35PaCVWTyFsJWVPKFQlZ09+TyFnI3ZPI2soeE9+T2IrdE8lait1TyhUK3FPKFZUTyhZVU8hXilYUH5PIV0rdk9gKVdYfk9bK3pPfk9gK3tPfk8hXyZQTyhUJWdPKFUhbE9gKVdQfk8laixPT35QO1NPaCVWTyNgLFNPfk9oJVZPbixWTyFfJHxPfk8hXyxYT35PIVEsWk8hX1hPfk8lbiV2T35PIXgsYE9+T2UsZU9+T2IsZk8oVCNuTyhWVE8oWVVPIV4pVlB+T2UlfU9+TyVqIVFPKFQmWk9+UD1nT1ssa09gLGpPfk9QWU9RWU9TZk9kek9leU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXh4TyF8XU8kbmlPJWh9TyhWVE8oWVVPKGFWTyhvW09+TyFfIWVPIXUhZ08kVyFrTyhUIWRPflAhRnlPYCxqT2Elbk8neiVuT35PUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV8hZU8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PYSxwT2whT08hdXdPJWwhT08lbSFPTyVuIU9PflAhSWNPIWwmb09+TyZeLHZPfk8hXyx4T35PJm8sek8mcSx7T1AmbGFRJmxhUyZsYVkmbGFhJmxhZCZsYWUmbGFsJmxhcCZsYXImbGFzJmxhdCZsYXombGF8JmxhIU8mbGEhUyZsYSFXJmxhIVgmbGEhXyZsYSFpJmxhIWwmbGEhbyZsYSFwJmxhIXEmbGEhcyZsYSF1JmxhIXgmbGEhfCZsYSRXJmxhJG4mbGElaCZsYSVqJmxhJWwmbGElbSZsYSVuJmxhJXEmbGElcyZsYSV2JmxhJXcmbGEleSZsYSZXJmxhJl4mbGEmYCZsYSZiJmxhJmQmbGEmZyZsYSZtJmxhJnMmbGEmdSZsYSZ3JmxhJnkmbGEmeyZsYSd3JmxhKFQmbGEoViZsYShZJmxhKGEmbGEobyZsYSFeJmxhJmUmbGFiJmxhJmombGF+TyhULVFPfk9oIWVYIV0hUlghXiFSWCFnIVJYIWchZVghbCFlWCNgIVJYfk8hXSFlWCFeIWVYflAjIWlPIWctVk8jYC1VT2goalghXSNoWCFeI2hYIWcoalghbChqWH5PIV0oalghXihqWH5QIyNbT2glVk8hZy1YTyFsJWVPIV0hYVghXiFhWH5PcyFuTyFTIW9PKFZUTyhZVU8oZSFtT35PUDxVT1E8VU9TZk9kPlJPZSFpT3BrT3I8VU9za090a096a098PFVPIU88VU8hU1dPIVdrTyFYa08hXyFlTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVlRPKFlVTyhhVk8ob1tPfk8oVD1RT35QIyRxTyFdLV1PIV4oaVh+TyFeLV9Pfk8hZy1WTyNgLVVPIV0jaFghXiNoWH5PIV0tYE8hXih4WH5PIV4tYk9+TyFjLWNPIWQtY08oVSFsT35QIyRgTyFeLWZPflAnX09uLWlPIV8nYE9+TyFZLW5Pfk9zIXthIWIhe2EhYyF7YSFkIXthI1Qhe2EjVSF7YSNWIXthI1che2EjWCF7YSNbIXthI10he2EoVSF7YShWIXthKFkhe2EoZSF7YShvIXthflAhI3ZPIXAtc08jYC1xT35QQ2hPIWMtdU8hZC11TyhVIWxPflBEV09hJW5PI2AtcU8neiVuT35PYSVuTyFnI3ZPI2AtcU8neiVuT35PYSVuTyFnI3ZPIXAtc08jYC1xTyd6JW5PKHIncE9+TyhQJ3hPKFEneE8oUi16T35Pdi17T35PIVknV2EhXSdXYX5QITp0TyFbLlBPIVknV1ghXSdXWH5QJVtPIV0oVk8hWShoYX5PIVkoaGF+UEhSTyFdKF5PIVkodmF+TyFTJWhPIVsuVE8hXyVpTyhUJWdPIVknXlghXSdeWH5PI2AuVk8hXSh0YSFrKHRhYSh0YSd6KHRhfk8hZyN2T35QIyx3TyFdKGpPIWsoc2F+TyFTJWhPIV8laU8jai5aTyhUJWdPfk9wLmBPIVMlaE8hWy5dTyFfJWlPIXxdTyNpLl9PI2ouXU8oVCVnTyFdJ2FYIWsnYVh+T1IuZE8hbCN4T35PaCVWT24uZ08hXydgTyVpLmZPfk9hI2NpIV0jY2kneiNjaSd3I2NpIVkjY2khayNjaXYjY2khXyNjaSVpI2NpIWcjY2l+UCE6dE9uPl1PIVEqT08neSpQTyh5JH1PKHolUE9+TyNrI19hYSNfYSNgI19hJ3ojX2EhXSNfYSFrI19hIV8jX2EhWSNfYX5QIy9zTyNrKGBYUChgWFIoYFhbKGBYYShgWGooYFhyKGBYIVMoYFghbChgWCFwKGBYI1IoYFgjbihgWCNvKGBYI3AoYFgjcShgWCNyKGBYI3MoYFgjdChgWCN1KGBYI3YoYFgjeChgWCN6KGBYI3soYFgneihgWChhKGBYKHIoYFghayhgWCFZKGBYJ3coYFh2KGBYIV8oYFglaShgWCFnKGBYflAhNmtPIV0udE8hayhrWH5QITp0TyFrLndPfk8hWS55T35PUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyhhVk9bI21pYSNtaWojbWlyI21pIV0jbWkjUiNtaSNvI21pI3AjbWkjcSNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkoeiNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyNuI21pflAjM2NPI24kT09+UCMzY09QJFtPUiN6T3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNuJE9PI28kUE8jcCRQTyNxJFBPKGFWT1sjbWlhI21paiNtaSFdI21pI1IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkoeSNtaSh6I21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3IjbWl+UCM2UU8jciRRT35QIzZRT1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8oYVZPYSNtaSFdI21pI3gjbWkjeiNtaSN7I21pJ3ojbWkociNtaSh5I21pKHojbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jdiNtaX5QIzhvT1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyhhVk8oeiN9T2EjbWkhXSNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jeCRVT35QIztWTyN4I21pflAjO1ZPI3YkU09+UCM4b09QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyhhVk8oeSN8Tyh6I31PYSNtaSFdI21pI3sjbWkneiNtaShyI21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3ojbWl+UCM9e08jeiRXT35QIz17T1BdWFJdWFtdWGpdWHJdWCFRXVghU11YIWxdWCFwXVgjUl1YI1NdWCNgXVgja2ZYI25dWCNvXVgjcF1YI3FdWCNyXVgjc11YI3RdWCN1XVgjdl1YI3hdWCN6XVgje11YJFFdWChhXVgocl1YKHldWCh6XVghXV1YIV5dWH5PJE9dWH5QI0BqT1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8jdjxjTyN4PGVPI3o8Z08jezxoTyhhVk8ociRZTyh5I3xPKHojfU9+TyRPLntPflAjQndPI1MkZE8jYDxuTyRRPG5PJE8oZ1ghXihnWH5QISB1T2EnZGEhXSdkYSd6J2RhJ3cnZGEhaydkYSFZJ2RhdidkYSFfJ2RhJWknZGEhZydkYX5QITp0T1sjbWlhI21paiNtaXIjbWkhXSNtaSNSI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk9QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPI24kT08jbyRQTyNwJFBPI3EkUE8oYVZPKHkjbWkoeiNtaX5QI0V5T24+XU8hUSpPTyd5KlBPKHkkfU8oeiVQT1AjbWlSI21pIVMjbWkhbCNtaSFwI21pI24jbWkjbyNtaSNwI21pI3EjbWkoYSNtaX5QI0V5TyFdL1BPZyhwWH5QITFXT2cvUk9+T2EkUGkhXSRQaSd6JFBpJ3ckUGkhWSRQaSFrJFBpdiRQaSFfJFBpJWkkUGkhZyRQaX5QITp0TyRdL1NPJF8vU09+TyRdL1RPJF8vVE9+TyFnKWhPI2AvVU8hXyRjWCRaJGNYJF0kY1gkXyRjWCRmJGNYfk8hWy9WT35PIV8pa08kWi9YTyRdKWpPJF8pak8kZi9ZT35PIV08aU8hXihmWH5QI0J3TyFeL1pPfk8hZyloTyRmKHtYfk8kZi9dT35Pdi9eT35QISZ6T3gpeU8oYil6TyhjL2FPfk8hUy9kT35PKHkkfU9uJWFhIVElYWEneSVhYSh6JWFhIV0lYWEjYCVhYX5PZyVhYSRPJWFhflAjTHtPKHolUE9uJWNhIVElY2EneSVjYSh5JWNhIV0lY2EjYCVjYX5PZyVjYSRPJWNhflAjTW5PIV1mWCFnZlgha2ZYIWskelgocmZYflAhMFNPcCVXTyFbL21PIV0oXk8oVC9sTyFZKHZQIVkpUFB+UCExdU9yKnNPIWIqcU8hYyprTyFkKmtPIWwqYk8jWypyTyVgKm1PKFUhbE8oVlRPKFlVT35Pczx9TyFTL25PIVsrW08hXipwTyhlPHxPIV4oeFB+UCQgW08hay9vT35QIy9zTyFdL3BPIWcjdk8ocidwTyFrKU9Yfk8hay91T35Pbm9YIVFvWCd5b1goeW9YKHpvWH5PIWcjdk8ha29YflAkI09PcC93TyFTJWhPIVsqXk8hXyVpTyhUJWdPIWspT1B+TyNrL3hPfk8hWSR6WCFdJHpYIWclUlh+UCEwU08hXS95TyFZKVBYflAjL3NPIWcve09+TyFZL31Pfk9wa08oVDBPT35QLmlPaCVWT3IwVE8hZyN2TyFsJWVPKHIncE9+TyFnK2lPfk9hJW5PIV0wWE8neiVuT35PIV4wWk9+UCE1aU8hYzBbTyFkMFtPKFUhbE9+UCMkYE9zIW5PIVMwXU8oVlRPKFlVTyhlIW1Pfk8jWzBfT35PZyVhYSFdJWFhI2AlYWEkTyVhYX5QITFXT2clY2EhXSVjYSNgJWNhJE8lY2F+UCExV09qJWRPayVkT2wlZE8oVCZaT2cnbVghXSdtWH5PIV0qeU9nKF5hfk9nMGhPfk9uMGpPI2AwaU9nKF9hIV0oX2F+T1Iwa08hUTBrTyFTMGxPI1MkZE9ufWEneX1hKHl9YSh6fWEhXX1hI2B9YX5PZ31hJE99YX5QJChjTyFRKk9PJ3kqUE9uJHNhKHkkc2EoeiRzYSFdJHNhI2Akc2F+T2ckc2EkTyRzYX5QJClfTyFRKk9PJ3kqUE9uJHVhKHkkdWEoeiR1YSFdJHVhI2AkdWF+T2ckdWEkTyR1YX5QJCpRTyNrMG9Pfk9nJVRhIV0lVGEjYCVUYSRPJVRhflAhMVdPIWcjdk9+TyNrMHJPfk8hXSteT2EpVGEneilUYX5PUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXJpWyFyaWohcmlyIXJpIV0hcmkhcCFyaSNSIXJpI24hcmkjbyFyaSNwIXJpI3EhcmkjciFyaSNzIXJpI3QhcmkjdSFyaSN2IXJpI3ghcmkjeiFyaSN7IXJpKHIhcmkoeSFyaSh6IXJpfk9hIXJpJ3ohcmkndyFyaSFZIXJpIWshcml2IXJpIV8hcmklaSFyaSFnIXJpflAkK29PaCVWT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUyR7TyFfJHxPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PcDB7TyVdMHxPKFQwek9+UCQuVk8hZytpT2EoXWEhXyhdYSd6KF1hIV0oXWF+TyNrMVNPfk9bXVghXWZYIV5mWH5PIV0xVE8hXilYWH5PIV4xVk9+T1sxV09+T2IxWU8oVCtxTyhWVE8oWVVPfk8hXyZQTyhUJWdPYCd1WCFdJ3VYfk8hXSt2T2ApV2F+TyFrMV1PflAhOnRPWzFgT35PYDFhT35PI2AxZk9+T24xaU8hXyR8T35PKGUofE8hXilVUH5PaCVWT24xck8hXzFvTyVpMXFPfk9bMXxPIV0xek8hXilWWH5PIV4xfU9+T2AyUE9hJW5PJ3olbk9+TyhUI25PKFZUTyhZVU9+TyNTJGRPI2AkZU8kUSRlT1AoZ1hSKGdYWyhnWHIoZ1ghUShnWCFTKGdYIV0oZ1ghbChnWCFwKGdYI1IoZ1gjbihnWCNvKGdYI3AoZ1gjcShnWCNyKGdYI3MoZ1gjdChnWCN1KGdYI3YoZ1gjeChnWCN6KGdYI3soZ1goYShnWChyKGdYKHkoZ1goeihnWH5PajJTTyZbMlRPYShnWH5QJDNwT2oyU08jYCRlTyZbMlRPfk9hMlZPflAlW09hMlhPfk8mZTJbT1AmY2lRJmNpUyZjaVkmY2lhJmNpZCZjaWUmY2lsJmNpcCZjaXImY2lzJmNpdCZjaXomY2l8JmNpIU8mY2khUyZjaSFXJmNpIVgmY2khXyZjaSFpJmNpIWwmY2khbyZjaSFwJmNpIXEmY2khcyZjaSF1JmNpIXgmY2khfCZjaSRXJmNpJG4mY2klaCZjaSVqJmNpJWwmY2klbSZjaSVuJmNpJXEmY2klcyZjaSV2JmNpJXcmY2kleSZjaSZXJmNpJl4mY2kmYCZjaSZiJmNpJmQmY2kmZyZjaSZtJmNpJnMmY2kmdSZjaSZ3JmNpJnkmY2kmeyZjaSd3JmNpKFQmY2koViZjaShZJmNpKGEmY2kobyZjaSFeJmNpYiZjaSZqJmNpfk9iMmJPIV4yYE8majJhT35QYE8hX1hPIWwyZE9+TyZxLHtPUCZsaVEmbGlTJmxpWSZsaWEmbGlkJmxpZSZsaWwmbGlwJmxpciZsaXMmbGl0JmxpeiZsaXwmbGkhTyZsaSFTJmxpIVcmbGkhWCZsaSFfJmxpIWkmbGkhbCZsaSFvJmxpIXAmbGkhcSZsaSFzJmxpIXUmbGkheCZsaSF8JmxpJFcmbGkkbiZsaSVoJmxpJWombGklbCZsaSVtJmxpJW4mbGklcSZsaSVzJmxpJXYmbGkldyZsaSV5JmxpJlcmbGkmXiZsaSZgJmxpJmImbGkmZCZsaSZnJmxpJm0mbGkmcyZsaSZ1JmxpJncmbGkmeSZsaSZ7JmxpJ3cmbGkoVCZsaShWJmxpKFkmbGkoYSZsaShvJmxpIV4mbGkmZSZsaWImbGkmaiZsaX5PIVkyak9+TyFdIWFhIV4hYWF+UCNCd09zIW5PIVMhb08hWzJwTyhlIW1PIV0nWFghXidYWH5QQG5PIV0tXU8hXihpYX5PIV0nX1ghXidfWH5QITl8TyFdLWBPIV4oeGF+TyFeMndPflAnX09hJW5PI2AzUU8neiVuT35PYSVuTyFnI3ZPI2AzUU8neiVuT35PYSVuTyFnI3ZPIXAzVU8jYDNRTyd6JW5PKHIncE9+T2Elbk8neiVuT35QITp0TyFdJF9PdiRxYX5PIVknV2khXSdXaX5QITp0TyFdKFZPIVkoaGl+TyFdKF5PIVkodml+TyFZKHdpIV0od2l+UCE6dE8hXSh0aSFrKHRpYSh0aSd6KHRpflAhOnRPI2AzV08hXSh0aSFrKHRpYSh0aSd6KHRpfk8hXShqTyFrKHNpfk8hUyVoTyFfJWlPIXxdTyNpM11PI2ozW08oVCVnT35PIVMlaE8hXyVpTyNqM1tPKFQlZ09+T24zZE8hXydgTyVpM2NPfk9oJVZPbjNkTyFfJ2BPJWkzY09+TyNrJWFhUCVhYVIlYWFbJWFhYSVhYWolYWFyJWFhIVMlYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEneiVhYShhJWFhKHIlYWEhayVhYSFZJWFhJ3clYWF2JWFhIV8lYWElaSVhYSFnJWFhflAjTHtPI2slY2FQJWNhUiVjYVslY2FhJWNhaiVjYXIlY2EhUyVjYSFsJWNhIXAlY2EjUiVjYSNuJWNhI28lY2EjcCVjYSNxJWNhI3IlY2EjcyVjYSN0JWNhI3UlY2EjdiVjYSN4JWNhI3olY2EjeyVjYSd6JWNhKGElY2EociVjYSFrJWNhIVklY2EndyVjYXYlY2EhXyVjYSVpJWNhIWclY2F+UCNNbk8jayVhYVAlYWFSJWFhWyVhYWElYWFqJWFhciVhYSFTJWFhIV0lYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEneiVhYShhJWFhKHIlYWEhayVhYSFZJWFhJ3clYWEjYCVhYXYlYWEhXyVhYSVpJWFhIWclYWF+UCMvc08jayVjYVAlY2FSJWNhWyVjYWElY2FqJWNhciVjYSFTJWNhIV0lY2EhbCVjYSFwJWNhI1IlY2EjbiVjYSNvJWNhI3AlY2EjcSVjYSNyJWNhI3MlY2EjdCVjYSN1JWNhI3YlY2EjeCVjYSN6JWNhI3slY2EneiVjYShhJWNhKHIlY2EhayVjYSFZJWNhJ3clY2EjYCVjYXYlY2EhXyVjYSVpJWNhIWclY2F+UCMvc08ja31hUH1hW31hYX1han1hcn1hIWx9YSFwfWEjUn1hI259YSNvfWEjcH1hI3F9YSNyfWEjc31hI3R9YSN1fWEjdn1hI3h9YSN6fWEje31hJ3p9YShhfWEocn1hIWt9YSFZfWEnd31hdn1hIV99YSVpfWEhZ31hflAkKGNPI2skc2FQJHNhUiRzYVskc2FhJHNhaiRzYXIkc2EhUyRzYSFsJHNhIXAkc2EjUiRzYSNuJHNhI28kc2EjcCRzYSNxJHNhI3Ikc2EjcyRzYSN0JHNhI3Ukc2EjdiRzYSN4JHNhI3okc2EjeyRzYSd6JHNhKGEkc2EociRzYSFrJHNhIVkkc2EndyRzYXYkc2EhXyRzYSVpJHNhIWckc2F+UCQpX08jayR1YVAkdWFSJHVhWyR1YWEkdWFqJHVhciR1YSFTJHVhIWwkdWEhcCR1YSNSJHVhI24kdWEjbyR1YSNwJHVhI3EkdWEjciR1YSNzJHVhI3QkdWEjdSR1YSN2JHVhI3gkdWEjeiR1YSN7JHVhJ3okdWEoYSR1YShyJHVhIWskdWEhWSR1YSd3JHVhdiR1YSFfJHVhJWkkdWEhZyR1YX5QJCpRTyNrJVRhUCVUYVIlVGFbJVRhYSVUYWolVGFyJVRhIVMlVGEhXSVUYSFsJVRhIXAlVGEjUiVUYSNuJVRhI28lVGEjcCVUYSNxJVRhI3IlVGEjcyVUYSN0JVRhI3UlVGEjdiVUYSN4JVRhI3olVGEjeyVUYSd6JVRhKGElVGEociVUYSFrJVRhIVklVGEndyVUYSNgJVRhdiVUYSFfJVRhJWklVGEhZyVUYX5QIy9zT2EjY3EhXSNjcSd6I2NxJ3cjY3EhWSNjcSFrI2NxdiNjcSFfI2NxJWkjY3EhZyNjcX5QITp0TyFbM2xPIV0nWVghaydZWH5QJVtPIV0udE8hayhrYX5PIV0udE8hayhrYX5QITp0TyFZM29Pfk8kTyFuYSFeIW5hflBLbE8kTyFqYSFdIWphIV4hamF+UCNCd08kTyFyYSFeIXJhflAhPVtPJE8hdGEhXiF0YX5QIT9yT2cnXVghXSddWH5QISxUTyFdL1BPZyhwYX5PU2ZPIV80VE8kZDRVT35PIV40WU9+T3Y0Wk9+UCMvc09hJG1xIV0kbXEneiRtcSd3JG1xIVkkbXEhayRtcXYkbXEhXyRtcSVpJG1xIWckbXF+UCE6dE8hWTRdT35QISZ6TyFTNF5Pfk8hUSpPTyd5KlBPKHolUE9uJ2lhKHknaWEhXSdpYSNgJ2lhfk9nJ2lhJE8naWF+UCUtZk8hUSpPTyd5KlBPbidrYSh5J2thKHona2EhXSdrYSNgJ2thfk9nJ2thJE8na2F+UCUuWE8ociRZT35QIy9zTyFZZlghWSR6WCFdZlghXSR6WCFnJVJYI2BmWH5QITBTT3AlV08oVD1XT35QITF1T3A0Yk8hUyVoTyFbNGFPIV8laU8oVCVnTyFdJ2VYIWsnZVh+TyFdL3BPIWspT2F+TyFdL3BPIWcjdk8haylPYX5PIV0vcE8hZyN2TyhyJ3BPIWspT2F+T2ckfGkhXSR8aSNgJHxpJE8kfGl+UCExV08hWzRqTyFZJ2dYIV0nZ1h+UCEzdE8hXS95TyFZKVBhfk8hXS95TyFZKVBhflAjL3NPUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghWV1YIV1dWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYV1YKHJdWCh5XVgoel1Yfk9qJVlYIWclWVh+UCUyT09qNG9PIWcjdk9+T2glVk8hZyN2TyFsJWVPfk9oJVZPcjR0TyFsJWVPKHIncE9+T3I0eU8hZyN2TyhyJ3BPfk9zIW5PIVM0ek8oVlRPKFlVTyhlIW1Pfk8oeSR9T24lYWkhUSVhaSd5JWFpKHolYWkhXSVhaSNgJWFpfk9nJWFpJE8lYWl+UCU1b08oeiVQT24lY2khUSVjaSd5JWNpKHklY2khXSVjaSNgJWNpfk9nJWNpJE8lY2l+UCU2Yk9nKF9pIV0oX2l+UCExV08jYDVRT2coX2khXShfaX5QITFXTyFrNVZPfk9hJG9xIV0kb3EneiRvcSd3JG9xIVkkb3EhayRvcXYkb3EhXyRvcSVpJG9xIWckb3F+UCE6dE8hWTVaT35PIV01W08hXylRWH5QIy9zT2EkelghXyR6WCVeXVgneiR6WCFdJHpYflAhMFNPJV41X09hb1ghX29YJ3pvWCFdb1h+UCQjT09wNWBPKFQjbk9+TyVeNV9Pfk9iNWZPJWo1Z08oVCtxTyhWVE8oWVVPIV0ndFghXid0WH5PIV0xVE8hXilYYX5PWzVrT35PYDVsT35PWzVwT35PYSVuTyd6JW5PflAjL3NPIV01dU8jYDV3TyFeKVVYfk8hXjV4T35PcjZPT3Mhbk8hUyppTyFiIXlPIWMhdk8hZCF2TyF8PFZPI1QhcE8jVSFwTyNWIXBPI1chcE8jWCFwTyNbNX1PI10hek8oVSFsTyhWVE8oWVVPKGUhbU8obyFzT35PIV41fE9+UCU7ZU9uNlRPIV8xb08laTZTT35PaCVWT242VE8hXzFvTyVpNlNPfk9iNltPKFQjbk8oVlRPKFlVTyFdJ3NYIV4nc1h+TyFdMXpPIV4pVmF+TyhWVE8oWVVPKGU2Xk9+T2A2Yk9+T2o2ZU8mWzZmT35QTlhPIWs2Z09+UCVbT2E2aU9+T2E2aU9+UCVbT2IyYk8hXjZuTyZqMmFPflBgTyFnNnBPfk8hZzZyT2goamkhXShqaSFeKGppIWcoamkhbChqaXIoamkocihqaX5PIV0jaGkhXiNoaX5QI0J3TyNgNnNPIV0jaGkhXiNoaX5PIV0hYWkhXiFhaX5QI0J3T2Elbk8jYDZ8Tyd6JW5Pfk9hJW5PIWcjdk8jYDZ8Tyd6JW5Pfk8hXSh0cSFrKHRxYSh0cSd6KHRxflAhOnRPIV0oak8hayhzcX5PIVMlaE8hXyVpTyNqN1RPKFQlZ09+TyFfJ2BPJWk3V09+T243W08hXydgTyVpN1dPfk8jaydpYVAnaWFSJ2lhWydpYWEnaWFqJ2lhcidpYSFTJ2lhIWwnaWEhcCdpYSNSJ2lhI24naWEjbydpYSNwJ2lhI3EnaWEjcidpYSNzJ2lhI3QnaWEjdSdpYSN2J2lhI3gnaWEjeidpYSN7J2lhJ3onaWEoYSdpYShyJ2lhIWsnaWEhWSdpYSd3J2lhdidpYSFfJ2lhJWknaWEhZydpYX5QJS1mTyNrJ2thUCdrYVIna2FbJ2thYSdrYWona2FyJ2thIVMna2EhbCdrYSFwJ2thI1Ina2EjbidrYSNvJ2thI3Ana2EjcSdrYSNyJ2thI3Mna2EjdCdrYSN1J2thI3Yna2EjeCdrYSN6J2thI3sna2EneidrYShhJ2thKHIna2EhaydrYSFZJ2thJ3cna2F2J2thIV8na2ElaSdrYSFnJ2thflAlLlhPI2skfGlQJHxpUiR8aVskfGlhJHxpaiR8aXIkfGkhUyR8aSFdJHxpIWwkfGkhcCR8aSNSJHxpI24kfGkjbyR8aSNwJHxpI3EkfGkjciR8aSNzJHxpI3QkfGkjdSR8aSN2JHxpI3gkfGkjeiR8aSN7JHxpJ3okfGkoYSR8aShyJHxpIWskfGkhWSR8aSd3JHxpI2AkfGl2JHxpIV8kfGklaSR8aSFnJHxpflAjL3NPI2slYWlQJWFpUiVhaVslYWlhJWFpaiVhaXIlYWkhUyVhaSFsJWFpIXAlYWkjUiVhaSNuJWFpI28lYWkjcCVhaSNxJWFpI3IlYWkjcyVhaSN0JWFpI3UlYWkjdiVhaSN4JWFpI3olYWkjeyVhaSd6JWFpKGElYWkociVhaSFrJWFpIVklYWkndyVhaXYlYWkhXyVhaSVpJWFpIWclYWl+UCU1b08jayVjaVAlY2lSJWNpWyVjaWElY2lqJWNpciVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJ3olY2koYSVjaShyJWNpIWslY2khWSVjaSd3JWNpdiVjaSFfJWNpJWklY2khZyVjaX5QJTZiTyFdJ1lhIWsnWWF+UCE6dE8hXS50TyFrKGtpfk8kTyNjaSFdI2NpIV4jY2l+UCNCd09QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPKGFWT1sjbWlqI21pciNtaSNSI21pI28jbWkjcCNtaSNxI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSh6I21pIV0jbWkhXiNtaX5PI24jbWl+UCVOZE8jbjxfT35QJU5kT1AkW09SI3pPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI248X08jbzxgTyNwPGBPI3E8YE8oYVZPWyNtaWojbWkjUiNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSh5I21pKHojbWkhXSNtaSFeI21pfk8jciNtaX5QJiFsTyNyPGFPflAmIWxPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyhhVk8jeCNtaSN6I21pI3sjbWkkTyNtaShyI21pKHkjbWkoeiNtaSFdI21pIV4jbWl+TyN2I21pflAmJHRPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyN2PGNPKGFWTyh6I31PI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSFdI21pIV4jbWl+TyN4PGVPflAmJnVPI3gjbWl+UCYmdU8jdjxjT35QJiR0T1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8jdjxjTyN4PGVPKGFWTyh5I3xPKHojfU8jeyNtaSRPI21pKHIjbWkhXSNtaSFeI21pfk8jeiNtaX5QJilVTyN6PGdPflAmKVVPYSN8eSFdI3x5J3ojfHkndyN8eSFZI3x5IWsjfHl2I3x5IV8jfHklaSN8eSFnI3x5flAhOnRPWyNtaWojbWlyI21pI1IjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSFdI21pIV4jbWl+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08jbjxfTyNvPGBPI3A8YE8jcTxgTyhhVk8oeSNtaSh6I21pflAmLFFPbj5eTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPUCNtaVIjbWkhUyNtaSFsI21pIXAjbWkjbiNtaSNvI21pI3AjbWkjcSNtaShhI21pflAmLFFPI1MkZE9QKGBYUihgWFsoYFhqKGBYbihgWHIoYFghUShgWCFTKGBYIWwoYFghcChgWCNSKGBYI24oYFgjbyhgWCNwKGBYI3EoYFgjcihgWCNzKGBYI3QoYFgjdShgWCN2KGBYI3goYFgjeihgWCN7KGBYJE8oYFgneShgWChhKGBYKHIoYFgoeShgWCh6KGBYIV0oYFghXihgWH5PJE8kUGkhXSRQaSFeJFBpflAjQndPJE8hcmkhXiFyaX5QJCtvT2cnXWEhXSddYX5QITFXTyFeN25Pfk8hXSdkYSFeJ2RhflAjQndPIVk3b09+UCMvc08hZyN2TyhyJ3BPIV0nZWEhaydlYX5PIV0vcE8haylPaX5PIV0vcE8hZyN2TyFrKU9pfk9nJHxxIV0kfHEjYCR8cSRPJHxxflAhMVdPIVknZ2EhXSdnYX5QIy9zTyFnN3ZPfk8hXS95TyFZKVBpflAjL3NPIV0veU8hWSlQaX5PIVk3eU9+T2glVk9yOE9PIWwlZU8ocidwT35PajhRTyFnI3ZPfk9yOFRPIWcjdk8ocidwT35PIVEqT08neSpQTyh6JVBPbidqYSh5J2phIV0namEjYCdqYX5PZydqYSRPJ2phflAmNVJPIVEqT08neSpQT24nbGEoeSdsYSh6J2xhIV0nbGEjYCdsYX5PZydsYSRPJ2xhflAmNXRPZyhfcSFdKF9xflAhMVdPI2A4Vk9nKF9xIV0oX3F+UCExV08hWThXT35PZyVPcSFdJU9xI2AlT3EkTyVPcX5QITFXT2Ekb3khXSRveSd6JG95J3ckb3khWSRveSFrJG95diRveSFfJG95JWkkb3khZyRveX5QITp0TyFnNnJPfk8hXTVbTyFfKVFhfk8hXydgT1AkVGFSJFRhWyRUYWokVGFyJFRhIVEkVGEhUyRUYSFdJFRhIWwkVGEhcCRUYSNSJFRhI24kVGEjbyRUYSNwJFRhI3EkVGEjciRUYSNzJFRhI3QkVGEjdSRUYSN2JFRhI3gkVGEjeiRUYSN7JFRhKGEkVGEociRUYSh5JFRhKHokVGF+TyVpN1dPflAmOGZPJV44W09hJVtpIV8lW2kneiVbaSFdJVtpfk9hI2N5IV0jY3kneiNjeSd3I2N5IVkjY3khayNjeXYjY3khXyNjeSVpI2N5IWcjY3l+UCE6dE9bOF5Pfk9iOGBPKFQrcU8oVlRPKFlVT35PIV0xVE8hXilYaX5PYDhkT35PKGUofE8hXSdwWCFeJ3BYfk8hXTV1TyFeKVVhfk8hXjhuT35QJTtlTyhvIXNPflAkJllPI1s4b09+TyFfMW9Pfk8hXzFvTyVpOHFPfk9uOHRPIV8xb08laThxT35PWzh5TyFdJ3NhIV4nc2F+TyFdMXpPIV4pVml+TyFrOH1Pfk8hazlPT35PIWs5Uk9+TyFrOVJPflAlW09hOVRPfk8hZzlVT35PIWs5Vk9+TyFdKHdpIV4od2l+UCNCd09hJW5PI2A5X08neiVuT35PIV0odHkhayh0eWEodHkneih0eX5QITp0TyFdKGpPIWsoc3l+TyVpOWJPflAmOGZPIV8nYE8laTliT35PI2skfHFQJHxxUiR8cVskfHFhJHxxaiR8cXIkfHEhUyR8cSFdJHxxIWwkfHEhcCR8cSNSJHxxI24kfHEjbyR8cSNwJHxxI3EkfHEjciR8cSNzJHxxI3QkfHEjdSR8cSN2JHxxI3gkfHEjeiR8cSN7JHxxJ3okfHEoYSR8cShyJHxxIWskfHEhWSR8cSd3JHxxI2AkfHF2JHxxIV8kfHElaSR8cSFnJHxxflAjL3NPI2snamFQJ2phUidqYVsnamFhJ2phaidqYXInamEhUydqYSFsJ2phIXAnamEjUidqYSNuJ2phI28namEjcCdqYSNxJ2phI3InamEjcydqYSN0J2phI3UnamEjdidqYSN4J2phI3onamEjeydqYSd6J2phKGEnamEocidqYSFrJ2phIVknamEndydqYXYnamEhXydqYSVpJ2phIWcnamF+UCY1Uk8jaydsYVAnbGFSJ2xhWydsYWEnbGFqJ2xhcidsYSFTJ2xhIWwnbGEhcCdsYSNSJ2xhI24nbGEjbydsYSNwJ2xhI3EnbGEjcidsYSNzJ2xhI3QnbGEjdSdsYSN2J2xhI3gnbGEjeidsYSN7J2xhJ3onbGEoYSdsYShyJ2xhIWsnbGEhWSdsYSd3J2xhdidsYSFfJ2xhJWknbGEhZydsYX5QJjV0TyNrJU9xUCVPcVIlT3FbJU9xYSVPcWolT3FyJU9xIVMlT3EhXSVPcSFsJU9xIXAlT3EjUiVPcSNuJU9xI28lT3EjcCVPcSNxJU9xI3IlT3EjcyVPcSN0JU9xI3UlT3EjdiVPcSN4JU9xI3olT3EjeyVPcSd6JU9xKGElT3EociVPcSFrJU9xIVklT3EndyVPcSNgJU9xdiVPcSFfJU9xJWklT3EhZyVPcX5QIy9zTyFdJ1lpIWsnWWl+UCE6dE8kTyNjcSFdI2NxIV4jY3F+UCNCd08oeSR9T1AlYWFSJWFhWyVhYWolYWFyJWFhIVMlYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEkTyVhYShhJWFhKHIlYWEhXSVhYSFeJWFhfk9uJWFhIVElYWEneSVhYSh6JWFhflAmSXlPKHolUE9QJWNhUiVjYVslY2FqJWNhciVjYSFTJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJE8lY2EoYSVjYShyJWNhIV0lY2EhXiVjYX5PbiVjYSFRJWNhJ3klY2EoeSVjYX5QJkxRT24+Xk8hUSpPTyd5KlBPKHolUE9+UCZJeU9uPl5PIVEqT08neSpQTyh5JH1PflAmTFFPUjBrTyFRMGtPIVMwbE8jUyRkT1B9YVt9YWp9YW59YXJ9YSFsfWEhcH1hI1J9YSNufWEjb31hI3B9YSNxfWEjcn1hI3N9YSN0fWEjdX1hI3Z9YSN4fWEjen1hI3t9YSRPfWEneX1hKGF9YShyfWEoeX1hKHp9YSFdfWEhXn1hfk8hUSpPTyd5KlBPUCRzYVIkc2FbJHNhaiRzYW4kc2FyJHNhIVMkc2EhbCRzYSFwJHNhI1Ikc2EjbiRzYSNvJHNhI3Akc2EjcSRzYSNyJHNhI3Mkc2EjdCRzYSN1JHNhI3Ykc2EjeCRzYSN6JHNhI3skc2EkTyRzYShhJHNhKHIkc2EoeSRzYSh6JHNhIV0kc2EhXiRzYX5PIVEqT08neSpQT1AkdWFSJHVhWyR1YWokdWFuJHVhciR1YSFTJHVhIWwkdWEhcCR1YSNSJHVhI24kdWEjbyR1YSNwJHVhI3EkdWEjciR1YSNzJHVhI3QkdWEjdSR1YSN2JHVhI3gkdWEjeiR1YSN7JHVhJE8kdWEoYSR1YShyJHVhKHkkdWEoeiR1YSFdJHVhIV4kdWF+T24+Xk8hUSpPTyd5KlBPKHkkfU8oeiVQT35PUCVUYVIlVGFbJVRhaiVUYXIlVGEhUyVUYSFsJVRhIXAlVGEjUiVUYSNuJVRhI28lVGEjcCVUYSNxJVRhI3IlVGEjcyVUYSN0JVRhI3UlVGEjdiVUYSN4JVRhI3olVGEjeyVUYSRPJVRhKGElVGEociVUYSFdJVRhIV4lVGF+UCcnVk8kTyRtcSFdJG1xIV4kbXF+UCNCd08kTyRvcSFdJG9xIV4kb3F+UCNCd08hXjlvT35PJE85cE9+UCExV08hZyN2TyFdJ2VpIWsnZWl+TyFnI3ZPKHIncE8hXSdlaSFrJ2Vpfk8hXS9wTyFrKU9xfk8hWSdnaSFdJ2dpflAjL3NPIV0veU8hWSlQcX5Pcjl3TyFnI3ZPKHIncE9+T1s5eU8hWTl4T35QIy9zTyFZOXhPfk9qOlBPIWcjdk9+T2coX3khXShfeX5QITFXTyFdJ25hIV8nbmF+UCMvc09hJVtxIV8lW3EneiVbcSFdJVtxflAjL3NPWzpVT35PIV0xVE8hXilYcX5PYDpZT35PI2A6Wk8hXSdwYSFeJ3Bhfk8hXTV1TyFeKVVpflAjQndPIVM6XU9+TyFfMW9PJWk6YE9+TyhWVE8oWVVPKGU6ZU9+TyFdMXpPIV4pVnF+TyFrOmhPfk8hazppT35PIWs6ak9+TyFrOmpPflAlW08jYDptTyFdI2h5IV4jaHl+TyFdI2h5IV4jaHl+UCNCd08laTpyT35QJjhmTyFfJ2BPJWk6ck9+TyRPI3x5IV0jfHkhXiN8eX5QI0J3T1AkfGlSJHxpWyR8aWokfGlyJHxpIVMkfGkhbCR8aSFwJHxpI1IkfGkjbiR8aSNvJHxpI3AkfGkjcSR8aSNyJHxpI3MkfGkjdCR8aSN1JHxpI3YkfGkjeCR8aSN6JHxpI3skfGkkTyR8aShhJHxpKHIkfGkhXSR8aSFeJHxpflAnJ1ZPIVEqT08neSpQTyh6JVBPUCdpYVInaWFbJ2lhaidpYW4naWFyJ2lhIVMnaWEhbCdpYSFwJ2lhI1InaWEjbidpYSNvJ2lhI3AnaWEjcSdpYSNyJ2lhI3MnaWEjdCdpYSN1J2lhI3YnaWEjeCdpYSN6J2lhI3snaWEkTydpYShhJ2lhKHInaWEoeSdpYSFdJ2lhIV4naWF+TyFRKk9PJ3kqUE9QJ2thUidrYVsna2FqJ2thbidrYXIna2EhUydrYSFsJ2thIXAna2EjUidrYSNuJ2thI28na2EjcCdrYSNxJ2thI3Ina2EjcydrYSN0J2thI3Una2EjdidrYSN4J2thI3ona2EjeydrYSRPJ2thKGEna2EocidrYSh5J2thKHona2EhXSdrYSFeJ2thfk8oeSR9T1AlYWlSJWFpWyVhaWolYWluJWFpciVhaSFRJWFpIVMlYWkhbCVhaSFwJWFpI1IlYWkjbiVhaSNvJWFpI3AlYWkjcSVhaSNyJWFpI3MlYWkjdCVhaSN1JWFpI3YlYWkjeCVhaSN6JWFpI3slYWkkTyVhaSd5JWFpKGElYWkociVhaSh6JWFpIV0lYWkhXiVhaX5PKHolUE9QJWNpUiVjaVslY2lqJWNpbiVjaXIlY2khUSVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJE8lY2kneSVjaShhJWNpKHIlY2koeSVjaSFdJWNpIV4lY2l+TyRPJG95IV0kb3khXiRveX5QI0J3TyRPI2N5IV0jY3khXiNjeX5QI0J3TyFnI3ZPIV0nZXEhaydlcX5PIV0vcE8haylPeX5PIVknZ3EhXSdncX5QIy9zT3I6fE8hZyN2TyhyJ3BPfk9bO1FPIVk7UE9+UCMvc08hWTtQT35PZyhfIVIhXShfIVJ+UCExV09hJVt5IV8lW3kneiVbeSFdJVt5flAjL3NPIV0xVE8hXilYeX5PIV01dU8hXilVcX5PKFQ7WE9+TyFfMW9PJWk7W09+TyFrO19Pfk8laTtkT35QJjhmT1AkfHFSJHxxWyR8cWokfHFyJHxxIVMkfHEhbCR8cSFwJHxxI1IkfHEjbiR8cSNvJHxxI3AkfHEjcSR8cSNyJHxxI3MkfHEjdCR8cSN1JHxxI3YkfHEjeCR8cSN6JHxxI3skfHEkTyR8cShhJHxxKHIkfHEhXSR8cSFeJHxxflAnJ1ZPIVEqT08neSpQTyh6JVBPUCdqYVInamFbJ2phaidqYW4namFyJ2phIVMnamEhbCdqYSFwJ2phI1InamEjbidqYSNvJ2phI3AnamEjcSdqYSNyJ2phI3MnamEjdCdqYSN1J2phI3YnamEjeCdqYSN6J2phI3snamEkTydqYShhJ2phKHInamEoeSdqYSFdJ2phIV4namF+TyFRKk9PJ3kqUE9QJ2xhUidsYVsnbGFqJ2xhbidsYXInbGEhUydsYSFsJ2xhIXAnbGEjUidsYSNuJ2xhI28nbGEjcCdsYSNxJ2xhI3InbGEjcydsYSN0J2xhI3UnbGEjdidsYSN4J2xhI3onbGEjeydsYSRPJ2xhKGEnbGEocidsYSh5J2xhKHonbGEhXSdsYSFeJ2xhfk9QJU9xUiVPcVslT3FqJU9xciVPcSFTJU9xIWwlT3EhcCVPcSNSJU9xI24lT3EjbyVPcSNwJU9xI3ElT3EjciVPcSNzJU9xI3QlT3EjdSVPcSN2JU9xI3glT3EjeiVPcSN7JU9xJE8lT3EoYSVPcShyJU9xIV0lT3EhXiVPcX5QJydWT2clZSFaIV0lZSFaI2AlZSFaJE8lZSFaflAhMVdPIVk7aE9+UCMvc09yO2lPIWcjdk8ocidwT35PWztrTyFZO2hPflAjL3NPIV0ncHEhXidwcX5QI0J3TyFdI2ghWiFeI2ghWn5QI0J3TyNrJWUhWlAlZSFaUiVlIVpbJWUhWmElZSFaaiVlIVpyJWUhWiFTJWUhWiFdJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWid6JWUhWihhJWUhWihyJWUhWiFrJWUhWiFZJWUhWid3JWUhWiNgJWUhWnYlZSFaIV8lZSFaJWklZSFaIWclZSFaflAjL3NPcjt0TyFnI3ZPKHIncE9+TyFZO3VPflAjL3NPcjt8TyFnI3ZPKHIncE9+TyFZO31PflAjL3NPUCVlIVpSJWUhWlslZSFaaiVlIVpyJWUhWiFTJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWiRPJWUhWihhJWUhWihyJWUhWiFdJWUhWiFeJWUhWn5QJydWT3I8UU8hZyN2TyhyJ3BPfk92KGZYflAxcU8hUSVyT35QISlbTyhVIWxPflAhKVtPIVlmWCFdZlgjYGZYflAlMk9PUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghXV1YIV1mWCFsXVghcF1YI1JdWCNTXVgjYF1YI2BmWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YKGFdWChyXVgoeV1YKHpdWH5PIWdmWCFrXVgha2ZYKHJmWH5QJ0xUT1A8VU9RPFVPU2ZPZD5ST2UhaU9wa09yPFVPc2tPdGtPemtPfDxVTyFPPFVPIVNXTyFXa08hWGtPIV9YTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVCldTyhWVE8oWVVPKGFWTyhvW09+TyFdPGlPIV4kcWF+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzx0TyFTJHtPIV8kfE8haT5XTyFsJHhPI2o8ek8kVyVgTyR0PHZPJHY8eE8keSVhTyhUKHZPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+T2wpZE9+UCgheU9yIWVYKHIhZVh+UCMhaU9yKGpYKHIoalh+UCMjW08hXl1YIV5mWH5QJ0xUTyFZZlghWSR6WCFdZlghXSR6WCNgZlh+UCEwU08jazxeT35PIWcjdk8jazxeT35PI2A8bk9+T2o8Yk9+TyNgPU9PIV0od1ghXih3WH5PI2A8bk8hXSh1WCFeKHVYfk8jaz1QT35PZz1ST35QITFXTyNrPVhPfk8jaz1ZT35PZz1STyhUJlpPfk8hZyN2TyNrPVpPfk8hZyN2TyNrPVBPfk8kTz1bT35QI0J3TyNrPV1Pfk8jaz1eT35PI2s9Y09+TyNrPWRPfk8jaz1lT35PI2s9Zk9+TyRPPWdPflAhMVdPJE89aE9+UCExV09sPXNPflA3ZU9rI1MjVCNVI1cjWCNbI2kjaiN1JG4kdCR2JHklXSVeJWglaSVqJXElcyV2JXcleSV7fihPVCNvIVgnfChVI3BzI24jcXIhUSd9JF0nfShUJF8oZX5cIixcbiAgZ290bzogXCIkOVkpXVBQUFBQUCleUFApYVApclArVy9dUFBQUDZtUFA3VFBQPVFQUFBAdFBBXlBBXlBQUEFeUENmUEFeUEFeUEFeUENqUENvUEReUElXUFBQSVtQUFBQSVtMX1BQUExlTVZQSVtQSVtQUCEgZUlbUFBQSVtQSVtQISNsSVtQISdTIShYIShiUCEpVSEpWSEpVSEsZ1BQUFBQUFAhLVchKFhQUCEtaCEvWVAhMmlJW0lbITJuITV6ITpoITpoIT5nUFBQIT5vSVtQUFBQUFBQUFAhQk9QIUNdUFBJWyFEblBJW1BJW0lbSVtJW0lbUElbIUZRUCFJW1AhTGJQIUxmIUxwIUx0IUx0UCFJWFAhTHghTHhQIyFPUCMhU0lbUElbIyFZIyVfQ2pBXlBBXlBBXkFeUCMmbEFeQV4jKU9BXiMrdkFeIy5TQV5BXiMuciMxVyMxVyMxXSMxZiMxVyMxcVBQIzFXUEFeIzJaQV4jNllBXkFeNm1QUFAjOl9QUFAjOngjOnhQIzp4UCM7YCM6eFBQIztmUCM7XVAjO10jO3kjO10jPGUjPGsjPG4pYVAjPHEpYVAjPHojPHojPHpQKWFQKWFQKWFQKWFQUClhUCM9USM9VFAjPVQpYVAjPVhQIz1bUClhUClhUClhUClhUClhUClhKWFQUCM9YiM9aCM9cyM9eSM+UCM+ViM+XSM+ayM+cSM+eyM/UiM/XSM/YyM/cyM/eSNAayNAfSNBVCNBWiNBaSNCTyNDcyNEUiNEWSNFdCNGUyNHdCNIUyNIWSNIYCNIZiNIcCNIdiNIfCNJVyNJaiNJcFBQUFBQUFBQUFBQI0l2UFBQUFBQUCNKayNNeCQgYiQgaSQgcVBQUCQnXVAkJ2YkKl8kMHgkMHskMU8kMX0kMlEkMlgkMmFQJDJnJDJqUCQzVyQzWyQ0UyQ1YiQ1ZyQ1fVBQJDZTJDZZJDZeJDZhJDZlJDZpJDdlJDd8JDhlJDhpJDhsJDhvJDh5JDh8JDlRJDlVUiF8Um9xT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9ZIXZRJ2AtZTFvNXtRJXR2USV8eVEmVHxRJmohVlMnVyFlLV1RJ2YhaVMnbCFyIXlVKmskfCpaKm9RK28lfVMrfCZWJldRLGQmZFEtYydfUS1tJ2dRLXUnbVEwWypxUTFiLE9RMXksZVI8ezxZJVNkT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXSxwLHMseC1pLXEuUC5WLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNsNHo2VDZlNmY2aTZ8OHQ5VDlfUyNxXTxWIXIpXyRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVStQJV08czx0USt0JlBRLGYmZ1EsbSZvUTB4K2dRMH0raVExWSt1UTJSLGtRM2AuZ1E1YDB8UTVmMVRRNlsxelE3WTNkUThgNWdSOWU3WydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+UyFTIW5RIXIhdiF5IXokfCdXJ18nYCdsJ20nbiprKm8qcSpyLV0tYy1lLXUwWzBfMW81ezV9JVskdGkjdiRiJGMkZCR4JHslTyVRJV4lXyVjKXkqUipUKlYqWSphKmcqdyp4K2YraSxTLFYuZi9QL2QvbS94L3kvezBgMGIwaTBqMG8xZjFpMXEzYzReNF80ajRvNVE1WzVfNlM3Vzd2OFE4VjhbOHE5YjlwOXk6UDpgOnI7UTtbO2Q7azxsPG08bzxwPHE8cjx1PHY8dzx4PHk8ej1TPVQ9VT1WPVg9WT1dPV49Xz1gPWE9Yj1jPWQ9Zz1oPlA+WD5ZPl0+XlEmWHxRJ1UhZVMnWyVpLWBRK3QmUFEsUCZXUSxmJmdRMG4rU1ExWSt1UTFfK3tRMlEsalEyUixrUTVmMVRRNW8xYVE2WzF6UTZfMXxRNmAyUFE4YDVnUThjNWxROHw2YlE6WDhkUTpmOHlRO1Y6WVI8fSpacm5PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9SLGgmayZ6Xk9QWFlzdHV2d3ohWiFgIWchaiFvI1MjZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5SPlNbI11XWiNXI1onWChUIWIlam0jaCNpI2wkeCVlJWgoXihoKGkoaipZKl4qYitaK1srXixvLVYuVC5aLlsuXS5fL20vcDJkM1szXTRhNnI3VFEld3hRJXt5VyZRfCZWJlcsT1EmXyFUUSdjIWhRJ2UhaVEocSNzUytuJXwlfVErciZQUSxfJmJRLGMmZFMtbCdmJ2dRLmkoclExUitvUTFYK3VRMVordlExXit6UTF0LGBTMXgsZCxlUTJ8LW1RNWUxVFE1aTFXUTVuMWBRNloxeVE4XzVnUThiNWtROGY1cFE6VDheUjtUOlUhVSR6aSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZIV4leXkhaSF1JXslfCV9J1YnZSdmJ2cnayd1KmorbitvLVktbC1tLXQwUjBVMVIydTJ8M1Q0cjRzNHY3fTl7UStoJXdRLFQmW1EsVyZdUSxiJmRRLmgocVExcyxfVTF3LGMsZCxlUTNlLmlRNlUxdFM2WTF4MXlROHg2WiNmPlQjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5vPlU8bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWhXJVRpJVYqeT5QUyZbIVEmaVEmXSFSUSZeIVNVKn0lWyVkPXNSLFImWSVdJVNpI3YkYiRjJGQkeCR7JU8lUSVeJV8lYyl5KlIqVCpWKlkqYSpnKncqeCtmK2ksUyxWLmYvUC9kL20veC95L3swYDBiMGkwajBvMWYxaTFxM2M0XjRfNGo0bzVRNVs1XzZTN1c3djhROFY4WzhxOWI5cDl5OlA6YDpyO1E7WztkO2s8bDxtPG88cDxxPHI8dTx2PHc8eDx5PHo9Uz1UPVU9Vj1YPVk9XT1ePV89YD1hPWI9Yz1kPWc9aD5QPlg+WT5dPl5UKXokdSl7VitQJV08czx0VydbIWUlaSpaLWBTKH0jeSN6UStjJXJRK3kmU1MuYihtKG5RMWosWFE1VDBrUjhpNXUnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlMkaSReYyNZI2UlcSVzJXUoUyhZKHQoeSlSKVMpVClVKVYpVylYKVkpWilbKV4pYCliKWcpcStkK3gtWi14LX0uUy5VLnMudi56LnwufS9PL2IwcDJrMm4zTzNWM2szcDNxM3IzczN0M3UzdjN3M3gzeTN6M3szfDRQNFE0WDVYNWM2dTZ7N1E3YTdiN2s3bDhrOVg5XTlnOW05bjpvO1c7YDxXPXZUI1RWI1UnUmtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNRJ1khZVIycS1dIVchblEhZSFyIXYheSF6JHwnVydfJ2AnbCdtJ24qWiprKm8qcSpyLV0tYy1lLXUwWzBfMW81ezV9UjFsLFpucU9Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfUSZ5IV5RJ3YheFMocyN1PF5RK2wlelEsXSZfUSxeJmFRLWonZFEtdydvUy5yKHg9UFMwcStYPVpRMVArbVExbixbUTJjLHpRMmUse1EybS1XUTJ6LWtRMn0tb1M1WTByPWVRNWExUVM1ZDFTPWZRNnQyb1E2eDJ7UTZ9M1NROF01YlE5WTZ2UTlaNnlROV43T1I6bDlWJGQkXWMjWSNlJXMldShTKFkodCh5KVIpUylUKVUpVilXKVgpWSlaKVspXilgKWIpZylxK2QreC1aLXgtfS5TLlUucy52LnoufS9PL2IwcDJrMm4zTzNWM2szcDNxM3IzczN0M3UzdjN3M3gzeTN6M3szfDRQNFE0WDVYNWM2dTZ7N1E3YTdiN2s3bDhrOVg5XTlnOW05bjpvO1c7YDxXPXZTKG8jcCdpUSlQI3pTK2IlcS58Uy5jKG4ocFIzXi5kJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUyNxXTxWUSZ0IVhRJnUhWVEmdyFbUSZ4IV1SMlosdlEnYSFoUStlJXdRLWgnY1MuZShxK2hRMngtZ1czYi5oLmkwdzB5UTZ3MnlXN1UzXzNhM2U1XlU5YTdWN1g3WlU6cTljOWQ5ZlM7YjpwOnNRO3A7Y1I7eDtxVSF3USdgLWVUNXkxbzV7IVFfT1haYHN0IVYhWiNkI2glZSVtJmkmayZyJnQmdSZ3KGoscyx4LlsyWzJfXSFwUSFyJ2AtZTFvNXtUI3FdPFYlXntPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfUyh9I3kjelMuYihtKG4hcz1sJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNVJGZkKV8sbVMocCNwJ2lVKnYlUih3NE9VMG0rTy5uN2dRNV4weFE3VjNgUTlkN1lSOnM5ZW0hdFEhciF2IXkheidgJ2wnbSduLWUtdTFvNXs1fVEndCF1UyhmI2cyVVMtcydrJ3dRL3MqXVEwUipqUTNVLXZRNGYvdFE0cjBUUTRzMFVRNHgwXlE3cjRgUzd9NHQ0dlM4UjR5NHtROXI3c1E5djd5UTl7OE9ROlE4VFM6ezl3OXhTO2c6fDtQUztzO2g7aVM7ezt0O3VTPFA7fDt9UjxTPFFRI3diUSdzIXVTKGUjZzJVUyhnI20rV1ErWSVmUStqJXhRK3AmT1UtcidrJ3Qnd1EuVyhmVS9yKl0qYC93UTBTKmpRMFYqbFExTytrUTF1LGFTM1Itcy12UTNaLmBTNGUvcy90UTRuMFBTNHEwUjBeUTR1MFdRNlcxdlE3UDNVUzdxNGA0YlE3dTRmVTd8NHI0eDR7UThQNHdROHY2WFM5cTdyN3NROXU3eVE5fThSUTpPOFNROmM4d1E6eTlyUzp6OXY5eFE7UzpRUTteOmRTO2Y6eztQUztyO2c7aFM7ejtzO3VTPE87ezt9UTxSPFBRPFQ8U1E9bz1qUT17PXRSPXw9dVYhd1EnYC1lJV5hT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1Mjd3ohaiFyPWkkWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1I9bz5SJV5iT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1ElZmohXiV4eSFpIXUleyV8JX0nVidlJ2YnZydrJ3UqaituK28tWS1sLW0tdDBSMFUxUjJ1MnwzVDRyNHM0djd9OXtTJk96IWpRK2sleVEsYSZkVzF2LGIsYyxkLGVVNlgxdzF4MXlTOHc2WTZaUTpkOHghcj1qJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNRPXQ+UVI9dT5SJVFlT1BYWXN0dXZ3IVohYCFnIW8jUyNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mciZ0JnUmdyZ7J1QnYidyKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfWSNiV1ojVyNaKFQhYiVqbSNoI2kjbCR4JWUlaCheKGgoaShqKlkqXipiK1orWyteLG8tVi5ULlouWy5dLl8vbS9wMmQzWzNdNGE2cjdUUSxuJm8hcD1rJFokbilzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUj1uJ1hVJ10hZSVpKlpSMnMtYCVTZE9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10scCxzLHgtaS1xLlAuVi50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czbDR6NlQ2ZTZmNmk2fDh0OVQ5XyFyKV8kWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1EsbSZvUTB4K2dRM2AuZ1E3WTNkUjllN1shYiRUYyNZJXEoUyhZKHQoeSlaKVspYClnK3gteC19LlMuVS5zLnYvYjBwM08zVjNrM3s1WDVjNns3UTdhOV06bzxXIVA8ZCleKXEtWi58MmsybjNwM3kzejRQNFg2dTdiN2s3bDhrOVg5ZzltOW47VztgPXYhZiRWYyNZJXEoUyhZKHQoeSlXKVgpWilbKWApZyt4LXgtfS5TLlUucy52L2IwcDNPM1YzazN7NVg1YzZ7N1E3YTldOm88VyFUPGYpXilxLVoufDJrMm4zcDN2M3czeTN6NFA0WDZ1N2I3azdsOGs5WDlnOW05bjtXO2A9diFeJFpjI1klcShTKFkodCh5KWApZyt4LXgtfS5TLlUucy52L2IwcDNPM1YzazN7NVg1YzZ7N1E3YTldOm88V1E0Xy9rej5TKV4pcS1aLnwyazJuM3A0UDRYNnU3YjdrN2w4azlYOWc5bTluO1c7YD12UT5YPlpSPlk+WydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1Mkb2gkcFI0VS9VJ1hnT1BXWFlaaHN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJHAlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9VL1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNUJGtmJHFRJGlmUylqJGwpblIpdiRxVCRqZiRxVClsJGwpbidYaE9QV1hZWmhzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiRwJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVS9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVCRvaCRwUSRyaFIpdSRwJV5qT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5XyFzPlEkWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+UyNnbE9QWFpzdCFaIWAhbyNTI2QjbyN7JG4lbSZrJm4mbyZyJnQmdSZ3JnsnVCdiKU8pcyppK10rZyxwLHMseC1pLmcvVi9uMF0wbDFyMlMyVDJWMlgyWzJfMmEzZDRUNHo2VDZlNmY2aTdbOHQ5VCFVJVJpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPlkjZih3I3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5eUStUJWFRL2MqT280TzxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFVJHlpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPllRKmMkelUqbCR8Kloqb1ErVSViUTBXKm0jZj1xI3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebj1yPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oUT13PlRRPXg+VVE9eT5WUj16PlchVSVSaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZI2YodyN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm80TzxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aG5vT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9TKmYkeypZUS1SJ09RLVMnUVI0aS95JVslU2kjdiRiJGMkZCR4JHslTyVRJV4lXyVjKXkqUipUKlYqWSphKmcqdyp4K2YraSxTLFYuZi9QL2QvbS94L3kvezBgMGIwaTBqMG8xZjFpMXEzYzReNF80ajRvNVE1WzVfNlM3Vzd2OFE4VjhbOHE5YjlwOXk6UDpgOnI7UTtbO2Q7azxsPG08bzxwPHE8cjx1PHY8dzx4PHk8ej1TPVQ9VT1WPVg9WT1dPV49Xz1gPWE9Yj1jPWQ9Zz1oPlA+WD5ZPl0+XlEsVSZdUTFoLFdRNXMxZ1I4aDV0VipuJHwqWipvVSpuJHwqWipvVDV6MW81e1MwUCppL25RNHcwXVQ4UzR6Ol1RK2oleFEwVipsUTFPK2tRMXUsYVE2VzF2UTh2NlhROmM4d1I7XjpkIVUlT2kkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WXgqUiR2KWUqUyp1K1YvdjBkMGU0UjRnNVI1UzVXN3A4VTpSOng9cD19Pk9TMGAqdDBhI2Y8byN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm48cDxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFkPVModSljKlsqZS5qLm0ucS9fL2svfDB2MWUzaDRbNGg0bDVyN103YDd3N3o4WDhaOXQ5fDpTOn07UjtlO2o7dj5aPltgPVQzfTdjN2Y3ajloOnQ6dzt5Uz1fLmwzaVQ9YDdlOWshVSVRaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZfCpUJHYpZSpVKnQrVi9nL3YwZDBlNFI0ZzR8NVI1UzVXN3A4VTpSOng9cD19Pk9TMGIqdTBjI2Y8cSN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm48cjxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFoPVUodSljKlsqZS5rLmwucS9fL2svfDB2MWUzZjNoNFs0aDRsNXI3XTdeN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bZD1WM303ZDdlN2o5aDlpOnQ6dTp3O3lTPWEubTNqVD1iN2Y5bHJuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUSZmIVVSLHAmb3JuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUiZmIVVRLFkmXlIxZCxSc25PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9RMXAsX1M2UjFzMXRVOHA2UDZRNlVTOl84cjhzUztZOl46YVE7bTtaUjt3O25RJm0hVlIsaSZpUjZfMXxSOmY4eVcmUXwmViZXLE9SMVordlEmciFXUixzJnNSLHkmeFQyXSx4Ml9SLH0meVEsfCZ5UjJmLH1RJ3khe1IteSd5U3NPdFEjZFhUJXBzI2RRI09UUid7I09RI1JVUid9I1JRKXskdVIvYCl7USNVVlIoUSNVUSNYV1UoVyNYKFguUVEoWCNZUi5RKFlRLV4nWVIyci1eUS51KHlTM20udTNuUjNuLnZRLWUnYFIydi1lWSFyUSdgLWUxbzV7UidqIXJRL1EpZVI0Uy9RVSNfVyVoKllVKF8jXyhgLlJRKGAjYFIuUihaUS1hJ11SMnQtYXRgT1hzdCFWIVojZCVtJmkmayZyJnQmdSZ3LHMseDJbMl9TI2haJWVVI3JgI2guW1IuWyhqUShrI2pRLlgoZ1cuYShrLlgzWDdSUTNYLllSN1IzWVEpbiRsUi9XKW5RJHBoUil0JHBRJGBjVSlhJGAtfDxqUS18PFdSPGopcVEvcSpdVzRjL3E0ZDd0OXNVNGQvci9zL3RTN3Q0ZTRmUjlzN3UkZSpRJHYodSljKWUqWyplKnQqdStRK1IrVi5sLm0uby5wLnEvXy9nL2kvay92L3wwZDBlMHYxZTNmM2czaDN9NFI0WzRnNGg0bDR8NU81UjVTNVc1cjddN143XzdgN2U3ZjdoN2k3ajdwN3c3ejhVOFg4WjloOWk5ajl0OXw6UjpTOnQ6dTp2Onc6eDp9O1I7ZTtqO3Y7eT1wPX0+Tz5aPltRL3oqZVU0ay96NG03eFE0bS98Ujd4NGxTKm8kfCpaUjBZKm94KlMkdillKnQqdStWL3YwZDBlNFI0ZzVSNVM1VzdwOFU6Ujp4PXA9fT5PIWQuaih1KWMqWyplLmwubS5xL18vay98MHYxZTNoNFs0aDRsNXI3XTdgN3c3ejhYOFo5dDl8OlM6fTtSO2U7ajt2Plo+W1UvaCpTLmo3Y2E3YzN9N2U3ZjdqOWg6dDp3O3lRMGEqdFEzaS5sVTR9MGEzaTlrUjlrN2V8KlUkdillKnQqdStWL2cvdjBkMGU0UjRnNHw1UjVTNVc3cDhVOlI6eD1wPX0+TyFoLmsodSljKlsqZS5sLm0ucS9fL2svfDB2MWUzZjNoNFs0aDRsNXI3XTdeN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bVS9qKlUuazdkZTdkM303ZTdmN2o5aDlpOnQ6dTp3O3lRMGMqdVEzai5tVTVQMGMzajlsUjlsN2ZRKnolVVIwZyp6UTVdMHZSOFk1XVErXyVrUjB1K19RNXYxalM4ajV2OltSOls4a1EsWyZfUjFtLFtRNXsxb1I4bTV7UTF7LGZTNl0xezh6Ujh6Nl9RMVUrclc1aDFVNWo4YTpWUTVqMVhROGE1aVI6VjhiUSt3JlFSMVsrd1EyXyx4UjZtMl9Zck9Yc3QjZFEmdiFaUSthJW1RLHImclEsdCZ0USx1JnVRLHcmd1EyWSxzUzJdLHgyX1I2bDJbUSVvcFEmeiFfUSZ9IWFRJ1AhYlEnUiFjUSdxIXVRK2AlbFErbCV6USxRJlhRLGgmbVEtUCZ8Vy1wJ2sncyd0J3dRLXcnb1EwWCpuUTFQK21RMWMsUFMyTyxpLGxRMmctT1EyaC1SUTJpLVNRMn0tb1czUC1yLXMtdi14UTVhMVFRNW0xX1E1cTFlUTZWMXVRNmEyUVE2azJaVTZ6M08zUjNVUTZ9M1NROF01YlE4ZTVvUThnNXJROGw1elE4dTZXUTh7NmBTOVs2ezdQUTleN09ROlc4Y1E6Yjh2UTpnOHxROm45XVE7VTpYUTtdOmNRO2E6b1E7bDtWUjtvO15RJXp5USdkIWlRJ28hdVUrbSV7JXwlfVEtVydWVS1rJ2UnZidnUy1vJ2sndVEwUSpqUzFRK24rb1Eyby1ZUzJ7LWwtbVEzUy10UzRwMFIwVVE1YjFSUTZ2MnVRNnkyfFE3TzNUVTd7NHI0czR2UTl6N31SO085e1Mkd2k+UFIqeyVWVSVVaSVWPlBSMGYqeVEkdmlTKHUjditpUyljJGIkY1EpZSRkUSpbJHhTKmUkeypZUSp0JU9RKnUlUVErUSVeUStSJV9RK1YlY1EubDxvUS5tPHFRLm88dVEucDx3US5xPHlRL18peVEvZypSUS9pKlRRL2sqVlEvdiphUy98KmcvbVEwZCp3UTBlKnhsMHYrZixWLmYxaTFxM2M2UzdXOHE5YjpgOnI7WztkUTFlLFNRM2Y9U1EzZz1VUTNoPVhTM308bDxtUTRSL1BTNFsvZDReUTRnL3hRNGgveVE0bC97UTR8MGBRNU8wYlE1UjBpUTVTMGpRNVcwb1E1cjFmUTddPV1RN149X1E3Xz1hUTdgPWNRN2U8cFE3ZjxyUTdoPHZRN2k8eFE3ajx6UTdwNF9RN3c0alE3ejRvUThVNVFROFg1W1E4WjVfUTloPVlROWk9VFE5aj1WUTl0N3ZROXw4UVE6UjhWUTpTOFtROnQ9XlE6dT1gUTp2PWJROnc9ZFE6eDlwUTp9OXlRO1I6UFE7ZT1nUTtqO1FRO3Y7a1E7eT1oUT1wPlBRPX0+WFE+Tz5ZUT5aPl1SPls+XlErTyVdUS5uPHNSN2c8dG5wT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9RIWZQUyNmWiNvUSZ8IWBXJ2ghbyppMF00elEoUCNTUSlRI3tRKXIkblMsbCZrJm5RLHEmb1EtTyZ7Uy1UJ1QvblEtZydiUS54KU9RL1spc1EwcytdUTB5K2dRMlcscFEyeS1pUTNhLmdRNFcvVlE1VTBsUTZRMXJRNmMyU1E2ZDJUUTZoMlZRNmoyWFE2bzJhUTdaM2RRN200VFE4czZUUTlQNmVROVE2ZlE5UzZpUTlmN1tROmE4dFI6azlUI1tjT1BYWnN0IVohYCFvI2QjbyN7JW0mayZuJm8mciZ0JnUmdyZ7J1QnYilPKmkrXStnLHAscyx4LWkuZy9uMF0wbDFyMlMyVDJWMlgyWzJfMmEzZDR6NlQ2ZTZmNmk3Wzh0OVRRI1lXUSNlWVElcXVRJXN2UyV1dyFnUyhTI1coVlEoWSNaUSh0I3VRKHkjeFEpUiRPUSlTJFBRKVQkUVEpVSRSUSlWJFNRKVckVFEpWCRVUSlZJFZRKVokV1EpWyRYUSleJFpRKWAkX1EpYiRhUSlnJGVXKXEkbilzL1Y0VFErZCV0USt4JlJTLVonWDJwUS14J3JTLX0oVC5QUS5TKF1RLlUoZFEucyh4US52KHpRLno8VVEufDxYUS59PFlRL088XVEvYil9UTBwK1hRMmstVVEybi1YUTNPLXFRM1YuVlEzay50UTNwPF5RM3E8X1EzcjxgUTNzPGFRM3Q8YlEzdTxjUTN2PGRRM3c8ZVEzeDxmUTN5PGdRM3o8aFEzey57UTN8PGtRNFA8blE0UTx7UTRYPGlRNVgwclE1YzFTUTZ1PU9RNnszUVE3UTNXUTdhM2xRN2I9UFE3az1SUTdsPVpROGs1d1E5WDZzUTldNnxROWc9W1E5bT1lUTluPWZROm85X1E7VzpaUTtgOm1RPFcjU1I9dj5TUiNbV1InWiFlbCF0USFyIXYheSF6J2AnbCdtJ24tZS11MW81ezV9UydWIWUtXVUqaiR8Kloqb1MtWSdXJ19TMFUqaypxUTBeKnJRMnUtY1E0djBbUjR7MF9SKHsjeFEhZlFULWQnYC1lXSFxUSFyJ2AtZTFvNXtRI3BdUidpPFZSKWYkZFkhdVEnYC1lMW81e1EnayFyUyd1IXYheVMndyF6NX1TLXQnbCdtUS12J25SM1QtdVQja1olZVMjalolZVMla20sb1UoZyNoI2kjbFMuWShoKGlRLl4oalEwdCteUTNZLlpVM1ouWy5dLl9TN1MzWzNdUjlgN1RkI15XI1cjWiVoKFQoXipZK1ouVC9tciNnWm0jaCNpI2wlZShoKGkoaiteLlouWy5dLl8zWzNdN1RTKl0keCpiUS90Kl5RMlUsb1EybC1WUTRgL3BRNnEyZFE3czRhUTlXNnJUPW0nWCtbViNhVyVoKllVI2BXJWgqWVMoVSNXKF5VKFojWitaL21TLVsnWCtbVC5PKFQuVFYnXiFlJWkqWlEkbGZSKXgkcVQpbSRsKW5SNFYvVVQqXyR4KmJUKmgkeypZUTB3K2ZRMWcsVlEzXy5mUTV0MWlRNlAxcVE3WDNjUThyNlNROWM3V1E6XjhxUTpwOWJRO1o6YFE7YzpyUTtuO1tSO3E7ZG5xT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9RJmwhVlIsaCZpdG1PWHN0IVUhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1IsbyZvVCVsbSxvUjFrLFhSLGcmZ1EmVXxTK30mViZXUjFeLE9SK3MmUFQmcCFXJnNUJnEhVyZzVDJeLHgyX1wiLFxuICBub2RlTmFtZXM6IFwi4pqgIEFyaXRoT3AgQXJpdGhPcCA/LiBKU1hTdGFydFRhZyBMaW5lQ29tbWVudCBCbG9ja0NvbW1lbnQgU2NyaXB0IEhhc2hiYW5nIEV4cG9ydERlY2xhcmF0aW9uIGV4cG9ydCBTdGFyIGFzIFZhcmlhYmxlTmFtZSBTdHJpbmcgRXNjYXBlIGZyb20gOyBkZWZhdWx0IEZ1bmN0aW9uRGVjbGFyYXRpb24gYXN5bmMgZnVuY3Rpb24gVmFyaWFibGVEZWZpbml0aW9uID4gPCBUeXBlUGFyYW1MaXN0IGluIG91dCBjb25zdCBUeXBlRGVmaW5pdGlvbiBleHRlbmRzIFRoaXNUeXBlIHRoaXMgTGl0ZXJhbFR5cGUgQXJpdGhPcCBOdW1iZXIgQm9vbGVhbkxpdGVyYWwgVGVtcGxhdGVUeXBlIEludGVycG9sYXRpb25FbmQgSW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0aW9uU3RhcnQgTnVsbFR5cGUgbnVsbCBWb2lkVHlwZSB2b2lkIFR5cGVvZlR5cGUgdHlwZW9mIE1lbWJlckV4cHJlc3Npb24gLiBQcm9wZXJ0eU5hbWUgWyBUZW1wbGF0ZVN0cmluZyBFc2NhcGUgSW50ZXJwb2xhdGlvbiBzdXBlciBSZWdFeHAgXSBBcnJheUV4cHJlc3Npb24gU3ByZWFkICwgfSB7IE9iamVjdEV4cHJlc3Npb24gUHJvcGVydHkgYXN5bmMgZ2V0IHNldCBQcm9wZXJ0eURlZmluaXRpb24gQmxvY2sgOiBOZXdUYXJnZXQgbmV3IE5ld0V4cHJlc3Npb24gKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCA8IEFycm93RnVuY3Rpb24gVHlwZVBhcmFtTGlzdCBTZXF1ZW5jZUV4cHJlc3Npb24gSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gS2V5b2ZUeXBlIGtleW9mIFVuaXF1ZVR5cGUgdW5pcXVlIEltcG9ydFR5cGUgSW5mZXJyZWRUeXBlIGluZmVyIFR5cGVOYW1lIFBhcmVudGhlc2l6ZWRUeXBlIEZ1bmN0aW9uU2lnbmF0dXJlIFBhcmFtTGlzdCBOZXdTaWduYXR1cmUgSW5kZXhlZFR5cGUgVHVwbGVUeXBlIExhYmVsIEFycmF5VHlwZSBSZWFkb25seVR5cGUgT2JqZWN0VHlwZSBNZXRob2RUeXBlIFByb3BlcnR5VHlwZSBJbmRleFNpZ25hdHVyZSBQcm9wZXJ0eURlZmluaXRpb24gQ2FsbFNpZ25hdHVyZSBUeXBlUHJlZGljYXRlIGFzc2VydHMgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciB1c2luZyBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBkZWZlciBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM4MCxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC04LDUsNiwxNCwzNywzOSw1MSw1Myw1NSxcIlwiXSxcbiAgICBbXCJncm91cFwiLCAtMjYsOSwxNywxOSw2OCwyMDcsMjExLDIxNSwyMTYsMjE4LDIyMSwyMjQsMjM0LDIzNywyNDMsMjQ1LDI0NywyNDksMjUyLDI1OCwyNjQsMjY2LDI2OCwyNzAsMjcyLDI3NCwyNzUsXCJTdGF0ZW1lbnRcIiwtMzQsMTMsMTQsMzIsMzUsMzYsNDIsNTEsNTQsNTUsNTcsNjIsNzAsNzIsNzYsODAsODIsODQsODUsMTEwLDExMSwxMjAsMTIxLDEzNiwxMzksMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDcsMTQ4LDE2NywxNjksMTcxLFwiRXhwcmVzc2lvblwiLC0yMywzMSwzMywzNyw0MSw0Myw0NSwxNzMsMTc1LDE3NywxNzgsMTgwLDE4MSwxODIsMTg0LDE4NSwxODYsMTg4LDE4OSwxOTAsMjAxLDIwMywyMDUsMjA2LFwiVHlwZVwiLC0zLDg4LDEwMywxMDksXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjMsXCI8XCIsMzgsXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiw1NixcIltcIiw2MCxcIntcIiw3MyxcIihcIiwxNjAsXCJKU1hTdGFydENsb3NlVGFnXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIC0yLDI0LDE2OCxcIj5cIiw0MCxcIkludGVycG9sYXRpb25FbmRcIiw1MCxcIl1cIiw2MSxcIn1cIiw3NCxcIilcIiwxNjUsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsNSw2LDI3OF0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRnEwN1tSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM6TyFSIVsjPF8hWyFdI0lfIV0hXiNKayFeIV8jS3UhXyFgJCFbIWAhYSQkdiFhIWIkKlQhYiFjJCxyIWMhfUVyIX0jTyQtfCNPI1AkL1cjUCNRJDRvI1EjUiQ1eSNSI1NFciNTI1QkN1cjVCNvJDhiI28jcCQ8ciNwI3EkPWgjcSNyJD54I3IjcyRAVSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQWAjQlokSVNFciRJUyRJXyRBYCRJXyRJfEVyJEl8JEl9JERrJEl9JEpPJERrJEpPJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyKG4lZF8kaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kaSZqKFohYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFohYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGkmaihXcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoV3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWjA3WytycSRpJmooV3AoWiFiJ3wwL2xPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVowN1suU1QoWCNTJGkmaid9MC9sTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMwN1subl8kaSZqKFdwKFohYid9MC9sT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopM3AveGAkaSZqIXApLFEoV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cxVmAjdihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cyZF8jdihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQzbF8oVic6ZiRpJmooWiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRpJmooWiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRpJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkZGAkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kZGBgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kZGAkaSZqKFohYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFohYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkZGAoWiFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrJTlbOmhoJGkmaihXcChaIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fV1MkaSZqKFdwKFohYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11XUyRpJmooWiFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hXUyRpJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1dTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXV1MoWiFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddV1MkaSZqKFdwT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1dTKFdwT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllXUyhXcChaIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMlOVtDfWkkaSZqKG8lMWwoV3AoWiFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciU5W0VvUDs9YDwlbENyMDdbRlJrJGkmaihXcChaIWIkXSN0KFQsMmooZSRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskaSZqKFdwKFohYiRdI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YwN1tKUFA7PWA8JWxFcihLV0pfYCRpJmooV3AoWiFiI3AoQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLV0tsXyRpJmokUShDaChXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiwjeEx2YSh6K0pZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1dOV2AkaSZqI3ooQ2goV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQhIGNfKFknO1ckaSZqKFdwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kaSZqKFdwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkaSZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGRgJGkmaihXcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihXcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkZGAoV3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiLzV8ISd0XyFsLy5eJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMmVSEpT18hayFMZiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVotIW4hKltiJGkmaihXcChaIWIoVSUmZiNxKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7IStkeyFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1chK29gJGkmaihXcChaIWIjbihDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKzt4ISx8YCRpJmooV3AoWiFicis0WU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLCRVIS5aXyFdK0pmJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyEvZWMkaSZqKFdwKFohYiFRLjJeT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITBwIVAhUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEweWEkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEyTyFQIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEyWl8hWyFMXiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhM2VnJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITVWZyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITZ3YyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE4X2MkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbITl1ZiRpJmooV3AoWiFiI28oQ2hPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3h6ITtaensjLX17IVAhO1ohUCFRIy9kIVEhXiE7WiFeIV8jKGkhXyFgIzdTIWAhYSM4aSFhIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaP08hO2ZiJGkmaihXcChaIWIhWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7Wj5eITx3YCRpJmooWiFiIVg3YE9ZITxuWVomY1p3ITxud3ghPXl4IVAhPG4hUCFRIUVxIVEhXiE8biFeIV8hR3IhXyF9ITxuIX0jTyFLUyNPI1AhRHkjUCNvITxuI28jcCFHciNwOydTITxuOydTOz1gIUxdPCVsTyE8bjx6IT5RXiRpJmohWDdgT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBjIV8hfSE9eSF9I08hQ1cjTyNQIUR5I1AjbyE9eSNvI3AhQGMjcDsnUyE9eTsnUzs9YCFFazwlbE8hPXk8eiE/VGQkaSZqIVg3YE8hXiZjIV8jVyZjI1cjWCE+fCNYI1omYyNaI1shPnwjWyNdJmMjXSNeIT58I14jYSZjI2EjYiE+fCNiI2cmYyNnI2ghPnwjaCNpJmMjaSNqIT58I2ojayE+fCNrI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmM3YCFAaFghWDdgT1khQGNaIVAhQGMhUCFRIUFUIVEhfSFAYyF9I08hQXIjTyNQIUJxI1A7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQVlXIVg3YCNXI1ghQVQjWiNbIUFUI10jXiFBVCNhI2IhQVQjZyNoIUFUI2kjaiFBVCNqI2shQVQjbSNuIUFUN2AhQXVWT1khQXJaI08hQXIjTyNQIUJbI1AjUSFAYyNROydTIUFyOydTOz1gIUJrPCVsTyFBcjdgIUJfU09ZIUFyWjsnUyFBcjsnUzs9YCFCazwlbE8hQXI3YCFCblA7PWA8JWwhQXI3YCFCdFNPWSFAY1o7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQ1RQOz1gPCVsIUBjPHohQ11bJGkmak9ZIUNXWVomY1ohXiFDVyFeIV8hQXIhXyNPIUNXI08jUCFEUiNQI1EhPXkjUSNvIUNXI28jcCFBciNwOydTIUNXOydTOz1gIURzPCVsTyFDVzx6IURXWCRpJmpPWSFDV1laJmNaIV4hQ1chXiFfIUFyIV8jbyFDVyNvI3AhQXIjcDsnUyFDVzsnUzs9YCFEczwlbE8hQ1c8eiFEdlA7PWA8JWwhQ1c8eiFFT1gkaSZqT1khPXlZWiZjWiFeIT15IV4hXyFAYyFfI28hPXkjbyNwIUBjI3A7J1MhPXk7J1M7PWAhRWs8JWxPIT15PHohRW5QOz1gPCVsIT15Pl4hRXpsJGkmaihaIWIhWDdgT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjVyZ9I1cjWCFFcSNYI1omfSNaI1shRXEjWyNdJn0jXSNeIUVxI14jYSZ9I2EjYiFFcSNiI2cmfSNnI2ghRXEjaCNpJn0jaSNqIUVxI2ojayFFcSNrI20mfSNtI24hRXEjbiNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn04ciFHeVooWiFiIVg3YE9ZIUdyWnchR3J3eCFAY3ghUCFHciFQIVEhSGwhUSF9IUdyIX0jTyFKVSNPI1AhQnEjUDsnUyFHcjsnUzs9YCFKfDwlbE8hR3I4ciFIc2UoWiFiIVg3YE9ZJ31adyd9eCNPJ30jUCNXJ30jVyNYIUhsI1gjWid9I1ojWyFIbCNbI10nfSNdI14hSGwjXiNhJ30jYSNiIUhsI2IjZyd9I2cjaCFIbCNoI2knfSNpI2ohSGwjaiNrIUhsI2sjbSd9I20jbiFIbCNuOydTJ307J1M7PWAoZjwlbE8nfThyIUpaWChaIWJPWSFKVVp3IUpVd3ghQXJ4I08hSlUjTyNQIUJbI1AjUSFHciNROydTIUpVOydTOz1gIUp2PCVsTyFKVThyIUp5UDs9YDwlbCFKVThyIUtQUDs9YDwlbCFHcj5eIUtaXiRpJmooWiFiT1khS1NZWiZjWnchS1N3eCFDV3ghXiFLUyFeIV8hSlUhXyNPIUtTI08jUCFEUiNQI1EhPG4jUSNvIUtTI28jcCFKVSNwOydTIUtTOydTOz1gIUxWPCVsTyFLUz5eIUxZUDs9YDwlbCFLUz5eIUxgUDs9YDwlbCE8bj1sIUxsYCRpJmooV3AhWDdgT1khTGNZWiZjWnIhTGNycyE9eXMhUCFMYyFQIVEhTW4hUSFeIUxjIV4hXyMgbyFfIX0hTGMhfSNPIyVQI08jUCFEeSNQI28hTGMjbyNwIyBvI3A7J1MhTGM7J1M7PWAjJlk8JWxPIUxjPWwhTXdsJGkmaihXcCFYN2BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNXKHIjVyNYIU1uI1gjWihyI1ojWyFNbiNbI10ociNdI14hTW4jXiNhKHIjYSNiIU1uI2IjZyhyI2cjaCFNbiNoI2kociNpI2ohTW4jaiNrIU1uI2sjbShyI20jbiFNbiNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocjhRIyB2WihXcCFYN2BPWSMgb1pyIyBvcnMhQGNzIVAjIG8hUCFRIyFpIVEhfSMgbyF9I08jJFIjTyNQIUJxI1A7J1MjIG87J1M7PWAjJHk8JWxPIyBvOFEjIXBlKFdwIVg3YE9ZKXJacilycyNPKXIjUCNXKXIjVyNYIyFpI1gjWilyI1ojWyMhaSNbI10pciNdI14jIWkjXiNhKXIjYSNiIyFpI2IjZylyI2cjaCMhaSNoI2kpciNpI2ojIWkjaiNrIyFpI2sjbSlyI20jbiMhaSNuOydTKXI7J1M7PWAqWjwlbE8pcjhRIyRXWChXcE9ZIyRSWnIjJFJycyFBcnMjTyMkUiNPI1AhQlsjUCNRIyBvI1E7J1MjJFI7J1M7PWAjJHM8JWxPIyRSOFEjJHZQOz1gPCVsIyRSOFEjJHxQOz1gPCVsIyBvPWwjJVdeJGkmaihXcE9ZIyVQWVomY1pyIyVQcnMhQ1dzIV4jJVAhXiFfIyRSIV8jTyMlUCNPI1AhRFIjUCNRIUxjI1EjbyMlUCNvI3AjJFIjcDsnUyMlUDsnUzs9YCMmUzwlbE8jJVA9bCMmVlA7PWA8JWwjJVA9bCMmXVA7PWA8JWwhTGM/TyMma24kaSZqKFdwKFohYiFYN2BPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1clWiNXI1gjJmAjWCNaJVojWiNbIyZgI1sjXSVaI10jXiMmYCNeI2ElWiNhI2IjJmAjYiNnJVojZyNoIyZgI2gjaSVaI2kjaiMmYCNqI2sjJmAjayNtJVojbSNuIyZgI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaOWQjKHJdKFdwKFohYiFYN2BPWSMoaVpyIyhpcnMhR3JzdyMoaXd4IyBveCFQIyhpIVAhUSMpayFRIX0jKGkhfSNPIytgI08jUCFCcSNQOydTIyhpOydTOz1gIyxgPCVsTyMoaTlkIyl0aChXcChaIWIhWDdgT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1cqZyNXI1gjKWsjWCNaKmcjWiNbIylrI1sjXSpnI10jXiMpayNeI2EqZyNhI2IjKWsjYiNnKmcjZyNoIylrI2gjaSpnI2kjaiMpayNqI2sjKWsjayNtKmcjbSNuIylrI247J1MqZzsnUzs9YCtaPCVsTypnOWQjK2daKFdwKFohYk9ZIytgWnIjK2BycyFKVXN3Iytgd3gjJFJ4I08jK2AjTyNQIUJbI1AjUSMoaSNROydTIytgOydTOz1gIyxZPCVsTyMrYDlkIyxdUDs9YDwlbCMrYDlkIyxjUDs9YDwlbCMoaT9PIyxvYCRpJmooV3AoWiFiT1kjLGZZWiZjWnIjLGZycyFLU3N3Iyxmd3gjJVB4IV4jLGYhXiFfIytgIV8jTyMsZiNPI1AhRFIjUCNRITtaI1EjbyMsZiNvI3AjK2AjcDsnUyMsZjsnUzs9YCMtcTwlbE8jLGY/TyMtdFA7PWA8JWwjLGY/TyMtelA7PWA8JWwhO1owN1sjLltiJGkmaihXcChaIWIoTzAvbCFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaMDdbIy9vXyRpJmooV3AoWiFiVDAvbE9ZIy9kWVomY1pyIy9kcnMjMG5zdyMvZHd4IzRPeCFeIy9kIV4hXyM1fSFfI08jL2QjTyNQIzFwI1AjbyMvZCNvI3AjNX0jcDsnUyMvZDsnUzs9YCM2fDwlbE8jL2QwNmojMHddJGkmaihaIWJUMC9sT1kjMG5ZWiZjWncjMG53eCMxcHghXiMwbiFeIV8jM1IhXyNPIzBuI08jUCMxcCNQI28jMG4jbyNwIzNSI3A7J1MjMG47J1M7PWAjM3g8JWxPIzBuMDVXIzF3WCRpJmpUMC9sT1kjMXBZWiZjWiFeIzFwIV4hXyMyZCFfI28jMXAjbyNwIzJkI3A7J1MjMXA7J1M7PWAjMns8JWxPIzFwMC9sIzJpU1QwL2xPWSMyZFo7J1MjMmQ7J1M7PWAjMnU8JWxPIzJkMC9sIzJ4UDs9YDwlbCMyZDA1VyMzT1A7PWA8JWwjMXAwMU8jM1lXKFohYlQwL2xPWSMzUlp3IzNSd3gjMmR4I08jM1IjTyNQIzJkI1A7J1MjM1I7J1M7PWAjM3I8JWxPIzNSMDFPIzN1UDs9YDwlbCMzUjA2aiMze1A7PWA8JWwjMG4wNXgjNFhdJGkmaihXcFQwL2xPWSM0T1laJmNaciM0T3JzIzFwcyFeIzRPIV4hXyM1USFfI08jNE8jTyNQIzFwI1AjbyM0TyNvI3AjNVEjcDsnUyM0TzsnUzs9YCM1dzwlbE8jNE8wMF4jNVhXKFdwVDAvbE9ZIzVRWnIjNVFycyMyZHMjTyM1USNPI1AjMmQjUDsnUyM1UTsnUzs9YCM1cTwlbE8jNVEwMF4jNXRQOz1gPCVsIzVRMDV4IzV6UDs9YDwlbCM0TzAxcCM2V1koV3AoWiFiVDAvbE9ZIzV9WnIjNX1ycyMzUnN3IzV9d3gjNVF4I08jNX0jTyNQIzJkI1A7J1MjNX07J1M7PWAjNnY8JWxPIzV9MDFwIzZ5UDs9YDwlbCM1fTA3WyM3UFA7PWA8JWwjL2QpM2gjN2FiJGkmaiRRKENoKFdwKFohYiFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaQXQjOHZiJFojdCRpJmooV3AoWiFiIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1onQWQjOlpwJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjVSVaI1UjViM/aSNWI1glWiNYI1khNHwjWSNiJVojYiNjIz5fI2MjZCNCcSNkI2wlWiNsI20jRXMjbSNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPGprJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPmpfJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjP3JkJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNBXWYkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjQnpjJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjRFYhWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0RWI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0RiZSRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNEViFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjRFYjUyNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0V8ZyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0dlIVshXiVaIV4hXypnIV8hYyVaIWMhaSNHZSFpI08lWiNPI1AmYyNQI1IlWiNSI1MjR2UjUyNUJVojVCNaI0dlI1ojbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0dwaSRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNHZSFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjR2UhaSNPJVojTyNQJmMjUCNSJVojUiNTI0dlI1MjVCVaI1QjWiNHZSNaI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoqKXgjSWxfIWckYiRpJmokTylMdihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWilbI0p2X2FsJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiNMU15oIylgI1ItPFUoV3AoWiFiJG43YE9ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI01PIVEhXipnIV4hXyNNdCFfIWAkIGYhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNNWFgkayZqKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTX1aI3IoQ2goV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTnAhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTnlYJFEoQ2goV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCQgb1gjcyhDaChXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKil4JCFnYSNgKiFZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkI2whYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1skI3dfI2soQ2wkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKil4JCVWYWchKnIjcyhDaCRmI3wkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYCQmWyFgIWEkJ2YhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckJmdfI3MoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCdxYSNyKENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgIWEkKHYhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckKVJgI3IoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtkJCpgYShyKEN0JGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWElWiFhIWIkK2UhYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckK3BgJGkmaiN7KENoKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNgJCx9XyF8JElwJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiQuWF8hUzAsdiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvXVokaSZqTyFeJDBPIV4hXyQwZiFfI2kkME8jaSNqJDBrI2ojbCQwTyNsI20kMl4jbSNvJDBPI28jcCQwZiNwOydTJDBPOydTOz1gJDRpPCVsTyQwTyhuJDBWVF8jUyRpJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBrT18jUyhuJDBwWyRpJmpPIVEmYyFRIVskMWYhWyFeJmMhXyFjJmMhYyFpJDFmIWkjVCZjI1QjWiQxZiNaI28mYyNvI3AkM3wjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxa1okaSZqTyFRJmMhUSFbJDJeIVshXiZjIV8hYyZjIWMhaSQyXiFpI1QmYyNUI1okMl4jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyY1okaSZqTyFRJmMhUSFbJDNVIVshXiZjIV8hYyZjIWMhaSQzVSFpI1QmYyNUI1okM1UjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzWlokaSZqTyFRJmMhUSFbJDBPIVshXiZjIV8hYyZjIWMhaSQwTyFpI1QmYyNUI1okME8jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQ0UFIhUSFbJDRZIWMhaSQ0WSNUI1okNFkjUyQ0XVMhUSFbJDRZIWMhaSQ0WSNUI1okNFkjcSNyJDBmKG4kNGxQOz1gPCVsJDBPIzFbJDR6XyFZIylsJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQ2VWAjeChDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVorO3AkN2NfJGkmaihXcChaIWIoYSs0UU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbJDhxayRpJmooV3AoWiFiKFQsMmokXyN0KGUkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhidXclWnd4KHJ4fSVafSFPJDpmIU8hUSVaIVEhWyQ4YiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOGIhfSNPJVojTyNQJmMjUCNSJVojUiNTJDhiI1MjVCVaI1QjbyQ4YiNvI3AqZyNwJGclWiRnOydTJDhiOydTOz1gJDxsPCVsTyQ4YitkJDpxayRpJmooV3AoWiFiJF8jdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOmZ1dyVad3gocnh9JVp9IU8kOmYhTyFRJVohUSFbJDpmIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6ZiF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOmYjUyNUJVojVCNvJDpmI28jcCpnI3AkZyVaJGc7J1MkOmY7J1M7PWAkPGY8JWxPJDpmK2QkPGlQOz1gPCVsJDpmMDdbJDxvUDs9YDwlbCQ4YiNKZiQ8e1ghXyNIYihXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnLCN4JD1zYSh5K0pZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK2UjcTsnUyVaOydTOz1gK2E8JWxPJVopPnYkP1ZfIV4oQ2R2QnIkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaP08kQGFfIXE3YCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1skQXF8JGkmaihXcChaIWInfDAvbCRdI3QoVCwyaihlJElbT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBYCNCWiRJU0VyJElTJElfJEFgJElfJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyMDdbJER8ayRpJmooV3AoWiFiJ30wL2wkXSN0KFQsMmooZSRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyXCIsXG4gIHRva2VuaXplcnM6IFtub1NlbWljb2xvbiwgbm9TZW1pY29sb25UeXBlLCBvcGVyYXRvclRva2VuLCBqc3gsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgaW5zZXJ0U2VtaWNvbG9uLCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwiJFN+UlJ0dVsjTyNQZyNTI1QjfH5fUCNvI3BifmdPeH5+alZPI2khUCNpI2ohVSNqI2whUCNsI20hcSNtOydTIVA7J1M7PWAjdjwlbE8hUH4hVU8hVX5+IVhTIVEhWyFlIWMhaSFlI1QjWiFlI28jcCNafiFoUiFRIVshcSFjIWkhcSNUI1ohcX4hdFIhUSFbIX0hYyFpIX0jVCNaIX1+I1FSIVEhWyFQIWMhaSFQI1QjWiFQfiNeUiFRIVsjZyFjIWkjZyNUI1ojZ34jalMhUSFbI2chYyFpI2cjVCNaI2cjcSNyIVB+I3lQOz1gPCVsIVB+JFJPKGN+flwiLCAxNDEsIDM0MCksIG5ldyBMb2NhbFRva2VuR3JvdXAoXCJqflJRWVpYentefl5PKFF+fmFQIVAhUWR+aU8oUn5+XCIsIDI1LCAzMjMpXSxcbiAgdG9wUnVsZXM6IHtcIlNjcmlwdFwiOlswLDddLFwiU2luZ2xlRXhwcmVzc2lvblwiOlsxLDI3Nl0sXCJTaW5nbGVDbGFzc0l0ZW1cIjpbMiwyNzddfSxcbiAgZGlhbGVjdHM6IHtqc3g6IDAsIHRzOiAxNTE3NX0sXG4gIGR5bmFtaWNQcmVjZWRlbmNlczoge1wiODBcIjoxLFwiODJcIjoxLFwiOTRcIjoxLFwiMTY5XCI6MSxcIjE5OVwiOjF9LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzMjcsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzQzLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY193b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDk1LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19MZXNzVGhhblt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxNTIwMVxufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */;\n        if (lookaheadRecord)\n            this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) {\n                let mustMove = false;\n                for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove)\n                    while (index > 0 && this.buffer[index - 2] > end) {\n                        // Move this record forward\n                        this.buffer[index] = this.buffer[index - 4];\n                        this.buffer[index + 1] = this.buffer[index - 3];\n                        this.buffer[index + 2] = this.buffer[index - 2];\n                        this.buffer[index + 3] = this.buffer[index - 1];\n                        index -= 4;\n                        if (size > 4)\n                            size -= 4;\n                    }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */\n    acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5Q0FBeUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFD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cmVpZnktY29kZS13ZWIvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanM/MzYyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgVHJlZSwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5BIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbnBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xudGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbmFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGFjayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgKi9cbiAgICBwLCBcbiAgICAvKipcbiAgICBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhY2ssIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2VQb3MsIFxuICAgIC8qKlxuICAgIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXJCYXNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1ckNvbnRleHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgdHJhY2tlci5cbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBsb29rYWhlYWRSZWNvcmQgPSB0aGlzLnJlZHVjZVBvcyA8IHRoaXMucG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLztcbiAgICAgICAgaWYgKGxvb2thaGVhZFJlY29yZClcbiAgICAgICAgICAgIHRoaXMuc2V0TG9va0FoZWFkKHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgbG9va2FoZWFkUmVjb3JkID8gOCA6IDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDJdIDogdGhpcy5wLnJhbmdlc1swXS5mcm9tLCBzaXplID0gdGhpcy5yZWR1Y2VQb3MgLSBzdGFydDtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byB0cnkgYW5kIGRldGVjdCBvdmVybHkgZGVlcCBsZWZ0LWFzc29jaWF0aXZlXG4gICAgICAgIC8vIHRyZWVzLCB3aGljaCB3aWxsIG5vdCBpbmNyZWFzZSB0aGUgcGFyc2Ugc3RhY2sgZGVwdGggYW5kIHRodXNcbiAgICAgICAgLy8gd29uJ3QgYmUgY2F1Z2h0IGJ5IHRoZSByZWd1bGFyIHN0YWNrLWRlcHRoIGxpbWl0IGNoZWNrLlxuICAgICAgICBpZiAoc2l6ZSA+PSAyMDAwIC8qIFJlY292ZXIuTWluQmlnUmVkdWN0aW9uICovICYmICEoKF9hID0gdGhpcy5wLnBhcnNlci5ub2RlU2V0LnR5cGVzW3R5cGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBbm9ueW1vdXMpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAxXSA6IDAsIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5SZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIG11c3RTaW5rID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJlxuICAgICAgICAgICAgKCF0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLmJ1ZmZlckJhc2UpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW11c3RTaW5rIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBpbmRleDsgc2NhbiA+IDAgJiYgdGhpcy5idWZmZXJbc2NhbiAtIDJdID4gZW5kOyBzY2FuIC09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3NjYW4gLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobXVzdE1vdmUpXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNoaWZ0KGFjdGlvbiwgdHlwZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5wb3MgfHwgdHlwZSA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIFJlY292ZXIuRGVsZXRlICovO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICAqL1xuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBSZWNvdmVyLk1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIFJlY292ZXIuSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgcmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIFBhcnNlU3RhdGUuRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBiYWNrdXAgPSB0aGlzLmZpbmRGb3JjZWRSZWR1Y3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3VwID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZWR1Y2UgPSBiYWNrdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVjb3Zlci5SZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBzY2FuIHRocm91Z2ggdGhlIGF1dG9tYXRvbiB0byBmaW5kIHNvbWUga2luZCBvZiByZWR1Y3Rpb25cbiAgICB0aGF0IGNhbiBiZSBhcHBsaWVkLiBVc2VkIHdoZW4gdGhlIHJlZ3VsYXIgRm9yY2VkUmVkdWNlIGZpZWxkXG4gICAgaXNuJ3QgYSB2YWxpZCBhY3Rpb24uIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZEZvcmNlZFJlZHVjdGlvbigpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnAsIHNlZW4gPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAoc3RhdGUsIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmNsdWRlcyhzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuYWxsQWN0aW9ucyhzdGF0ZSwgKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gJiAoMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyB8IDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJEZXB0aCA9IChhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIC0gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gckRlcHRoICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPj0gMCAmJiBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAockRlcHRoIDw8IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSB8IDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovIHwgdGVybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZXhwbG9yZShhY3Rpb24sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwbG9yZSh0aGlzLnN0YXRlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgc3RhdGUpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgICovXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgKi9cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtMyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnBvcywgdGhpcy5wb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2tBaGVhZCA+IDApXG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICB9XG59XG5jbGFzcyBTdGFja0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHJhY2tlci5zdHJpY3QgPyB0cmFja2VyLmhhc2goY29udGV4dCkgOiAwO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrID09IHRoaXMuc3RhcnQuc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlIC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhcnQucC5wYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RoaXMuYmFzZSAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2ssIHBvcyA9IHN0YWNrLmJ1ZmZlckJhc2UgKyBzdGFjay5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3Ioc3RhY2ssIHBvcywgcG9zIC0gc3RhY2suYnVmZmVyQmFzZSk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEVuY29kZS5CaWdWYWxDb2RlICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSA2NTUzNSAvKiBFbmNvZGUuQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogRW5jb2RlLkdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogRW5jb2RlLkdhcDEgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gbmV4dCAtIDMyIC8qIEVuY29kZS5TdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBFbmNvZGUuQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEVuY29kZS5CYXNlICovO1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgKz0gZGlnaXQ7XG4gICAgICAgICAgICBpZiAoc3RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhbHVlICo9IDQ2IC8qIEVuY29kZS5CYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vKipcbltUb2tlbml6ZXJzXSgjbHIuRXh0ZXJuYWxUb2tlbml6ZXIpIGludGVyYWN0IHdpdGggdGhlIGlucHV0XG50aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2ZcbmNoYXJhY3RlcnMsIHRyYWNraW5nIGxvb2thaGVhZCBhbmQgaGlkaW5nIHRoZSBjb21wbGV4aXR5IG9mXG5bcmFuZ2VzXSgjY29tbW9uLlBhcnNlci5wYXJzZV5yYW5nZXMpIGZyb20gdG9rZW5pemVyIGNvZGUuXG4qL1xuY2xhc3MgSW5wdXRTdHJlYW0ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnB1dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIEJhY2t1cCBjaHVua1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rMiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY2h1bmsyUG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjaGFyYWN0ZXIgY29kZSBvZiB0aGUgbmV4dCBjb2RlIHVuaXQgaW4gdGhlIGlucHV0LCBvciAtMVxuICAgICAgICB3aGVuIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLmVuZCA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2xpcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnJhbmdlLmZyb20gJiYgcG9zIDwgdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHJhbmdlLnRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwb3MsIHJhbmdlLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgYXQgYSBjb2RlIHVuaXQgbmVhciB0aGUgc3RyZWFtIHBvc2l0aW9uLiBgLnBlZWsoMClgIGVxdWFsc1xuICAgIGAubmV4dGAsIGAucGVlaygtMSlgIGdpdmVzIHlvdSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLCBhbmQgc29cbiAgICBvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgbG9va2luZyBhcm91bmQgZHVyaW5nIHRva2VuaXppbmcgY3JlYXRlcyBkZXBlbmRlbmNpZXNcbiAgICBvbiBwb3RlbnRpYWxseSBmYXItYXdheSBjb250ZW50LCB3aGljaCBtYXkgcmVkdWNlIHRoZVxuICAgIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIGNhdXNlIGludmFsaWQgcmVwYXJzZXMgd2hlbiBsb29raW5nIGJhY2t3YXJkIG1vcmUgdGhhbiAyNSBjb2RlXG4gICAgdW5pdHMsIHNpbmNlIHRoZSBsaWJyYXJ5IGRvZXMgbm90IHRyYWNrIGxvb2tiZWhpbmQuXG4gICAgKi9cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBBY2NlcHQgYSB0b2tlbi4gQnkgZGVmYXVsdCwgdGhlIGVuZCBvZiB0aGUgdG9rZW4gaXMgc2V0IHRvIHRoZVxuICAgIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uLCBidXQgeW91IGNhbiBwYXNzIGFuIG9mZnNldCAocmVsYXRpdmUgdG9cbiAgICB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICAqL1xuICAgIGFjY2VwdFRva2VuKHRva2VuLCBlbmRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBlbmQgPSBlbmRPZmZzZXQgPyB0aGlzLnJlc29sdmVPZmZzZXQoZW5kT2Zmc2V0LCAtMSkgOiB0aGlzLnBvcztcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsIHx8IGVuZCA8IHRoaXMudG9rZW4uc3RhcnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRva2VuIGVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBBY2NlcHQgYSB0b2tlbiBlbmRpbmcgYXQgYSBzcGVjaWZpYyBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGFjY2VwdFRva2VuVG8odG9rZW4sIGVuZFBvcykge1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kUG9zO1xuICAgIH1cbiAgICBnZXRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGNodW5rLCBjaHVua1BvcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMjtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLmNodW5rMlBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IGNodW5rUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIGxldCBuZXh0Q2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMucG9zKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyArIG5leHRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gZW5kID4gdGhpcy5yYW5nZS50byA/IG5leHRDaHVuay5zbGljZSgwLCB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3MpIDogbmV4dENodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmdldENodW5rKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua09mZiA9PSB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdCh0aGlzLmNodW5rT2ZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgc3RyZWFtIGZvcndhcmQgTiAoZGVmYXVsdHMgdG8gMSkgY29kZSB1bml0cy4gUmV0dXJuc1xuICAgIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgICovXG4gICAgYWR2YW5jZShuID0gMSkge1xuICAgICAgICB0aGlzLmNodW5rT2ZmICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyArIG4gPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgIG4gLT0gdGhpcy5yYW5nZS50byAtIHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5yYW5nZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICBzZXREb25lKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleCA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmtQb3MgJiYgdG8gPD0gdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmtQb3MsIHRvIC0gdGhpcy5jaHVua1Bvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmsyUG9zICYmIHRvIDw9IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsyLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rMlBvcywgdG8gLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMucmFuZ2UuZnJvbSAmJiB0byA8PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQucmVhZChmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmlucHV0LnJlYWQoTWF0aC5tYXgoci5mcm9tLCBmcm9tKSwgTWF0aC5taW4oci50bywgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIHRoaXMuaWQsIHBhcnNlci5kYXRhLCBwYXJzZXIudG9rZW5QcmVjVGFibGUpO1xuICAgIH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5AaGlkZVxuKi9cbmNsYXNzIExvY2FsVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcHJlY1RhYmxlLCBlbHNlVG9rZW4pIHtcbiAgICAgICAgdGhpcy5wcmVjVGFibGUgPSBwcmVjVGFibGU7XG4gICAgICAgIHRoaXMuZWxzZVRva2VuID0gZWxzZVRva2VuO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiID8gZGVjb2RlQXJyYXkoZGF0YSkgOiBkYXRhO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gaW5wdXQucG9zLCBza2lwcGVkID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0RW9mID0gaW5wdXQubmV4dCA8IDAsIG5leHRQb3MgPSBpbnB1dC5yZXNvbHZlT2Zmc2V0KDEsIDEpO1xuICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCAwLCB0aGlzLmRhdGEsIHRoaXMucHJlY1RhYmxlKTtcbiAgICAgICAgICAgIGlmIChpbnB1dC50b2tlbi52YWx1ZSA+IC0xKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxzZVRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFhdEVvZilcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaW5wdXQucmVzZXQobmV4dFBvcywgaW5wdXQudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChzdGFydCwgaW5wdXQudG9rZW4pO1xuICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGhpcy5lbHNlVG9rZW4sIHNraXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuTG9jYWxUb2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8qKlxuYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiovXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtLCBzY2FucyBmb3IgdGhlIHR5cGVzIG9mIHRva2VucyBpdFxuICAgIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICBbYGFjY2VwdFRva2VuYF0oI2xyLklucHV0U3RyZWFtLmFjY2VwdFRva2VuKSB3aGVuIGl0IGZpbmRzXG4gICAgb25lLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgaW5wdXQudG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCBzdGFjaywgZ3JvdXAsIHByZWNUYWJsZSwgcHJlY09mZnNldCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgZGlhbGVjdCB9ID0gc3RhY2sucC5wYXJzZXI7XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0LnRva2VuLnZhbHVlID09IC0xIHx8IGlucHV0LnRva2VuLnZhbHVlID09IHRlcm0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyh0ZXJtLCBpbnB1dC50b2tlbi52YWx1ZSwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIEVPRlxuICAgICAgICBpZiAoaW5wdXQubmV4dCA8IDAgJiYgaGlnaCA+IGxvdyAmJiBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gM10gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gMV07XG4gICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKDsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXSB8fCAweDEwMDAwO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVzKHRva2VuLCBwcmV2LCB0YWJsZURhdGEsIHRhYmxlT2Zmc2V0KSB7XG4gICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCBwcmV2KTtcbiAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgdG9rZW4pIDwgaVByZXY7XG59XG5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpO1xuICAgIGN1cnNvci5tb3ZlVG8ocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDwgcG9zIDogY3Vyc29yLmZyb20gPiBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihjdXJzb3IudG8gLSAxLCBwb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBQYXJzZVN0YXRlLlRva2VuaXplck1hc2sgKi8pO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN0YWNrLmN1ckNvbnRleHQgPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICBsZXQgbG9va0FoZWFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmxvb2tBaGVhZCA+IHRva2VuLmVuZCArIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogVGVybS5FcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGFjdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHRlbmRlZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4uZXh0ZW5kZWQsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi52YWx1ZSwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbml6ZXIuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkluZGV4ID4gc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IGFjdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xuICAgICAgICBpZiAobG9va0FoZWFkKVxuICAgICAgICAgICAgc3RhY2suc2V0TG9va0FoZWFkKGxvb2tBaGVhZCk7XG4gICAgICAgIGlmICghbWFpbiAmJiBzdGFjay5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kKSB7XG4gICAgICAgICAgICBtYWluID0gbmV3IENhY2hlZFRva2VuO1xuICAgICAgICAgICAgbWFpbi52YWx1ZSA9IHN0YWNrLnAucGFyc2VyLmVvZlRlcm07XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gbWFpbi5lbmQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgbWFpbi52YWx1ZSwgbWFpbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG1haW47XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnM7XG4gICAgfVxuICAgIGdldE1haW5Ub2tlbihzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5tYWluVG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluVG9rZW47XG4gICAgICAgIGxldCBtYWluID0gbmV3IENhY2hlZFRva2VuLCB7IHBvcywgcCB9ID0gc3RhY2s7XG4gICAgICAgIG1haW4uc3RhcnQgPSBwb3M7XG4gICAgICAgIG1haW4uZW5kID0gTWF0aC5taW4ocG9zICsgMSwgcC5zdHJlYW0uZW5kKTtcbiAgICAgICAgbWFpbi52YWx1ZSA9IHBvcyA9PSBwLnN0cmVhbS5lbmQgPyBwLnBhcnNlci5lb2ZUZXJtIDogMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgcmV0dXJuIG1haW47XG4gICAgfVxuICAgIHVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YXJ0LCB0b2tlbiksIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0odGhpcy5zdHJlYW0ucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2sucC5wYXJzZXIuZGlhbGVjdC5hbGxvd3MocmVzdWx0ID4+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCAmIDEpID09IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dEFjdGlvbihhY3Rpb24sIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGUgYWN0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2ldID09IGFjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBhZGRBY3Rpb25zKHN0YWNrLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gc3RhY2ssIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDsgLy8g4pmULCDimZUsIOKZliwg4pmXLCDimZgsIOKZmSwg4pmgLCDimaEsIOKZoiwg4pmjLCDimaQsIOKZpSwg4pmmLCDimadcbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IDA7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShpbnB1dCwgcmFuZ2VzKTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy50b3BUZXJtID0gcGFyc2VyLnRvcFsxXTtcbiAgICAgICAgbGV0IHsgZnJvbSB9ID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCBmcm9tKV07XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aCAmJiB0aGlzLnN0cmVhbS5lbmQgLSBmcm9tID4gcGFyc2VyLmJ1ZmZlckxlbmd0aCAqIDRcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgcGFyc2VyLm5vZGVTZXQpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluU3RhY2tQb3M7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMubWluU3RhY2tQb3M7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBob2xkIHN0YWNrcyBiZXlvbmQgYHBvc2AuXG4gICAgICAgIGxldCBuZXdTdGFja3MgPSB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICBsZXQgc3RvcHBlZCwgc3RvcHBlZFRva2VucztcbiAgICAgICAgLy8gSWYgYSBsYXJnZSBhbW91bnQgb2YgcmVkdWN0aW9ucyBoYXBwZW5lZCB3aXRoIHRoZSBzYW1lIHN0YXJ0XG4gICAgICAgIC8vIHBvc2l0aW9uLCBmb3JjZSB0aGUgc3RhY2sgb3V0IG9mIHRoYXQgcHJvZHVjdGlvbiBpbiBvcmRlciB0b1xuICAgICAgICAvLyBhdm9pZCBjcmVhdGluZyBhIHRyZWUgdG9vIGRlZXAgdG8gcmVjdXJzZSB0aHJvdWdoLlxuICAgICAgICAvLyAoVGhpcyBpcyBhbiB1Z2x5IGtsdWRnZSwgYmVjYXVzZSB1bmZvcnR1bmF0ZWx5IHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHN0cmFpZ2h0Zm9yd2FyZCwgY2hlYXAgd2F5IHRvIGNoZWNrIGZvciB0aGlzIGhhcHBlbmluZywgZHVlIHRvXG4gICAgICAgIC8vIHRoZSBoaXN0b3J5IG9mIHJlZHVjdGlvbnMgb25seSBiZWluZyBhdmFpbGFibGUgaW4gYW5cbiAgICAgICAgLy8gZXhwZW5zaXZlLXRvLWFjY2VzcyBmb3JtYXQgaW4gdGhlIHN0YWNrIGJ1ZmZlcnMuKVxuICAgICAgICBpZiAodGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA+IDMwMCAvKiBSZWMuTWF4TGVmdEFzc29jaWF0aXZlUmVkdWN0aW9uQ291bnQgKi8gJiYgc3RhY2tzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgW3NdID0gc3RhY2tzO1xuICAgICAgICAgICAgd2hpbGUgKHMuZm9yY2VSZWR1Y2UoKSAmJiBzLnN0YWNrLmxlbmd0aCAmJiBzLnN0YWNrW3Muc3RhY2subGVuZ3RoIC0gMl0gPj0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHsgfVxuICAgICAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV07XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5nZXRNYWluVG9rZW4oc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZpbmlzaCB3aXRoIFwiICsgdGhpcy5zdGFja0lEKGZpbmlzaGVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogUmVjLkRpc3RhbmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgc3RvcHBlZCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gdGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdG9wcGVkWzBdLnBvcyA+IHRoaXMuc3RvcHBlZEF0ID8gc3RvcHBlZFswXVxuICAgICAgICAgICAgICAgIDogdGhpcy5ydW5SZWNvdmVyeShzdG9wcGVkLCBzdG9wcGVkVG9rZW5zLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm9yY2UtZmluaXNoIFwiICsgdGhpcy5zdGFja0lEKGZpbmlzaGVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogUmVjLk1heFJlbWFpbmluZ1BlclN0ZXAgKi87XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3Muc29tZShzID0+IHMucmVkdWNlUG9zID4gcG9zKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmctLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gUHJ1bmUgc3RhY2tzIHRoYXQgYXJlIGluIHRoZSBzYW1lIHN0YXRlLCBvciB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gcnVubmluZyB3aXRob3V0IHNwbGl0dGluZyBmb3IgYSB3aGlsZSwgdG8gYXZvaWQgZ2V0dGluZyBzdHVja1xuICAgICAgICAgICAgLy8gd2l0aCBtdWx0aXBsZSBzdWNjZXNzZnVsIHN0YWNrcyBydW5uaW5nIGVuZGxlc3NseSBvbi5cbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXdTdGFja3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbmV3U3RhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLnNhbWVTdGF0ZShvdGhlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogUmVjLk1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogUmVjLk1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8sIG5ld1N0YWNrcy5sZW5ndGggLSAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDg0MDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gNjAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBtYWluID8gbWFpbi5zdGFydCA6IGxvY2FsU3RhY2sucG9zLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBSZWMuRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLyoqXG5Db250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbmluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbmdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbmdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuXG5Db250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxub24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG5cblRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbnR5cGUuXG4qL1xuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8qKlxuICAgIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG5Ib2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG5jb250ZW50IHdpdGguXG4qL1xuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxNCAvKiBGaWxlLlZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTQgLyogRmlsZS5WZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBOb2RlUHJvcFtwcm9wXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wU291cmNlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uc3BlYy5wcm9wU291cmNlcyk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplclNwZWNzID0gc3BlYy5zcGVjaWFsaXplZCB8fCBbXTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gdGhpcy5zcGVjaWFsaXplclNwZWNzW2ldLnRlcm07XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcChnZXRTcGVjaWFsaXplcik7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBUZXJtLkVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBQYXJzZVN0YXRlLlNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogUGFyc2VTdGF0ZS5GbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFsbEFjdGlvbnMoc3RhdGUsIGEgPT4gYSA9PSBhY3Rpb24gPyB0cnVlIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWxsQWN0aW9ucyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZWZsdCA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBkZWZsdCA/IGFjdGlvbihkZWZsdCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOyByZXN1bHQgPT0gbnVsbDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYWN0aW9uKHBhaXIodGhpcy5kYXRhLCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3BlY2lhbGl6ZXJzKSB7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyU3BlY3MgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnNwZWNpYWxpemVycy5maW5kKHIgPT4gci5mcm9tID09IHMuZXh0ZXJuYWwpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzKSwgeyBleHRlcm5hbDogZm91bmQudG8gfSk7XG4gICAgICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnNbaV0gPSBnZXRTcGVjaWFsaXplcihzcGVjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBwYXJzZXIuXG4gICAgKi9cbiAgICBoYXNXcmFwcGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICBzdG9yZWQuXG4gICAgKi9cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgdHlwZXMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yLiBOb3QgYXZhaWxhYmxlIHRvXG4gICAgdXNlciBjb2RlLiBAaGlkZVxuICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldFNwZWNpYWxpemVyKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5leHRlcm5hbCkge1xuICAgICAgICBsZXQgbWFzayA9IHNwZWMuZXh0ZW5kID8gMSAvKiBTcGVjaWFsaXplLkV4dGVuZCAqLyA6IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovO1xuICAgICAgICByZXR1cm4gKHZhbHVlLCBzdGFjaykgPT4gKHNwZWMuZXh0ZXJuYWwodmFsdWUsIHN0YWNrKSA8PCAxKSB8IG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBzcGVjLmdldDtcbn1cblxuZXhwb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBJbnB1dFN0cmVhbSwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCwgU3RhY2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/python/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/python/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst printKeyword = 1,\n  indent = 194,\n  dedent = 195,\n  newline$1 = 196,\n  blankLineStart = 197,\n  newlineBracketed = 198,\n  eof = 199,\n  stringContent = 200,\n  Escape = 2,\n  replacementStart = 3,\n  stringEnd = 201,\n  ParenL = 24,\n  ParenthesizedExpression = 25,\n  TupleExpression = 49,\n  ComprehensionExpression = 50,\n  BracketL = 55,\n  ArrayExpression = 56,\n  ArrayComprehensionExpression = 57,\n  BraceL = 59,\n  DictionaryExpression = 60,\n  DictionaryComprehensionExpression = 61,\n  SetExpression = 62,\n  SetComprehensionExpression = 63,\n  ArgList = 65,\n  subscript = 238,\n  String$1 = 71,\n  stringStart = 241,\n  stringStartD = 242,\n  stringStartL = 243,\n  stringStartLD = 244,\n  stringStartR = 245,\n  stringStartRD = 246,\n  stringStartRL = 247,\n  stringStartRLD = 248,\n  FormatString = 72,\n  stringStartF = 249,\n  stringStartFD = 250,\n  stringStartFL = 251,\n  stringStartFLD = 252,\n  stringStartFR = 253,\n  stringStartFRD = 254,\n  stringStartFRL = 255,\n  stringStartFRLD = 256,\n  FormatReplacement = 73,\n  nestedFormatReplacement = 77,\n  importList = 263,\n  TypeParamList = 112,\n  ParamList = 130,\n  SequencePattern = 151,\n  MappingPattern = 152,\n  PatternArgList = 155;\n\nconst newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46,\n      braceOpen = 123, braceClose = 125, singleQuote = 39, doubleQuote = 34, backslash = 92,\n      letter_o = 111, letter_x = 120, letter_N = 78, letter_u = 117, letter_U = 85;\n\nconst bracketed = new Set([\n  ParenthesizedExpression, TupleExpression, ComprehensionExpression, importList, ArgList, ParamList,\n  ArrayExpression, ArrayComprehensionExpression, subscript,\n  SetExpression, SetComprehensionExpression, FormatString, FormatReplacement, nestedFormatReplacement,\n  DictionaryExpression, DictionaryComprehensionExpression,\n  SequencePattern, MappingPattern, PatternArgList, TypeParamList\n]);\n\nfunction isLineBreak(ch) {\n  return ch == newline || ch == carriageReturn\n}\n\nfunction isHex(ch) {\n  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n}\n\nconst newlines = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let prev;\n  if (input.next < 0) {\n    input.acceptToken(eof);\n  } else if (stack.context.flags & cx_Bracketed) {\n    if (isLineBreak(input.next)) input.acceptToken(newlineBracketed, 1);\n  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) &&\n             stack.canShift(blankLineStart)) {\n    let spaces = 0;\n    while (input.next == space || input.next == tab) { input.advance(); spaces++; }\n    if (input.next == newline || input.next == carriageReturn || input.next == hash)\n      input.acceptToken(blankLineStart, -spaces);\n  } else if (isLineBreak(input.next)) {\n    input.acceptToken(newline$1, 1);\n  }\n}, {contextual: true});\n\nconst indentation = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let context = stack.context;\n  if (context.flags) return\n  let prev = input.peek(-1);\n  if (prev == newline || prev == carriageReturn) {\n    let depth = 0, chars = 0;\n    for (;;) {\n      if (input.next == space) depth++;\n      else if (input.next == tab) depth += 8 - (depth % 8);\n      else break\n      input.advance();\n      chars++;\n    }\n    if (depth != context.indent &&\n        input.next != newline && input.next != carriageReturn && input.next != hash) {\n      if (depth < context.indent) input.acceptToken(dedent, -chars);\n      else input.acceptToken(indent);\n    }\n  }\n});\n\n// Flags used in Context objects\nconst cx_Bracketed = 1, cx_String = 2, cx_DoubleQuote = 4, cx_Long = 8, cx_Raw = 16, cx_Format = 32;\n\nfunction Context(parent, indent, flags) {\n  this.parent = parent;\n  this.indent = indent;\n  this.flags = flags;\n  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent + (indent << 4) + flags + (flags << 6);\n}\n\nconst topIndent = new Context(null, 0, 0);\n\nfunction countIndent(space) {\n  let depth = 0;\n  for (let i = 0; i < space.length; i++)\n    depth += space.charCodeAt(i) == tab ? 8 - (depth % 8) : 1;\n  return depth\n}\n\nconst stringFlags = new Map([\n  [stringStart, 0],\n  [stringStartD, cx_DoubleQuote],\n  [stringStartL, cx_Long],\n  [stringStartLD, cx_Long | cx_DoubleQuote],\n  [stringStartR, cx_Raw],\n  [stringStartRD, cx_Raw | cx_DoubleQuote],\n  [stringStartRL, cx_Raw | cx_Long],\n  [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote],\n  [stringStartF, cx_Format],\n  [stringStartFD, cx_Format | cx_DoubleQuote],\n  [stringStartFL, cx_Format | cx_Long],\n  [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote],\n  [stringStartFR, cx_Format | cx_Raw],\n  [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote],\n  [stringStartFRL, cx_Format | cx_Raw | cx_Long],\n  [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]\n].map(([term, flags]) => [term, flags | cx_String]));\n\nconst trackIndent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: topIndent,\n  reduce(context, term, _, input) {\n    if ((context.flags & cx_Bracketed) && bracketed.has(term) ||\n        (term == String$1 || term == FormatString) && (context.flags & cx_String))\n      return context.parent\n    return context\n  },\n  shift(context, term, stack, input) {\n    if (term == indent)\n      return new Context(context, countIndent(input.read(input.pos, stack.pos)), 0)\n    if (term == dedent)\n      return context.parent\n    if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart)\n      return new Context(context, 0, cx_Bracketed)\n    if (stringFlags.has(term))\n      return new Context(context, 0, stringFlags.get(term) | (context.flags & cx_Bracketed))\n    return context\n  },\n  hash(context) { return context.hash }\n});\n\nconst legacyPrint = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  for (let i = 0; i < 5; i++) {\n    if (input.next != \"print\".charCodeAt(i)) return\n    input.advance();\n  }\n  if (/\\w/.test(String.fromCharCode(input.next))) return\n  for (let off = 0;; off++) {\n    let next = input.peek(off);\n    if (next == space || next == tab) continue\n    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)\n      input.acceptToken(printKeyword);\n    return\n  }\n});\n\nconst strings = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {flags} = stack.context;\n  let quote = (flags & cx_DoubleQuote) ? doubleQuote : singleQuote;\n  let long = (flags & cx_Long) > 0;\n  let escapes = !(flags & cx_Raw);\n  let format = (flags & cx_Format) > 0;\n\n  let start = input.pos;\n  for (;;) {\n    if (input.next < 0) {\n      break\n    } else if (format && input.next == braceOpen) {\n      if (input.peek(1) == braceOpen) {\n        input.advance(2);\n      } else {\n        if (input.pos == start) {\n          input.acceptToken(replacementStart, 1);\n          return\n        }\n        break\n      }\n    } else if (escapes && input.next == backslash) {\n      if (input.pos == start) {\n        input.advance();\n        let escaped = input.next;\n        if (escaped >= 0) {\n          input.advance();\n          skipEscape(input, escaped);\n        }\n        input.acceptToken(Escape);\n        return\n      }\n      break\n    } else if (input.next == backslash && !escapes && input.peek(1) > -1) {\n      // Raw strings still ignore escaped quotes, weirdly.\n      input.advance(2);\n    } else if (input.next == quote && (!long || input.peek(1) == quote && input.peek(2) == quote)) {\n      if (input.pos == start) {\n        input.acceptToken(stringEnd, long ? 3 : 1);\n        return\n      }\n      break\n    } else if (input.next == newline) {\n      if (long) {\n        input.advance();\n      } else if (input.pos == start) {\n        input.acceptToken(stringEnd);\n        return\n      }\n      break\n    } else {\n      input.advance();\n    }\n  }\n  if (input.pos > start) input.acceptToken(stringContent);\n});\n\nfunction skipEscape(input, ch) {\n  if (ch == letter_o) {\n    for (let i = 0; i < 2 && input.next >= 48 && input.next <= 55; i++) input.advance();\n  } else if (ch == letter_x) {\n    for (let i = 0; i < 2 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_u) {\n    for (let i = 0; i < 4 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_U) {\n    for (let i = 0; i < 8 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_N) {\n    if (input.next == braceOpen) {\n      input.advance();\n      while (input.next >= 0 && input.next != braceClose && input.next != singleQuote &&\n             input.next != doubleQuote && input.next != newline) input.advance();\n      if (input.next == braceClose) input.advance();\n    }\n  }\n}\n\nconst pythonHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"async \\\"*\\\" \\\"**\\\" FormatConversion FormatSpec\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while if elif else try except finally return raise break continue with pass assert await yield match case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in not and or is del\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"from def class global nonlocal lambda\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  import: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with as print\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  Boolean: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  None: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  \"FunctionDefinition/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDefinition/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  FormatString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  \"ArithOp!\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  AssignOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Ellipsis: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  At: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,await:44, or:54, and:56, in:60, not:62, is:64, if:70, else:72, lambda:76, yield:94, from:96, async:102, for:104, None:162, True:164, False:164, del:178, pass:182, break:186, continue:190, return:194, raise:202, import:206, as:208, global:212, nonlocal:214, assert:218, type:223, elif:236, while:240, try:246, except:248, finally:250, with:254, def:258, class:268, match:279, case:285};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j\",\n  stateData: \"$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~\",\n  goto: \"!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t\",\n  nodeNames: \"âš  print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard\",\n  maxTerm: 277,\n  context: trackIndent,\n  nodeProps: [\n    [\"isolate\", -5,4,71,72,73,77,\"\"],\n    [\"group\", -15,6,85,87,88,90,92,94,96,98,99,100,102,105,108,110,\"Statement Statement\",-22,8,18,21,25,40,49,50,56,57,60,61,62,63,64,67,70,71,72,79,80,81,82,\"Expression\",-10,114,116,119,121,122,126,128,133,135,138,\"Statement\",-9,143,144,147,148,150,151,152,153,154,\"Pattern\"],\n    [\"openedBy\", 23,\"(\",54,\"[\",58,\"{\"],\n    [\"closedBy\", 24,\")\",55,\"]\",59,\"}\"]\n  ],\n  propSources: [pythonHighlighting],\n  skippedNodes: [0,4],\n  repeatNodeCount: 34,\n  tokenData: \"!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T\",\n  tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],\n  topRules: {\"Script\":[0,5]},\n  specialized: [{term: 221, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 7668\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL3B5dGhvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RTtBQUNyQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHdEQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsd0JBQXdCLHdEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEdBQUc7QUFDcjlLO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGlCQUFpQix3REFBd0Q7QUFDekU7QUFDQSxDQUFDOztBQUVpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYXJlaWZ5LWNvZGUtd2ViLy4vbm9kZV9tb2R1bGVzL0BsZXplci9weXRob24vZGlzdC9pbmRleC5qcz82NzBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVybmFsVG9rZW5pemVyLCBDb250ZXh0VHJhY2tlciwgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcHJpbnRLZXl3b3JkID0gMSxcbiAgaW5kZW50ID0gMTk0LFxuICBkZWRlbnQgPSAxOTUsXG4gIG5ld2xpbmUkMSA9IDE5NixcbiAgYmxhbmtMaW5lU3RhcnQgPSAxOTcsXG4gIG5ld2xpbmVCcmFja2V0ZWQgPSAxOTgsXG4gIGVvZiA9IDE5OSxcbiAgc3RyaW5nQ29udGVudCA9IDIwMCxcbiAgRXNjYXBlID0gMixcbiAgcmVwbGFjZW1lbnRTdGFydCA9IDMsXG4gIHN0cmluZ0VuZCA9IDIwMSxcbiAgUGFyZW5MID0gMjQsXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gMjUsXG4gIFR1cGxlRXhwcmVzc2lvbiA9IDQ5LFxuICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDUwLFxuICBCcmFja2V0TCA9IDU1LFxuICBBcnJheUV4cHJlc3Npb24gPSA1NixcbiAgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU3LFxuICBCcmFjZUwgPSA1OSxcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24gPSA2MCxcbiAgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNjEsXG4gIFNldEV4cHJlc3Npb24gPSA2MixcbiAgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MyxcbiAgQXJnTGlzdCA9IDY1LFxuICBzdWJzY3JpcHQgPSAyMzgsXG4gIFN0cmluZyQxID0gNzEsXG4gIHN0cmluZ1N0YXJ0ID0gMjQxLFxuICBzdHJpbmdTdGFydEQgPSAyNDIsXG4gIHN0cmluZ1N0YXJ0TCA9IDI0MyxcbiAgc3RyaW5nU3RhcnRMRCA9IDI0NCxcbiAgc3RyaW5nU3RhcnRSID0gMjQ1LFxuICBzdHJpbmdTdGFydFJEID0gMjQ2LFxuICBzdHJpbmdTdGFydFJMID0gMjQ3LFxuICBzdHJpbmdTdGFydFJMRCA9IDI0OCxcbiAgRm9ybWF0U3RyaW5nID0gNzIsXG4gIHN0cmluZ1N0YXJ0RiA9IDI0OSxcbiAgc3RyaW5nU3RhcnRGRCA9IDI1MCxcbiAgc3RyaW5nU3RhcnRGTCA9IDI1MSxcbiAgc3RyaW5nU3RhcnRGTEQgPSAyNTIsXG4gIHN0cmluZ1N0YXJ0RlIgPSAyNTMsXG4gIHN0cmluZ1N0YXJ0RlJEID0gMjU0LFxuICBzdHJpbmdTdGFydEZSTCA9IDI1NSxcbiAgc3RyaW5nU3RhcnRGUkxEID0gMjU2LFxuICBGb3JtYXRSZXBsYWNlbWVudCA9IDczLFxuICBuZXN0ZWRGb3JtYXRSZXBsYWNlbWVudCA9IDc3LFxuICBpbXBvcnRMaXN0ID0gMjYzLFxuICBUeXBlUGFyYW1MaXN0ID0gMTEyLFxuICBQYXJhbUxpc3QgPSAxMzAsXG4gIFNlcXVlbmNlUGF0dGVybiA9IDE1MSxcbiAgTWFwcGluZ1BhdHRlcm4gPSAxNTIsXG4gIFBhdHRlcm5BcmdMaXN0ID0gMTU1O1xuXG5jb25zdCBuZXdsaW5lID0gMTAsIGNhcnJpYWdlUmV0dXJuID0gMTMsIHNwYWNlID0gMzIsIHRhYiA9IDksIGhhc2ggPSAzNSwgcGFyZW5PcGVuID0gNDAsIGRvdCA9IDQ2LFxuICAgICAgYnJhY2VPcGVuID0gMTIzLCBicmFjZUNsb3NlID0gMTI1LCBzaW5nbGVRdW90ZSA9IDM5LCBkb3VibGVRdW90ZSA9IDM0LCBiYWNrc2xhc2ggPSA5MixcbiAgICAgIGxldHRlcl9vID0gMTExLCBsZXR0ZXJfeCA9IDEyMCwgbGV0dGVyX04gPSA3OCwgbGV0dGVyX3UgPSAxMTcsIGxldHRlcl9VID0gODU7XG5cbmNvbnN0IGJyYWNrZXRlZCA9IG5ldyBTZXQoW1xuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiwgVHVwbGVFeHByZXNzaW9uLCBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgaW1wb3J0TGlzdCwgQXJnTGlzdCwgUGFyYW1MaXN0LFxuICBBcnJheUV4cHJlc3Npb24sIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIHN1YnNjcmlwdCxcbiAgU2V0RXhwcmVzc2lvbiwgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIEZvcm1hdFN0cmluZywgRm9ybWF0UmVwbGFjZW1lbnQsIG5lc3RlZEZvcm1hdFJlcGxhY2VtZW50LFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiwgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uLFxuICBTZXF1ZW5jZVBhdHRlcm4sIE1hcHBpbmdQYXR0ZXJuLCBQYXR0ZXJuQXJnTGlzdCwgVHlwZVBhcmFtTGlzdFxuXSk7XG5cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGNoKSB7XG4gIHJldHVybiBjaCA9PSBuZXdsaW5lIHx8IGNoID09IGNhcnJpYWdlUmV0dXJuXG59XG5cbmZ1bmN0aW9uIGlzSGV4KGNoKSB7XG4gIHJldHVybiBjaCA+PSA0OCAmJiBjaCA8PSA1NyB8fCBjaCA+PSA2NSAmJiBjaCA8PSA3MCB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMDJcbn1cblxuY29uc3QgbmV3bGluZXMgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQgcHJldjtcbiAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oZW9mKTtcbiAgfSBlbHNlIGlmIChzdGFjay5jb250ZXh0LmZsYWdzICYgY3hfQnJhY2tldGVkKSB7XG4gICAgaWYgKGlzTGluZUJyZWFrKGlucHV0Lm5leHQpKSBpbnB1dC5hY2NlcHRUb2tlbihuZXdsaW5lQnJhY2tldGVkLCAxKTtcbiAgfSBlbHNlIGlmICgoKHByZXYgPSBpbnB1dC5wZWVrKC0xKSkgPCAwIHx8IGlzTGluZUJyZWFrKHByZXYpKSAmJlxuICAgICAgICAgICAgIHN0YWNrLmNhblNoaWZ0KGJsYW5rTGluZVN0YXJ0KSkge1xuICAgIGxldCBzcGFjZXMgPSAwO1xuICAgIHdoaWxlIChpbnB1dC5uZXh0ID09IHNwYWNlIHx8IGlucHV0Lm5leHQgPT0gdGFiKSB7IGlucHV0LmFkdmFuY2UoKTsgc3BhY2VzKys7IH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBuZXdsaW5lIHx8IGlucHV0Lm5leHQgPT0gY2FycmlhZ2VSZXR1cm4gfHwgaW5wdXQubmV4dCA9PSBoYXNoKVxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oYmxhbmtMaW5lU3RhcnQsIC1zcGFjZXMpO1xuICB9IGVsc2UgaWYgKGlzTGluZUJyZWFrKGlucHV0Lm5leHQpKSB7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obmV3bGluZSQxLCAxKTtcbiAgfVxufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3QgaW5kZW50YXRpb24gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQgY29udGV4dCA9IHN0YWNrLmNvbnRleHQ7XG4gIGlmIChjb250ZXh0LmZsYWdzKSByZXR1cm5cbiAgbGV0IHByZXYgPSBpbnB1dC5wZWVrKC0xKTtcbiAgaWYgKHByZXYgPT0gbmV3bGluZSB8fCBwcmV2ID09IGNhcnJpYWdlUmV0dXJuKSB7XG4gICAgbGV0IGRlcHRoID0gMCwgY2hhcnMgPSAwO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChpbnB1dC5uZXh0ID09IHNwYWNlKSBkZXB0aCsrO1xuICAgICAgZWxzZSBpZiAoaW5wdXQubmV4dCA9PSB0YWIpIGRlcHRoICs9IDggLSAoZGVwdGggJSA4KTtcbiAgICAgIGVsc2UgYnJlYWtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGNoYXJzKys7XG4gICAgfVxuICAgIGlmIChkZXB0aCAhPSBjb250ZXh0LmluZGVudCAmJlxuICAgICAgICBpbnB1dC5uZXh0ICE9IG5ld2xpbmUgJiYgaW5wdXQubmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBpbnB1dC5uZXh0ICE9IGhhc2gpIHtcbiAgICAgIGlmIChkZXB0aCA8IGNvbnRleHQuaW5kZW50KSBpbnB1dC5hY2NlcHRUb2tlbihkZWRlbnQsIC1jaGFycyk7XG4gICAgICBlbHNlIGlucHV0LmFjY2VwdFRva2VuKGluZGVudCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gRmxhZ3MgdXNlZCBpbiBDb250ZXh0IG9iamVjdHNcbmNvbnN0IGN4X0JyYWNrZXRlZCA9IDEsIGN4X1N0cmluZyA9IDIsIGN4X0RvdWJsZVF1b3RlID0gNCwgY3hfTG9uZyA9IDgsIGN4X1JhdyA9IDE2LCBjeF9Gb3JtYXQgPSAzMjtcblxuZnVuY3Rpb24gQ29udGV4dChwYXJlbnQsIGluZGVudCwgZmxhZ3MpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIHRoaXMuaGFzaCA9IChwYXJlbnQgPyBwYXJlbnQuaGFzaCArIHBhcmVudC5oYXNoIDw8IDggOiAwKSArIGluZGVudCArIChpbmRlbnQgPDwgNCkgKyBmbGFncyArIChmbGFncyA8PCA2KTtcbn1cblxuY29uc3QgdG9wSW5kZW50ID0gbmV3IENvbnRleHQobnVsbCwgMCwgMCk7XG5cbmZ1bmN0aW9uIGNvdW50SW5kZW50KHNwYWNlKSB7XG4gIGxldCBkZXB0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspXG4gICAgZGVwdGggKz0gc3BhY2UuY2hhckNvZGVBdChpKSA9PSB0YWIgPyA4IC0gKGRlcHRoICUgOCkgOiAxO1xuICByZXR1cm4gZGVwdGhcbn1cblxuY29uc3Qgc3RyaW5nRmxhZ3MgPSBuZXcgTWFwKFtcbiAgW3N0cmluZ1N0YXJ0LCAwXSxcbiAgW3N0cmluZ1N0YXJ0RCwgY3hfRG91YmxlUXVvdGVdLFxuICBbc3RyaW5nU3RhcnRMLCBjeF9Mb25nXSxcbiAgW3N0cmluZ1N0YXJ0TEQsIGN4X0xvbmcgfCBjeF9Eb3VibGVRdW90ZV0sXG4gIFtzdHJpbmdTdGFydFIsIGN4X1Jhd10sXG4gIFtzdHJpbmdTdGFydFJELCBjeF9SYXcgfCBjeF9Eb3VibGVRdW90ZV0sXG4gIFtzdHJpbmdTdGFydFJMLCBjeF9SYXcgfCBjeF9Mb25nXSxcbiAgW3N0cmluZ1N0YXJ0UkxELCBjeF9SYXcgfCBjeF9Mb25nIHwgY3hfRG91YmxlUXVvdGVdLFxuICBbc3RyaW5nU3RhcnRGLCBjeF9Gb3JtYXRdLFxuICBbc3RyaW5nU3RhcnRGRCwgY3hfRm9ybWF0IHwgY3hfRG91YmxlUXVvdGVdLFxuICBbc3RyaW5nU3RhcnRGTCwgY3hfRm9ybWF0IHwgY3hfTG9uZ10sXG4gIFtzdHJpbmdTdGFydEZMRCwgY3hfRm9ybWF0IHwgY3hfTG9uZyB8IGN4X0RvdWJsZVF1b3RlXSxcbiAgW3N0cmluZ1N0YXJ0RlIsIGN4X0Zvcm1hdCB8IGN4X1Jhd10sXG4gIFtzdHJpbmdTdGFydEZSRCwgY3hfRm9ybWF0IHwgY3hfUmF3IHwgY3hfRG91YmxlUXVvdGVdLFxuICBbc3RyaW5nU3RhcnRGUkwsIGN4X0Zvcm1hdCB8IGN4X1JhdyB8IGN4X0xvbmddLFxuICBbc3RyaW5nU3RhcnRGUkxELCBjeF9Gb3JtYXQgfCBjeF9SYXcgfCBjeF9Mb25nIHwgY3hfRG91YmxlUXVvdGVdXG5dLm1hcCgoW3Rlcm0sIGZsYWdzXSkgPT4gW3Rlcm0sIGZsYWdzIHwgY3hfU3RyaW5nXSkpO1xuXG5jb25zdCB0cmFja0luZGVudCA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiB0b3BJbmRlbnQsXG4gIHJlZHVjZShjb250ZXh0LCB0ZXJtLCBfLCBpbnB1dCkge1xuICAgIGlmICgoY29udGV4dC5mbGFncyAmIGN4X0JyYWNrZXRlZCkgJiYgYnJhY2tldGVkLmhhcyh0ZXJtKSB8fFxuICAgICAgICAodGVybSA9PSBTdHJpbmckMSB8fCB0ZXJtID09IEZvcm1hdFN0cmluZykgJiYgKGNvbnRleHQuZmxhZ3MgJiBjeF9TdHJpbmcpKVxuICAgICAgcmV0dXJuIGNvbnRleHQucGFyZW50XG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSwgc3RhY2ssIGlucHV0KSB7XG4gICAgaWYgKHRlcm0gPT0gaW5kZW50KVxuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGNvbnRleHQsIGNvdW50SW5kZW50KGlucHV0LnJlYWQoaW5wdXQucG9zLCBzdGFjay5wb3MpKSwgMClcbiAgICBpZiAodGVybSA9PSBkZWRlbnQpXG4gICAgICByZXR1cm4gY29udGV4dC5wYXJlbnRcbiAgICBpZiAodGVybSA9PSBQYXJlbkwgfHwgdGVybSA9PSBCcmFja2V0TCB8fCB0ZXJtID09IEJyYWNlTCB8fCB0ZXJtID09IHJlcGxhY2VtZW50U3RhcnQpXG4gICAgICByZXR1cm4gbmV3IENvbnRleHQoY29udGV4dCwgMCwgY3hfQnJhY2tldGVkKVxuICAgIGlmIChzdHJpbmdGbGFncy5oYXModGVybSkpXG4gICAgICByZXR1cm4gbmV3IENvbnRleHQoY29udGV4dCwgMCwgc3RyaW5nRmxhZ3MuZ2V0KHRlcm0pIHwgKGNvbnRleHQuZmxhZ3MgJiBjeF9CcmFja2V0ZWQpKVxuICAgIHJldHVybiBjb250ZXh0XG4gIH0sXG4gIGhhc2goY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5oYXNoIH1cbn0pO1xuXG5jb25zdCBsZWdhY3lQcmludCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgIT0gXCJwcmludFwiLmNoYXJDb2RlQXQoaSkpIHJldHVyblxuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgfVxuICBpZiAoL1xcdy8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0Lm5leHQpKSkgcmV0dXJuXG4gIGZvciAobGV0IG9mZiA9IDA7OyBvZmYrKykge1xuICAgIGxldCBuZXh0ID0gaW5wdXQucGVlayhvZmYpO1xuICAgIGlmIChuZXh0ID09IHNwYWNlIHx8IG5leHQgPT0gdGFiKSBjb250aW51ZVxuICAgIGlmIChuZXh0ICE9IHBhcmVuT3BlbiAmJiBuZXh0ICE9IGRvdCAmJiBuZXh0ICE9IG5ld2xpbmUgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihwcmludEtleXdvcmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuY29uc3Qgc3RyaW5ncyA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7ZmxhZ3N9ID0gc3RhY2suY29udGV4dDtcbiAgbGV0IHF1b3RlID0gKGZsYWdzICYgY3hfRG91YmxlUXVvdGUpID8gZG91YmxlUXVvdGUgOiBzaW5nbGVRdW90ZTtcbiAgbGV0IGxvbmcgPSAoZmxhZ3MgJiBjeF9Mb25nKSA+IDA7XG4gIGxldCBlc2NhcGVzID0gIShmbGFncyAmIGN4X1Jhdyk7XG4gIGxldCBmb3JtYXQgPSAoZmxhZ3MgJiBjeF9Gb3JtYXQpID4gMDtcblxuICBsZXQgc3RhcnQgPSBpbnB1dC5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChmb3JtYXQgJiYgaW5wdXQubmV4dCA9PSBicmFjZU9wZW4pIHtcbiAgICAgIGlmIChpbnB1dC5wZWVrKDEpID09IGJyYWNlT3Blbikge1xuICAgICAgICBpbnB1dC5hZHZhbmNlKDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlucHV0LnBvcyA9PSBzdGFydCkge1xuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHJlcGxhY2VtZW50U3RhcnQsIDEpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlc2NhcGVzICYmIGlucHV0Lm5leHQgPT0gYmFja3NsYXNoKSB7XG4gICAgICBpZiAoaW5wdXQucG9zID09IHN0YXJ0KSB7XG4gICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBpbnB1dC5uZXh0O1xuICAgICAgICBpZiAoZXNjYXBlZCA+PSAwKSB7XG4gICAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICAgIHNraXBFc2NhcGUoaW5wdXQsIGVzY2FwZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmFjY2VwdFRva2VuKEVzY2FwZSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gYmFja3NsYXNoICYmICFlc2NhcGVzICYmIGlucHV0LnBlZWsoMSkgPiAtMSkge1xuICAgICAgLy8gUmF3IHN0cmluZ3Mgc3RpbGwgaWdub3JlIGVzY2FwZWQgcXVvdGVzLCB3ZWlyZGx5LlxuICAgICAgaW5wdXQuYWR2YW5jZSgyKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gcXVvdGUgJiYgKCFsb25nIHx8IGlucHV0LnBlZWsoMSkgPT0gcXVvdGUgJiYgaW5wdXQucGVlaygyKSA9PSBxdW90ZSkpIHtcbiAgICAgIGlmIChpbnB1dC5wb3MgPT0gc3RhcnQpIHtcbiAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oc3RyaW5nRW5kLCBsb25nID8gMyA6IDEpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChpbnB1dC5uZXh0ID09IG5ld2xpbmUpIHtcbiAgICAgIGlmIChsb25nKSB7XG4gICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQucG9zID09IHN0YXJ0KSB7XG4gICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHN0cmluZ0VuZCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQucG9zID4gc3RhcnQpIGlucHV0LmFjY2VwdFRva2VuKHN0cmluZ0NvbnRlbnQpO1xufSk7XG5cbmZ1bmN0aW9uIHNraXBFc2NhcGUoaW5wdXQsIGNoKSB7XG4gIGlmIChjaCA9PSBsZXR0ZXJfbykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBpbnB1dC5uZXh0ID49IDQ4ICYmIGlucHV0Lm5leHQgPD0gNTU7IGkrKykgaW5wdXQuYWR2YW5jZSgpO1xuICB9IGVsc2UgaWYgKGNoID09IGxldHRlcl94KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIGlzSGV4KGlucHV0Lm5leHQpOyBpKyspIGlucHV0LmFkdmFuY2UoKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBsZXR0ZXJfdSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNCAmJiBpc0hleChpbnB1dC5uZXh0KTsgaSsrKSBpbnB1dC5hZHZhbmNlKCk7XG4gIH0gZWxzZSBpZiAoY2ggPT0gbGV0dGVyX1UpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDggJiYgaXNIZXgoaW5wdXQubmV4dCk7IGkrKykgaW5wdXQuYWR2YW5jZSgpO1xuICB9IGVsc2UgaWYgKGNoID09IGxldHRlcl9OKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgPT0gYnJhY2VPcGVuKSB7XG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICB3aGlsZSAoaW5wdXQubmV4dCA+PSAwICYmIGlucHV0Lm5leHQgIT0gYnJhY2VDbG9zZSAmJiBpbnB1dC5uZXh0ICE9IHNpbmdsZVF1b3RlICYmXG4gICAgICAgICAgICAgaW5wdXQubmV4dCAhPSBkb3VibGVRdW90ZSAmJiBpbnB1dC5uZXh0ICE9IG5ld2xpbmUpIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGlmIChpbnB1dC5uZXh0ID09IGJyYWNlQ2xvc2UpIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcHl0aG9uSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgXCJhc3luYyBcXFwiKlxcXCIgXFxcIioqXFxcIiBGb3JtYXRDb252ZXJzaW9uIEZvcm1hdFNwZWNcIjogdGFncy5tb2RpZmllcixcbiAgXCJmb3Igd2hpbGUgaWYgZWxpZiBlbHNlIHRyeSBleGNlcHQgZmluYWxseSByZXR1cm4gcmFpc2UgYnJlYWsgY29udGludWUgd2l0aCBwYXNzIGFzc2VydCBhd2FpdCB5aWVsZCBtYXRjaCBjYXNlXCI6IHRhZ3MuY29udHJvbEtleXdvcmQsXG4gIFwiaW4gbm90IGFuZCBvciBpcyBkZWxcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFwiZnJvbSBkZWYgY2xhc3MgZ2xvYmFsIG5vbmxvY2FsIGxhbWJkYVwiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBpbXBvcnQ6IHRhZ3MubW9kdWxlS2V5d29yZCxcbiAgXCJ3aXRoIGFzIHByaW50XCI6IHRhZ3Mua2V5d29yZCxcbiAgQm9vbGVhbjogdGFncy5ib29sLFxuICBOb25lOiB0YWdzLm51bGwsXG4gIFZhcmlhYmxlTmFtZTogdGFncy52YXJpYWJsZU5hbWUsXG4gIFwiQ2FsbEV4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBcIkZ1bmN0aW9uRGVmaW5pdGlvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpKSxcbiAgXCJDbGFzc0RlZmluaXRpb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLmNsYXNzTmFtZSksXG4gIFByb3BlcnR5TmFtZTogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIFwiQ2FsbEV4cHJlc3Npb24vTWVtYmVyRXhwcmVzc2lvbi9Qcm9wZXJ0eU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIENvbW1lbnQ6IHRhZ3MubGluZUNvbW1lbnQsXG4gIE51bWJlcjogdGFncy5udW1iZXIsXG4gIFN0cmluZzogdGFncy5zdHJpbmcsXG4gIEZvcm1hdFN0cmluZzogdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKSxcbiAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgVXBkYXRlT3A6IHRhZ3MudXBkYXRlT3BlcmF0b3IsXG4gIFwiQXJpdGhPcCFcIjogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIEJpdE9wOiB0YWdzLmJpdHdpc2VPcGVyYXRvcixcbiAgQ29tcGFyZU9wOiB0YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgQXNzaWduT3A6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBFbGxpcHNpczogdGFncy5wdW5jdHVhdGlvbixcbiAgQXQ6IHRhZ3MubWV0YSxcbiAgXCIoIClcIjogdGFncy5wYXJlbixcbiAgXCJbIF1cIjogdGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiB0YWdzLmJyYWNlLFxuICBcIi5cIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiB0YWdzLnNlcGFyYXRvclxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGF3YWl0OjQ0LCBvcjo1NCwgYW5kOjU2LCBpbjo2MCwgbm90OjYyLCBpczo2NCwgaWY6NzAsIGVsc2U6NzIsIGxhbWJkYTo3NiwgeWllbGQ6OTQsIGZyb206OTYsIGFzeW5jOjEwMiwgZm9yOjEwNCwgTm9uZToxNjIsIFRydWU6MTY0LCBGYWxzZToxNjQsIGRlbDoxNzgsIHBhc3M6MTgyLCBicmVhazoxODYsIGNvbnRpbnVlOjE5MCwgcmV0dXJuOjE5NCwgcmFpc2U6MjAyLCBpbXBvcnQ6MjA2LCBhczoyMDgsIGdsb2JhbDoyMTIsIG5vbmxvY2FsOjIxNCwgYXNzZXJ0OjIxOCwgdHlwZToyMjMsIGVsaWY6MjM2LCB3aGlsZToyNDAsIHRyeToyNDYsIGV4Y2VwdDoyNDgsIGZpbmFsbHk6MjUwLCB3aXRoOjI1NCwgZGVmOjI1OCwgY2xhc3M6MjY4LCBtYXRjaDoyNzksIGNhc2U6Mjg1fTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIjI2pPYFFlT09QJH1PU09PTyZXUXRPJyNIVU9PUVMnI0NvJyNDb09PUVMnI0NwJyNDcE8ndlFkTycjQ25PKlVRdE8nI0hUT09RUycjSFUnI0hVT09RUycjRFUnI0RVT09RUycjSFQnI0hUTypyUWRPJyNEX08rVlFkTycjRGZPK2dRZE8nI0RqTyt6T1dPJyNEdU8sVk9XTycjRHZPLltRdE8nI0d1T09RUycjR3UnI0d1Tyd2UWRPJyNHdE8wWlF0TycjR3RPT1FTJyNFYicjRWJPMHJRZE8nI0VjT09RUycjR3MnI0dzTzB8UWRPJyNHck9PUVYnI0dyJyNHck8xWFFkTycjRllPT1FTJyNHXicjR15PMV5RZE8nI0ZYT09RVicjSVMnI0lTT09RVicjR3EnI0dxT09RVicjRnEnI0ZxUWBRZU9PTyd2UWRPJyNDcU8xbFFkTycjQ31PMXNRZE8nI0RSTzJSUWRPJyNIWU8yY1F0TycjRVZPJ3ZRZE8nI0VXT09RUycjRVknI0VZT09RUycjRVsnI0VbT09RUycjRV4nI0VeTzJ3UWRPJyNFYE8zX1FkTycjRWRPM3JRZE8nI0VmTzN6UXRPJyNFZk8xWFFkTycjRWlPMHJRZE8nI0VsTzFYUWRPJyNFbk8wclFkTycjRXRPMHJRZE8nI0V3TzRWUWRPJyNFeU80XlFkTycjRk9PNGlRZE8nI0V6TzByUWRPJyNGT08xWFFkTycjRlFPMVhRZE8nI0ZWTzRuUWRPJyNGW1A0dU9kTycjR3BQT09PKUNCZClDQmRPT1FTJyNDZScjQ2VPT1FTJyNDZicjQ2ZPT1FTJyNDZycjQ2dPT1FTJyNDaCcjQ2hPT1FTJyNDaScjQ2lPT1FTJyNDaicjQ2pPT1FTJyNDbCcjQ2xPJ3ZRZE8sNTlPTyd2UWRPLDU5T08ndlFkTyw1OU9PJ3ZRZE8sNTlPTyd2UWRPLDU5T08ndlFkTyw1OU9PNVRRZE8nI0RvT09RUyw1OlksNTpZTzVoUWRPJyNIZE9PUVMsNTpdLDU6XU81dVEhZk8sNTpdTzV6UXRPLDU5WU8xbFFkTyw1OWJPMWxRZE8sNTliTzFsUWRPLDU5Yk84alFkTyw1OWJPOG9RZE8sNTliTzh2UWRPLDU5ak84fVFkTycjSFRPOlRRZE8nI0hTT09RUycjSFMnI0hTT09RUycjRFsnI0RbTzpsUWRPLDU5YU8ndlFkTyw1OWFPOnpRZE8sNTlhT09RUyw1OXksNTl5TztQUWRPLDU6Uk8ndlFkTyw1OlJPT1FTLDU6USw1OlFPO19RZE8sNTpRTztkUWRPLDU6WE8ndlFkTyw1OlhPJ3ZRZE8sNTpWT09RUyw1OlUsNTpVTzt1UWRPLDU6VU87elFkTyw1OldPT09XJyNGeScjRnlPPFBPV08sNTphT09RUyw1OmEsNTphTzxbUWRPJyNId09PT1cnI0R3JyNEd09PT1cnI0Z6JyNGek88bE9XTyw1OmJPT1FTLDU6Yiw1OmJPT1FTJyNGfScjRn1PPHpRdE8sNTppTz9sUXRPLDU9YE9AVlEjeE8sNT1gT0B2UXRPLDU9YE9PUVMsNTp9LDU6fU9BX1FlTycjR1dPQnFRZE8sNTteT09RViw1PV4sNT1eT0J8UXRPJyNJUE9Da1FkTyw1O3RPT1FTLUU6Wy1FOltPT1FWLDU7cyw1O3NPNGRRZE8nI0ZRT09RVi1FOW8tRTlvT0NzUXRPLDU5XU9FelF0Tyw1OWlPRmVRZE8nI0hWT0ZwUWRPJyNIVk8xWFFkTycjSFZPRntRZE8nI0RUT0dUUWRPLDU5bU9HWVFkTycjSFpPJ3ZRZE8nI0haTzByUWRPLDU9dE9PUVMsNT10LDU9dE8wclFkTycjRVJPT1FTJyNFUycjRVNPR3dRZE8nI0dQT0hYUWRPLDU4fE9IWFFkTyw1OHxPKnhRZE8sNTpvT0hnUXRPJyNIXU9PUVMsNTpyLDU6ck9PUVMsNTp6LDU6ek9IelFkTyw1O09PSV1RZE8nI0lPTzFYUWRPJyNIfU9PUVMsNTtRLDU7UU9PUVMnI0dUJyNHVE9JcVF0Tyw1O1FPSlBRZE8sNTtRT0pVUWRPJyNJUU9PUVMsNTtULDU7VE9KZFFkTycjSHxPT1FTLDU7Vyw1O1dPSnVRZE8sNTtZTzRpUWRPLDU7YE80aVFkTyw1O2NPSn1RdE8nI0lUTyd2UWRPJyNJVE9LWFFkTyw1O2VPNFZRZE8sNTtlTzByUWRPLDU7ak8xWFFkTyw1O2xPS15RZU8nI0V1T0xqUWdPLDU7Zk8hIWtRZE8nI0lVTzRpUWRPLDU7ak8hIXZRZE8sNTtsTyEjT1FkTyw1O3FPISNaUXRPLDU7dk8ndlFkTyw1O3ZQT09PLDU9Wyw1PVtQISNiT1NPLDU9W1AhI2pPZE8sNT1bTyEmYlF0TzFHLmpPISZpUXRPMUcuak8hKVlRdE8xRy5qTyEpZFF0TzFHLmpPISt9UXRPMUcuak8hLGJRdE8xRy5qTyEsdVFkTycjSGNPIS1UUXRPJyNHdU8wclFkTycjSGNPIS1fUWRPJyNIYk9PUVMsNTpaLDU6Wk8hLWdRZE8sNTpaTyEtbFFkTycjSGVPIS13UWRPJyNIZU8hLltRZE8sNT5PT09RUycjRHMnI0RzT09RUzFHL3cxRy93T09RUzFHLnwxRy58TyEvW1F0TzFHLnxPIS9jUXRPMUcufE8xbFFkTzFHLnxPITBPUWRPMUcvVU9PUVMnI0RaJyNEWk8wclFkTyw1OXRPT1FTMUcuezFHLntPITBWUWRPMUcvZU8hMGdRZE8xRy9lTyEwb1FkTzFHL2ZPJ3ZRZE8nI0hbTyEwdFFkTycjSFtPITB5UXRPMUcue08hMVpRZE8sNTlpTyEyYVFkTyw1PXpPITJxUWRPLDU9ek8hMnlRZE8xRy9tTyEzT1F0TzFHL21PT1FTMUcvbDFHL2xPITNgUWRPLDU9dU8hNFZRZE8sNT11TzByUWRPMUcvcU8hNHRRZE8xRy9zTyE0eVF0TzFHL3NPITVaUXRPMUcvcU9PUVMxRy9wMUcvcE9PUVMxRy9yMUcvck9PT1ctRTl3LUU5d09PUVMxRy97MUcve08hNWtRZE8nI0h4TzByUWRPJyNIeE8hNXxRZE8sNT5jT09PVy1FOXgtRTl4T09RUzFHL3wxRy98T09RUy1FOXstRTl7TyE2W1EjeE8xRzJ6TyE2e1F0TzFHMnpPJ3ZRZE8sNTxqT09RUyw1PGosNTxqT09RUy1FOXwtRTl8T09RUyw1PHIsNTxyT09RUy1FOlUtRTpVT09RVjFHMHgxRzB4TzFYUWRPJyNHUk8hN2RRdE8sNT5rT09RUzFHMWAxRzFgTyE4UlFkTzFHMWBPT1FTJyNEVicjRFZPMHJRZE8sNT1xT09RUyw1PXEsNT1xTyE4V1FkTycjRnJPIThjUWRPLDU5b08hOGtRZE8xRy9YTyE4dVF0Tyw1PXVPT1FTMUczYDFHM2BPT1FTLDU6bSw1Om1PITlmUWRPJyNHdE9PUVMsNTxrLDU8a09PUVMtRTl9LUU5fU8hOXdRZE8xRy5oT09RUzFHMFoxRzBaTyE6VlFkTyw1PXdPITpnUWRPLDU9d08wclFkTzFHMGpPMHJRZE8xRzBqTyE6eFFkTyw1PmpPITtaUWRPLDU+ak8xWFFkTyw1PmpPITtsUWRPLDU+aU9PUVMtRTpSLUU6Uk8hO3FRZE8xRzBsTyE7fFFkTzFHMGxPITxSUWRPLDU+bE8hPGFRZE8sNT5sTyE8b1FkTyw1PmhPIT1WUWRPLDU+aE8hPWhRZE8nI0VwTzByUWRPMUcwdE8hPXNRZE8xRzB0TyE9eFFnTzFHMHpPIUF2UWdPMUcwfU8hRXFRZE8sNT5vTyFFe1FkTyw1Pm9PIUZUUXRPLDU+b08wclFkTzFHMVBPIUZfUWRPMUcxUE80aVFkTzFHMVVPISF2UWRPMUcxV09PUVYsNTthLDU7YU8hRmRRZk8sNTthTyFGaVFnTzFHMVFPIUpqUWRPJyNHWk80aVFkTzFHMVFPNGlRZE8xRzFRTyFKelFkTyw1PnBPIUtYUWRPLDU+cE8xWFFkTyw1PnBPT1FWMUcxVTFHMVVPIUthUWRPJyNGU08hS3JRIWZPMUcxV08hS3pRZE8xRzFXT09RVjFHMV0xRzFdTzRpUWRPMUcxXU8hTFBRZE8xRzFdTyFMWFFkTycjRl5PT1FWMUcxYjFHMWJPISNaUXRPMUcxYlBPT08xRzJ2MUcydlAhTF5PU08xRzJ2T09RUyw1PX0sNT19T09RUycjRHAnI0RwTzByUWRPLDU9fU8hTGZRZE8sNT18TyFMeVFkTyw1PXxPT1FTMUcvdTFHL3VPIU1SUWRPLDU+UE8hTWNRZE8sNT5QTyFNa1FkTyw1PlBPIU5PUWRPLDU+UE8hTmBRZE8sNT5QT09RUzFHM2oxRzNqT09RUzcrJGg3KyRoTyE4a1FkTzcrJHBPIyFSUWRPMUcufE8jIVlRZE8xRy58T09RUzFHL2AxRy9gT09RUyw1PGAsNTxgTyd2UWRPLDU8YE9PUVM3KyVQNyslUE8jIWFRZE83KyVQT09RUy1FOXItRTlyT09RUzcrJVE3KyVRTyMhcVFkTyw1PXZPJ3ZRZE8sNT12T09RUzcrJGc3KyRnTyMhdlFkTzcrJVBPIyNPUWRPNyslUU8jI1RRZE8xRzNmT09RUzcrJVg3KyVYTyMjZVFkTzFHM2ZPIyNtUWRPNyslWE9PUVMsNTxfLDU8X08ndlFkTyw1PF9PIyNyUWRPMUczYU9PUVMtRTlxLUU5cU8jJGlRZE83KyVdT09RUzcrJV83KyVfTyMkd1FkTzFHM2FPIyVmUWRPNyslX08jJWtRZE8xRzNnTyMle1FkTzFHM2dPIyZUUWRPNyslXU8jJllRZE8sNT5kTyMmc1FkTyw1PmRPIyZzUWRPLDU+ZE9PUVMnI0R4JyNEeE8jJ1VPJmpPJyNEek8jJ2FPYE8nI0h5T09PVzFHM30xRzN9TyMnZlFkTzFHM31PIyduUWRPMUczfU8jJ3lRI3hPNysoZk8jKGpRdE8xRzJVUCMpVFFkTycjR09PT1FTLDU8bSw1PG1PT1FTLUU6UC1FOlBPT1FTNysmejcrJnpPT1FTMUczXTFHM11PT1FTLDU8Xiw1PF5PT1FTLUU5cC1FOXBPT1FTNyskczcrJHNPIyliUWRPLDU9YE8jKXtRZE8sNT1gTyMqXlF0Tyw1PGFPIypxUWRPMUczY09PUVMtRTlzLUU5c09PUVM3KyZVNysmVU8jK1JRZE83KyZVTyMrYVFkTyw1PG5PIyt1UWRPMUc0VU9PUVMtRTpRLUU6UU8jLFdRZE8xRzRVT09RUzFHNFQxRzRUT09RUzcrJlc3KyZXTyMsaVFkTzcrJldPT1FTLDU8cCw1PHBPIyx0UWRPMUc0V09PUVMtRTpTLUU6U09PUVMsNTxsLDU8bE8jLVNRZE8xRzRTT09RUy1FOk8tRTpPTzFYUWRPJyNFcU8jLWpRZE8nI0VxTyMtdVFkTycjSVJPIy19UWRPLDU7W09PUVM3KyZgNysmYE8wclFkTzcrJmBPIy5TUWdPNysmZk8hSm1RZE8nI0dYTzRpUWRPNysmZk80aVFkTzcrJmlPIzJRUXRPLDU8dE8ndlFkTyw1PHRPIzJbUWRPMUc0Wk9PUVMtRTpXLUU6V08jMmZRZE8xRzRaTzRpUWRPNysma08wclFkTzcrJmtPT1FWNysmcDcrJnBPIUtyUSFmTzcrJnJPIUt6UWRPNysmck9gUWVPMUcwe09PUVYtRTpYLUU6WE80aVFkTzcrJmxPNGlRZE83KyZsT09RViw1PHUsNTx1TyMyblFkTyw1PHVPIUptUWRPLDU8dU9PUVY3KyZsNysmbE8jMnlRZ083KyZsTyM2dFFkTyw1PHZPIzdQUWRPMUc0W09PUVMtRTpZLUU6WU8jN15RZE8xRzRbTyM3ZlFkTycjSVdPIzd0UWRPJyNJV08xWFFkTycjSVdPT1FTJyNJVycjSVdPIzhQUWRPJyNJVk9PUVMsNTtuLDU7bk8jOFhRZE8sNTtuTzByUWRPJyNGVU9PUVY3KyZyNysmck80aVFkTzcrJnJPT1FWNysmdzcrJndPNGlRZE83KyZ3TyM4XlFmTyw1O3hPT1FWNysmfDcrJnxQT09PNysoYjcrKGJPIzhjUWRPMUczaU9PUVMsNTxjLDU8Y08jOHFRZE8xRzNoT09RUy1FOXUtRTl1TyM5VVFkTyw1PGRPIzlhUWRPLDU8ZE8jOXRRZE8xRzNrT09RUy1FOXYtRTl2TyM6VVFkTzFHM2tPIzpeUWRPMUcza08jOm5RZE8xRzNrTyM6VVFkTzFHM2tPT1FTPDxIWzw8SFtPIzp5UXRPMUcxek9PUVM8PEhrPDxIa1AjO1dRZE8nI0Z0Tzh2UWRPMUczYk8jO2VRZE8xRzNiTyM7alFkTzw8SGtPT1FTPDxIbDw8SGxPIzt6UWRPNyspUU9PUVM8PEhzPDxIc08jPFtRdE8xRzF5UCM8e1FkTycjRnNPIz1ZUWRPNyspUk8jPWpRZE83KylSTyM9clFkTzw8SHdPIz13UWRPNysoe09PUVM8PEh5PDxIeU8jPm5RZE8sNTxiTyd2UWRPLDU8Yk9PUVMtRTl0LUU5dE9PUVM8PEh3PDxId09PUVMsNTxnLDU8Z08wclFkTyw1PGdPIz5zUWRPMUc0T09PUVMtRTl5LUU5eU8jP15RZE8xRzRPTzxbUWRPJyNIe09PT08nI0R7JyNEe09PT08nI0Z8JyNGfE8jP29PJmpPLDU6Zk9PT1csNT5lLDU+ZU9PT1c3KylpNyspaU8jP3pRZE83KylpTyNAU1FkTzFHMnpPI0BtUWRPMUcyelAndlFkTycjRnVPMHJRZE88PElwTzFYUWRPMUcyWVAxWFFkTycjR1NPI0FPUWRPNyspcE8jQWFRZE83KylwT09RUzw8SXI8PElyUDFYUWRPJyNHVVAwclFkTycjR1FPT1FTLDU7XSw1O11PI0FyUWRPLDU+bU8jQlFRZE8sNT5tT09RUzFHMHYxRzB2T09RUzw8SXo8PEl6T09RVi1FOlYtRTpWTzRpUWRPPDxKUU9PUVYsNTxzLDU8c080aVFkTyw1PHNPT1FWPDxKUTw8SlFPT1FWPDxKVDw8SlRPI0JZUXRPMUcyYFAjQmRRZE8nI0dZTyNCa1FkTzcrKXVPI0J1UWdPPDxKVk80aVFkTzw8SlZPT1FWPDxKXjw8Sl5PNGlRZE88PEpeTyFLclEhZk88PEpeTyNGcFFnTzcrJmdPT1FWPDxKVzw8SldPI0Z6UWdPPDxKV09PUVYxRzJhMUcyYU8xWFFkTzFHMmFPI0p1UWRPMUcyYU80aVFkTzw8SldPMVhRZE8xRzJiUDByUWRPJyNHW08jS1FRZE83Kyl2TyNLX1FkTzcrKXZPT1FTJyNGVCcjRlRPMHJRZE8sNT5yTyNLZ1FkTyw1PnJPI0tyUWRPLDU+ck8jS31RZE8sNT5xTyNMYFFkTyw1PnFPT1FTMUcxWTFHMVlPT1FTLDU7cCw1O3BPT1FWPDxKYzw8SmNPI0xoUWRPMUcxZE9PUVM3KylUNyspVFAjTG1RZE8nI0Z3TyNMfVFkTzFHMk9PI01iUWRPMUcyT08jTXJRZE8xRzJPUCNNfVFkTycjRnhPI05bUWRPNyspVk8jTmxRZE83KylWTyNObFFkTzcrKVZPI050UWRPNyspVk8kIFVRZE83Kyh8Tzh2UWRPNysofE9PUVNBTj5WQU4+Vk8kIG9RZE88PExtT09RU0FOPmNBTj5jTzByUWRPMUcxfE8kIVBRdE8xRzF8UCQhWlFkTycjRnZPT1FTMUcyUjFHMlJQJCFoUWRPJyNGe08kIXVRZE83KylqTyQjYFFkTyw1PmdPT09PLUU5ei1FOXpPT09XPDxNVDw8TVRPJCNuUWRPNysoZk9PUVNBTj9bQU4/W09PUVM3Kyd0NysndE8kJFhRZE88PE1bT09RUyw1PHEsNTxxTyQkalFkTzFHNFhPT1FTLUU6VC1FOlRPT1FWQU4/bEFOP2xPT1FWMUcyXzFHMl9PNGlRZE9BTj9xTyQkeFFnT0FOP3FPT1FWQU4/eEFOP3hPNGlRZE9BTj94T09RVjw8SlI8PEpSTzRpUWRPQU4/ck80aVFkTzcrJ3tPT1FWNysnezcrJ3tPMVhRZE83Kyd7T09RVkFOP3JBTj9yT09RUzcrJ3w3Kyd8TyQoc1FkTzw8TWJPT1FTMUc0XjFHNF5PMHJRZE8xRzReT09RUyw1PHcsNTx3TyQpUVFkTzFHNF1PT1FTLUU6Wi1FOlpPT1FVJyNHXycjR19PJCljUWZPNysnT08kKW5RZE8nI0ZfTyQqdVFkTzcrJ2pPJCtWUWRPNysnak9PUVM3KydqNysnak8kK2JRZE88PExxTyQrclFkTzw8THFPJCtyUWRPPDxMcU8kK3pRZE8nI0heT09RUzw8TGg8PExoTyQsVVFkTzw8TGhPT1FTNysnaDcrJ2hPT1FTJyNEfCcjRHxPT09PMUc0UjFHNFJPJCxvUWRPMUc0Uk8kLHdRZE8xRzRSUCE9aFFkTycjR1ZPT1FWRzI1XUcyNV1PNGlRZE9HMjVdT09RVkcyNWRHMjVkT09RVkcyNV5HMjVeT09RVjw8S2c8PEtnTzRpUWRPPDxLZ09PUVM3Kyl4NyspeFAkLVNRZE8nI0ddT09RVS1FOl0tRTpdT09RVjw8Smo8PEpqTyQtdlF0TycjRmFPT1FTJyNGYycjRmNPJC5XUWRPJyNGYk8kLnhRZE8nI0ZiT09RUycjRmInI0ZiTyQufVFkTycjSVlPJCluUWRPJyNGaU8kKW5RZE8nI0ZpTyQvZlFkTycjRmpPJCluUWRPJyNGa08kL21RZE8nI0laT09RUycjSVonI0laTyQwW1FkTyw1O3lPT1FTPDxLVTw8S1VPJDBkUWRPPDxLVU8kMHRRZE9BTkJdTyQxVVFkT0FOQl1PJDFeUWRPJyNIX09PUVMnI0hfJyNIX08xc1FkTycjRGNPJDF3UWRPLDU9eE9PUVNBTkJTQU5CU09PT083KyltNyspbU8kMmBRZE83KyltT09RVkxEKndMRCp3T09RVkFOQVJBTkFSTzV1USFmTycjR2FPJDJoUXRPLDU8U08kKW5RZE8nI0ZtT09RUyw1PFcsNTxXT09RUycjRmQnI0ZkTyQzWVFkTyw1O3xPJDNfUWRPLDU7fE9PUVMnI0ZnJyNGZ08kKW5RZE8nI0dgTyQ0UFFkTyw1PFFPJDRrUWRPLDU+dE8kNHtRZE8sNT50TzFYUWRPLDU8UE8kNV5RZE8sNTxUTyQ1Y1FkTyw1PFRPJCluUWRPJyNJW08kNWhRZE8nI0lbTyQ1bVFkTyw1PFVPT1FTLDU8Viw1PFZPMHJRZE8nI0ZwT09RVTFHMWUxRzFlTzRpUWRPMUcxZU9PUVNBTkBwQU5AcE8kNXJRZE9HMjd3TyQ2U1FkTyw1OX1PT1FTMUczZDFHM2RPT09PPDxNWDw8TVhPT1FTLDU8eyw1PHtPT1FTLUU6Xy1FOl9PJDZYUXRPJyNGYU8kNmBRZE8nI0ldTyQ2blFkTycjSV1PJDZ2UWRPLDU8WE9PUVMxRzFoMUcxaE8kNntRZE8xRzFoTyQ3UVFkTyw1PHpPT1FTLUU6Xi1FOl5PJDdsUWRPLDU9T08kOFRRZE8xRzRgT09RUy1FOmItRTpiT09RUzFHMWsxRzFrT09RUzFHMW8xRzFvTyQ4ZVFkTyw1PnZPJCluUWRPLDU+dk9PUVMxRzFwMUcxcE9PUVMsNTxbLDU8W09PUVU3KydQNysnUE8kK3pRZE8xRy9pTyQpblFkTyw1PFlPJDhzUWRPLDU+d08kOHpRZE8sNT53T09RUzFHMXMxRzFzT09RUzcrJ1M3KydTUCQpblFkTycjR2RPJDlTUWRPMUc0Yk8kOV5RZE8xRzRiTyQ5ZlFkTzFHNGJPT1FTNyslVDcrJVRPJDl0UWRPMUcxdE8kOlNRdE8nI0ZhTyQ6WlFkTyw1PH1PT1FTLDU8fSw1PH1PJDppUWRPMUc0Y09PUVMtRTphLUU6YU8kKW5RZE8sNTx8TyQ6cFFkTyw1PHxPJDp1UWRPNyspfE9PUVMtRTpgLUU6YE8kO1BRZE83Kyl8TyQpblFkTyw1PFpQJCluUWRPJyNHY08kO1hRZE8xRzJoTyQpblFkTzFHMmhQJDtnUWRPJyNHYk8kO25RZE88PE1oTyQ7eFFkTzFHMXVPJDxXUWRPNysoU084dlFkTycjQ31POHZRZE8sNTliTzh2UWRPLDU5Yk84dlFkTyw1OWJPJDxmUXRPLDU9YE84dlFkTzFHLnxPMHJRZE8xRy9YTzByUWRPNyskcFAkPHlRZE8nI0dPTyd2UWRPJyNHdE8kPVdRZE8sNTliTyQ9XVFkTyw1OWJPJD1kUWRPLDU5bU8kPWlRZE8xRy9VTzFzUWRPJyNEUk84dlFkTyw1OWpcIixcbiAgc3RhdGVEYXRhOiBcIiQ+U35PJWNPUyVeT1NTT1MlXVBRfk9QZE9WYU9mb09oWU9vcE9zIVBPdnFPIVByTyFRe08hVCFTTyFVIVJPIVhaTyFdW08haGBPIXJgTyFzYE8hdGBPIXt0TyF9dU8jUHZPI1J3TyNUeE8jWHlPI1p6TyNefE8jX3xPI2F9TyNjIU9PI2whUU8jbyFUTyNzIVVPI3UhVk8jeiFXTyN9aE8kUCFYTyVvUk8lcFJPJXRTTyV1V08mWl1PJltdTyZdXU8mXl1PJl9dTyZgXU8mYV1PJmJdTyZjXk8mZF5PJmVeTyZmXk8mZ15PJmheTyZpXk8mal5Pfk8lXSFZT35PViFhT18hYU9hIWJPaCFpTyFYIWtPIWYhbU8laiFbTyVrIV1PJWwhXk8lbSFfTyVuIV9PJW8hYE8lcCFgTyVxIWFPJXIhYU8lcyFhT35PayV4WGwleFhtJXhYbiV4WG8leFhwJXhYcyV4WHoleFh7JXhYIXgleFgjZyV4WCVbJXhYJV8leFgleiV4WGcleFghVCV4WCFVJXhYJXsleFghVyV4WCFbJXhYIVEleFgjWyV4WHQleFghbSV4WH5QJVNPZm9PaFlPIVhaTyFdW08haGBPIXJgTyFzYE8hdGBPJW9STyVwUk8ldFNPJXVXTyZaXU8mW11PJl1dTyZeXU8mX11PJmBdTyZhXU8mYl1PJmNeTyZkXk8mZV5PJmZeTyZnXk8maF5PJmleTyZqXk9+T3old1h7JXdYI2cld1glWyV3WCVfJXdYJXold1h+T2shcE9sIXFPbSFvT24hb09vIXJPcCFzT3MhdE8heCV3WH5QKXBPViF6T2chfE9vMGNPdjBxTyFQck9+UCd2T1YjT09vMGNPdjBxTyFXI1BPflAndk9WI1NPYSNUT28wY092MHFPIVsjVU9+UCd2T1EjWE8lYCNYTyVhI1pPfk9RI15PUiNbTyVgI15PJWEjYE9+T1YlaVhfJWlYYSVpWGglaVhrJWlYbCVpWG0laVhuJWlYbyVpWHAlaVhzJWlYeiVpWCFYJWlYIWYlaVglaiVpWCVrJWlYJWwlaVglbSVpWCVuJWlYJW8laVglcCVpWCVxJWlYJXIlaVglcyVpWGclaVghVCVpWCFVJWlYfk8mWl1PJltdTyZdXU8mXl1PJl9dTyZgXU8mYV1PJmJdTyZjXk8mZF5PJmVeTyZmXk8mZ15PJmheTyZpXk8mal5PeyVpWCF4JWlYI2claVglWyVpWCVfJWlYJXolaVgleyVpWCFXJWlYIVslaVghUSVpWCNbJWlYdCVpWCFtJWlYflAsZU96I2RPeyVoWCF4JWhYI2claFglWyVoWCVfJWhYJXolaFh+T28wY092MHFPflAndk8jZyNnTyVbI2lPJV8jaU9+TyV1V09+TyFUI25PI3UhVk8jeiFXTyN9aE9+T29wT35QJ3ZPViNzT2EjdE8ldVdPe3dQfk9WI3hPbzBjT3YwcU8hUSN5T35QJ3ZPeyN7TyF4JFFPJXojfE8jZyF5WCVbIXlYJV8heVh+T1YjeE9vMGNPdjBxTyNnI1NYJVsjU1glXyNTWH5QJ3ZPbzBjT3YwcU8jZyNXWCVbI1dYJV8jV1h+UCd2T2gkV08ldVdPfk8hZiRZTyFyJFlPJXVXT35PViRlT35QJ3ZPIVUkZ08jcyRoTyN1JGlPfk97JGpPfk9WJHFPflAndk9TJHNPJVskck8lXyRyTyVjJHRPfk9WJH1PYSR9T2clUE9vMGNPdjBxT35QJ3ZPbzBjT3YwcU97JVNPflAndk8mWSVVT35PYSFiT2ghaU8hWCFrTyFmIW1PVmJhX2Jha2JhbGJhbWJhbmJhb2JhcGJhc2JhemJhe2JhIXhiYSNnYmElW2JhJV9iYSVqYmEla2JhJWxiYSVtYmElbmJhJW9iYSVwYmElcWJhJXJiYSVzYmElemJhZ2JhIVRiYSFVYmEle2JhIVdiYSFbYmEhUWJhI1tiYXRiYSFtYmF+T24lWk9+T28lWk9+UCd2T28wY09+UCd2T2swZU9sMGZPbTBkT24wZE9vMG1PcDBuT3Mwck9nJXdYIVQld1ghVSV3WCV7JXdYIVcld1ghWyV3WCFRJXdYI1sld1ghbSV3WH5QKXBPJXslXU9nJXZYeiV2WCFUJXZYIVUldlghVyV2WHsldlh+T2clX096JWBPIVQlZE8hVSVjT35PZyVfT35PeiVnTyFUJWRPIVUlY08hVyZTWH5PIVcla09+T3olbE97JW5PIVQlZE8hVSVjTyFbJX1Yfk8hWyVyT35PIVslc09+T1EjWE8lYCNYTyVhJXVPfk9WJXdPbzBjT3YwcU8hUHJPflAndk9RI15PUiNbTyVgI15PJWElek9+T1YhcWFfIXFhYSFxYWghcWFrIXFhbCFxYW0hcWFuIXFhbyFxYXAhcWFzIXFheiFxYXshcWEhWCFxYSFmIXFhIXghcWEjZyFxYSVbIXFhJV8hcWElaiFxYSVrIXFhJWwhcWElbSFxYSVuIXFhJW8hcWElcCFxYSVxIXFhJXIhcWElcyFxYSV6IXFhZyFxYSFUIXFhIVUhcWEleyFxYSFXIXFhIVshcWEhUSFxYSNbIXFhdCFxYSFtIXFhflAjeU96JXxPeyVoYSF4JWhhI2claGElWyVoYSVfJWhhJXolaGF+UCVTT1YmT09vcE92cU97JWhhIXglaGEjZyVoYSVbJWhhJV8laGEleiVoYX5QJ3ZPeiV8T3slaGEheCVoYSNnJWhhJVslaGElXyVoYSV6JWhhfk9QZE9WYU9vcE92cU8hUHJPIVF7TyF7dE8hfXVPI1B2TyNSd08jVHhPI1h5TyNaek8jXnxPI198TyNhfU8jYyFPTyNnJHpYJVskelglXyR6WH5QJ3ZPI2cjZ08lWyZUTyVfJlRPfk8hZiZVT2gmc1glWyZzWHomc1gjWyZzWCNnJnNYJV8mc1gjWiZzWGcmc1h+T2ghaU8lWyZXT35Pa2VhbGVhbWVhbmVhb2VhcGVhc2VhemVhe2VhIXhlYSNnZWElW2VhJV9lYSV6ZWFnZWEhVGVhIVVlYSV7ZWEhV2VhIVtlYSFRZWEjW2VhdGVhIW1lYX5QJVNPc3FhenFhe3FhI2dxYSVbcWElX3FhJXpxYX5PayFwT2whcU9tIW9PbiFvT28hck9wIXNPIXhxYX5QRWNPJXomWU96JXlYeyV5WH5PJXVXT3oleVh7JXlYfk96Jl1Pe3dYfk97Jl9Pfk96JWxPI2clfVglWyV9WCVfJX1YZyV9WHslfVghWyV9WCFtJX1YJXolfVh+T1YwbE9vMGNPdjBxTyFQck9+UCd2TyV6I3xPI2dVYSVbVWElX1Vhfk96JmhPI2cmUFglWyZQWCVfJlBYbiZQWH5QJVNPeiZrTyFRJmpPI2cjV2ElWyNXYSVfI1dhfk96JmxPI1smbk8jZyZyWCVbJnJYJV8mclhnJnJYfk8hZiRZTyFyJFlPI1omcU8ldVdPfk8jWiZxT35PeiZzTyNnJnRYJVsmdFglXyZ0WH5PeiZ1TyNnJnBYJVsmcFglXyZwWHsmcFh+TyFYJndPJXomeE9+T3omfE9uJndYflAlU09uJ1BPfk9QZE9WYU9vcE92cU8hUHJPIVF7TyF7dE8hfXVPI1B2TyNSd08jVHhPI1h5TyNaek8jXnxPI198TyNhfU8jYyFPTyVbJ1VPflAndk90J1lPI3AnV08jcSdYT1AjbmFWI25hZiNuYWgjbmFvI25hcyNuYXYjbmEhUCNuYSFRI25hIVQjbmEhVSNuYSFYI25hIV0jbmEhaCNuYSFyI25hIXMjbmEhdCNuYSF7I25hIX0jbmEjUCNuYSNSI25hI1QjbmEjWCNuYSNaI25hI14jbmEjXyNuYSNhI25hI2MjbmEjbCNuYSNvI25hI3MjbmEjdSNuYSN6I25hI30jbmEkUCNuYSVYI25hJW8jbmElcCNuYSV0I25hJXUjbmEmWiNuYSZbI25hJl0jbmEmXiNuYSZfI25hJmAjbmEmYSNuYSZiI25hJmMjbmEmZCNuYSZlI25hJmYjbmEmZyNuYSZoI25hJmkjbmEmaiNuYSVaI25hJV8jbmF+T3onWk8jWyddT3smeFh+T2gnX08hWCZ3T35PaCFpT3skak8hWCZ3T35PeydlT35QJVNPJVsnaE8lXydoT35PUydpTyVbJ2hPJV8naE9+T1YhYU9fIWFPYSFiT2ghaU8hWCFrTyFmIW1PJWwhXk8lbSFfTyVuIV9PJW8hYE8lcCFgTyVxIWFPJXIhYU8lcyFhT2tXaWxXaW1XaW5XaW9XaXBXaXNXaXpXaXtXaSF4V2kjZ1dpJVtXaSVfV2klaldpJXpXaWdXaSFUV2khVVdpJXtXaSFXV2khW1dpIVFXaSNbV2l0V2khbVdpfk8layFdT35QISN1TyVrV2l+UCEjdU9WIWFPXyFhT2EhYk9oIWlPIVgha08hZiFtTyVvIWBPJXAhYE8lcSFhTyVyIWFPJXMhYU9rV2lsV2ltV2luV2lvV2lwV2lzV2l6V2l7V2kheFdpI2dXaSVbV2klX1dpJWpXaSVrV2klbFdpJXpXaWdXaSFUV2khVVdpJXtXaSFXV2khW1dpIVFXaSNbV2l0V2khbVdpfk8lbSFfTyVuIV9PflAhJnBPJW1XaSVuV2l+UCEmcE9hIWJPaCFpTyFYIWtPIWYhbU9rV2lsV2ltV2luV2lvV2lwV2lzV2l6V2l7V2kheFdpI2dXaSVbV2klX1dpJWpXaSVrV2klbFdpJW1XaSVuV2klb1dpJXBXaSV6V2lnV2khVFdpIVVXaSV7V2khV1dpIVtXaSFRV2kjW1dpdFdpIW1XaX5PViFhT18hYU8lcSFhTyVyIWFPJXMhYU9+UCEpbk9WV2lfV2klcVdpJXJXaSVzV2l+UCEpbk8hVCVkTyFVJWNPZyZWWHomVlh+TyV6J2tPJXsna09+UCxlT3onbU9nJlVYfk9nJ29Pfk96J3BPeydyTyFXJlhYfk9vMGNPdjBxT3oncE97J3NPIVcmWFh+UCd2TyFXJ3VPfk9tIW9PbiFvT28hck9wIXNPa2ppc2ppemppe2ppIXhqaSNnamklW2ppJV9qaSV6aml+T2whcU9+UCEuYU9saml+UCEuYU9rMGVPbDBmT20wZE9uMGRPbzBtT3Awbk9+T3Qnd09+UCEvak9WJ3xPZyd9T28wY092MHFPflAndk9nJ31PeihPT35PZyhRT35PIVUoU09+T2coVE96KE9PIVQlZE8hVSVjT35QJVNPazBlT2wwZk9tMGRPbjBkT28wbU9wMG5PZ3FhIVRxYSFVcWEle3FhIVdxYSFbcWEhUXFhI1txYXRxYSFtcWF+UEVjT1YnfE9vMGNPdjBxTyFXJlNhflAndk96KFdPIVcmU2F+TyFXKFhPfk96KFdPIVQlZE8hVSVjTyFXJlNhflAlU09WKF1PbzBjT3YwcU8hWyV9YSNnJX1hJVslfWElXyV9YWclfWF7JX1hIW0lfWEleiV9YX5QJ3ZPeiheTyFbJX1hI2clfWElWyV9YSVfJX1hZyV9YXslfWEhbSV9YSV6JX1hfk8hWyhhT35PeiheTyFUJWRPIVUlY08hWyV9YX5QJVNPeihkTyFUJWRPIVUlY08hWyZUYX5QJVNPeihnT3smbFghWyZsWCFtJmxYJXombFh+T3soa08hWyhtTyFtKG5PJXooak9+T1YmT09vcE92cU97JWhpIXglaGkjZyVoaSVbJWhpJV8laGkleiVoaX5QJ3ZPeihwT3slaGkheCVoaSNnJWhpJVslaGklXyVoaSV6JWhpfk8hZiZVT2gmc2ElWyZzYXomc2EjWyZzYSNnJnNhJV8mc2EjWiZzYWcmc2F+TyVbKHVPfk9WI3NPYSN0TyV1V09+T3omXU97d2F+T29wT3ZxT35QJ3ZPeiheTyNnJX1hJVslfWElXyV9YWclfWF7JX1hIVslfWEhbSV9YSV6JX1hflAlU096KHpPI2claFglWyVoWCVfJWhYJXolaFh+TyV6I3xPI2dVaSVbVWklX1Vpfk8jZyZQYSVbJlBhJV8mUGFuJlBhflAndk96KH1PI2cmUGElWyZQYSVfJlBhbiZQYX5PJXVXTyNnJnJhJVsmcmElXyZyYWcmcmF+T3opU08jZyZyYSVbJnJhJV8mcmFnJnJhfk9nKVZPfk9WKVdPaCRXTyV1V09+TyNaKVhPfk8ldVdPI2cmdGElWyZ0YSVfJnRhfk96KVpPI2cmdGElWyZ0YSVfJnRhfk9vMGNPdjBxTyNnJnBhJVsmcGElXyZwYXsmcGF+UCd2T3opXk8jZyZwYSVbJnBhJV8mcGF7JnBhfk9WKWBPYSlgTyV1V09+TyV6KWVPfk90KWhPI2opZ09QI2hpViNoaWYjaGloI2hpbyNoaXMjaGl2I2hpIVAjaGkhUSNoaSFUI2hpIVUjaGkhWCNoaSFdI2hpIWgjaGkhciNoaSFzI2hpIXQjaGkheyNoaSF9I2hpI1AjaGkjUiNoaSNUI2hpI1gjaGkjWiNoaSNeI2hpI18jaGkjYSNoaSNjI2hpI2wjaGkjbyNoaSNzI2hpI3UjaGkjeiNoaSN9I2hpJFAjaGklWCNoaSVvI2hpJXAjaGkldCNoaSV1I2hpJlojaGkmWyNoaSZdI2hpJl4jaGkmXyNoaSZgI2hpJmEjaGkmYiNoaSZjI2hpJmQjaGkmZSNoaSZmI2hpJmcjaGkmaCNoaSZpI2hpJmojaGklWiNoaSVfI2hpfk90KWlPUCNraVYja2lmI2tpaCNraW8ja2lzI2tpdiNraSFQI2tpIVEja2khVCNraSFVI2tpIVgja2khXSNraSFoI2tpIXIja2khcyNraSF0I2tpIXsja2khfSNraSNQI2tpI1Ija2kjVCNraSNYI2tpI1oja2kjXiNraSNfI2tpI2Eja2kjYyNraSNsI2tpI28ja2kjcyNraSN1I2tpI3oja2kjfSNraSRQI2tpJVgja2klbyNraSVwI2tpJXQja2kldSNraSZaI2tpJlsja2kmXSNraSZeI2tpJl8ja2kmYCNraSZhI2tpJmIja2kmYyNraSZkI2tpJmUja2kmZiNraSZnI2tpJmgja2kmaSNraSZqI2tpJVoja2klXyNraX5PVilrT24md2F+UCd2T3opbE9uJndhfk96KWxPbiZ3YX5QJVNPbilwT35PJVkpdE9+T3Qpd08jcCdXTyNxKXZPUCNuaVYjbmlmI25paCNuaW8jbmlzI25pdiNuaSFQI25pIVEjbmkhVCNuaSFVI25pIVgjbmkhXSNuaSFoI25pIXIjbmkhcyNuaSF0I25pIXsjbmkhfSNuaSNQI25pI1IjbmkjVCNuaSNYI25pI1ojbmkjXiNuaSNfI25pI2EjbmkjYyNuaSNsI25pI28jbmkjcyNuaSN1I25pI3ojbmkjfSNuaSRQI25pJVgjbmklbyNuaSVwI25pJXQjbmkldSNuaSZaI25pJlsjbmkmXSNuaSZeI25pJl8jbmkmYCNuaSZhI25pJmIjbmkmYyNuaSZkI25pJmUjbmkmZiNuaSZnI25pJmgjbmkmaSNuaSZqI25pJVojbmklXyNuaX5PVil6T28wY092MHFPeyRqT35QJ3ZPbzBjT3YwcU97JnhhflAndk96Kk9PeyZ4YX5PVipTT2EqVE9nKldPJXEqVU8ldVdPfk97JGpPJnsqWU9+T2gnX09+T2ghaU97JGpPfk8lWypfT35PJVsqYU8lXyphT35PViR9T2EkfU9vMGNPdjBxT2cmVWF+UCd2T3oqZE9nJlVhfk9vMGNPdjBxT3sqZ08hVyZYYX5QJ3ZPeipoTyFXJlhhfk9vMGNPdjBxT3oqaE97KmtPIVcmWGF+UCd2T28wY092MHFPeipoTyFXJlhhflAndk96KmhPeyprTyFXJlhhfk9tMGRPbjBkT28wbU9wMG5PZ2ppa2ppc2ppemppIVRqaSFVamkle2ppIVdqaXtqaSFbamkjZ2ppJVtqaSVfamkhUWppI1tqaXRqaSFtamklemppfk9sMGZPflAhTmtPbGppflAhTmtPVid8T2cqcE9vMGNPdjBxT35QJ3ZPbipyT35PZypwT3oqdE9+T2cqdU9+T1YnfE9vMGNPdjBxTyFXJlNpflAndk96KnZPIVcmU2l+TyFXKndPfk9WKF1PbzBjT3YwcU8hWyV9aSNnJX1pJVslfWklXyV9aWclfWl7JX1pIW0lfWkleiV9aX5QJ3ZPeip6TyFUJWRPIVUlY08hWyZUaX5Peip9TyFbJX1pI2clfWklWyV9aSVfJX1pZyV9aXslfWkhbSV9aSV6JX1pfk8hWytPT35PYStRT28wY092MHFPIVsmVGl+UCd2T3oqek8hWyZUaX5PIVsrU09+T1YrVU9vMGNPdjBxT3smbGEhWyZsYSFtJmxhJXombGF+UCd2T3orVk97JmxhIVsmbGEhbSZsYSV6Jmxhfk8hXStZTyZuK1tPIVshblh+TyFbK15Pfk97KGtPIVsrX09+T3soa08hWytfTyFtK2BPfk9WJk9Pb3BPdnFPeyVocSF4JWhxI2claHElWyVocSVfJWhxJXolaHF+UCd2T3okcml7JHJpIXgkcmkjZyRyaSVbJHJpJV8kcmkleiRyaX5QJVNPViZPT29wT3ZxT35QJ3ZPViZPT28wY092MHFPI2claGElWyVoYSVfJWhhJXolaGF+UCd2T3orYU8jZyVoYSVbJWhhJV8laGEleiVoYX5PeiRpYSNnJGlhJVskaWElXyRpYW4kaWF+UCVTTyNnJlBpJVsmUGklXyZQaW4mUGl+UCd2T3orZE8jZyNXcSVbI1dxJV8jV3F+TyNbK2VPeiR2YSNnJHZhJVskdmElXyR2YWckdmF+TyV1V08jZyZyaSVbJnJpJV8mcmlnJnJpfk96K2dPI2cmcmklWyZyaSVfJnJpZyZyaX5PVitpT2gkV08ldVdPfk8ldVdPI2cmdGklWyZ0aSVfJnRpfk9vMGNPdjBxTyNnJnBpJVsmcGklXyZwaXsmcGl+UCd2T3sje096I2VYIVcjZVh+T3orbU8hVyZ1WH5PIVcrb09+T3Qrck8jailnT1AjaHFWI2hxZiNocWgjaHFvI2hxcyNocXYjaHEhUCNocSFRI2hxIVQjaHEhVSNocSFYI2hxIV0jaHEhaCNocSFyI2hxIXMjaHEhdCNocSF7I2hxIX0jaHEjUCNocSNSI2hxI1QjaHEjWCNocSNaI2hxI14jaHEjXyNocSNhI2hxI2MjaHEjbCNocSNvI2hxI3MjaHEjdSNocSN6I2hxI30jaHEkUCNocSVYI2hxJW8jaHElcCNocSV0I2hxJXUjaHEmWiNocSZbI2hxJl0jaHEmXiNocSZfI2hxJmAjaHEmYSNocSZiI2hxJmMjaHEmZCNocSZlI2hxJmYjaHEmZyNocSZoI2hxJmkjaHEmaiNocSVaI2hxJV8jaHF+T24kfGF6JHxhflAlU09WKWtPbiZ3aX5QJ3ZPeit5T24md2l+T3osVE97JGpPI1ssVE9+TyNxLFZPUCNucVYjbnFmI25xaCNucW8jbnFzI25xdiNucSFQI25xIVEjbnEhVCNucSFVI25xIVgjbnEhXSNucSFoI25xIXIjbnEhcyNucSF0I25xIXsjbnEhfSNucSNQI25xI1IjbnEjVCNucSNYI25xI1ojbnEjXiNucSNfI25xI2EjbnEjYyNucSNsI25xI28jbnEjcyNucSN1I25xI3ojbnEjfSNucSRQI25xJVgjbnElbyNucSVwI25xJXQjbnEldSNucSZaI25xJlsjbnEmXSNucSZeI25xJl8jbnEmYCNucSZhI25xJmIjbnEmYyNucSZkI25xJmUjbnEmZiNucSZnI25xJmgjbnEmaSNucSZqI25xJVojbnElXyNucX5PI1ssV096JU9heyVPYX5PbzBjT3YwcU97JnhpflAndk96LFlPeyZ4aX5PeyN7TyV6LFtPZyZ6WHomelh+TyV1V09nJnpYeiZ6WH5PeixgT2cmeVh+T2csYk9+TyVZLGVPfk8hVCVkTyFVJWNPZyZWaXomVml+T1YkfU9hJH1PbzBjT3YwcU9nJlVpflAndk97LGhPeiRsYSFXJGxhfk9vMGNPdjBxT3ssaU96JGxhIVckbGF+UCd2T28wY092MHFPeypnTyFXJlhpflAndk96LGxPIVcmWGl+T28wY092MHFPeixsTyFXJlhpflAndk96LGxPeyxvTyFXJlhpfk9nJGhpeiRoaSFXJGhpflAlU09WJ3xPbzBjT3YwcU9+UCd2T24scU9+T1YnfE9nLHJPbzBjT3YwcU9+UCd2T1YnfE9vMGNPdjBxTyFXJlNxflAndk96JGdpIVskZ2kjZyRnaSVbJGdpJV8kZ2lnJGdpeyRnaSFtJGdpJXokZ2l+UCVTT1YoXU9vMGNPdjBxT35QJ3ZPYStRT28wY092MHFPIVsmVHF+UCd2T3osc08hWyZUcX5PIVssdE9+T1YoXU9vMGNPdjBxTyFbJX1xI2clfXElWyV9cSVfJX1xZyV9cXslfXEhbSV9cSV6JX1xflAndk97LHVPfk9WK1VPbzBjT3YwcU97JmxpIVsmbGkhbSZsaSV6JmxpflAndk96LHpPeyZsaSFbJmxpIW0mbGkleiZsaX5PIV0rWU8mbitbTyFbIW5hfk97KGtPIVssfU9+T1YmT09vMGNPdjBxTyNnJWhpJVslaGklXyVoaSV6JWhpflAndk96LU9PI2claGklWyVoaSVfJWhpJXolaGl+TyV1V08jZyZycSVbJnJxJV8mcnFnJnJxfk96LVJPI2cmcnElWyZycSVfJnJxZyZycX5PVilgT2EpYE8ldVdPIVcmdWF+T3otVE8hVyZ1YX5PbiR8aXokfGl+UCVTT1Ypa09+UCd2T1Ypa09uJndxflAndk90LVhPUCNteVYjbXlmI215aCNteW8jbXlzI215diNteSFQI215IVEjbXkhVCNteSFVI215IVgjbXkhXSNteSFoI215IXIjbXkhcyNteSF0I215IXsjbXkhfSNteSNQI215I1IjbXkjVCNteSNYI215I1ojbXkjXiNteSNfI215I2EjbXkjYyNteSNsI215I28jbXkjcyNteSN1I215I3ojbXkjfSNteSRQI215JVgjbXklbyNteSVwI215JXQjbXkldSNteSZaI215JlsjbXkmXSNteSZeI215Jl8jbXkmYCNteSZhI215JmIjbXkmYyNteSZkI215JmUjbXkmZiNteSZnI215JmgjbXkmaSNteSZqI215JVojbXklXyNteX5PJVotXU8lXy1dT35QYE8jcS1eT1AjbnlWI255ZiNueWgjbnlvI255cyNueXYjbnkhUCNueSFRI255IVQjbnkhVSNueSFYI255IV0jbnkhaCNueSFyI255IXMjbnkhdCNueSF7I255IX0jbnkjUCNueSNSI255I1QjbnkjWCNueSNaI255I14jbnkjXyNueSNhI255I2MjbnkjbCNueSNvI255I3MjbnkjdSNueSN6I255I30jbnkkUCNueSVYI255JW8jbnklcCNueSV0I255JXUjbnkmWiNueSZbI255Jl0jbnkmXiNueSZfI255JmAjbnkmYSNueSZiI255JmMjbnkmZCNueSZlI255JmYjbnkmZyNueSZoI255JmkjbnkmaiNueSVaI255JV8jbnl+T3otYU97JGpPI1stYU9+T28wY092MHFPeyZ4cX5QJ3ZPei1kT3smeHF+TyV6LFtPZyZ6YXomemF+T3sje09nJnpheiZ6YX5PVipTT2EqVE8lcSpVTyV1V09nJnlhfk96LWhPZyZ5YX5PJFMtbE9+T1YkfU9hJH1PbzBjT3YwcU9+UCd2T28wY092MHFPey1tT3okbGkhVyRsaX5QJ3ZPbzBjT3YwcU96JGxpIVckbGl+UCd2T3stbU96JGxpIVckbGl+T28wY092MHFPeypnT35QJ3ZPbzBjT3YwcU97KmdPIVcmWHF+UCd2T3otcE8hVyZYcX5PbzBjT3YwcU96LXBPIVcmWHF+UCd2T3Mtc08hVCVkTyFVJWNPZyZPcSFXJk9xIVsmT3F6Jk9xflAhL2pPYStRT28wY092MHFPIVsmVHl+UCd2T3okamkhWyRqaX5QJVNPYStRT28wY092MHFPflAndk9WK1VPbzBjT3YwcU9+UCd2T1YrVU9vMGNPdjBxT3smbHEhWyZscSFtJmxxJXombHF+UCd2T3soa08hWy14TyFtLXlPJXotd09+T1YmT09vMGNPdjBxTyNnJWhxJVslaHElXyVocSV6JWhxflAndk8ldVdPI2cmcnklWyZyeSVfJnJ5ZyZyeX5PVilgT2EpYE8ldVdPIVcmdWl+T3QtfU9QI20hUlYjbSFSZiNtIVJoI20hUm8jbSFScyNtIVJ2I20hUiFQI20hUiFRI20hUiFUI20hUiFVI20hUiFYI20hUiFdI20hUiFoI20hUiFyI20hUiFzI20hUiF0I20hUiF7I20hUiF9I20hUiNQI20hUiNSI20hUiNUI20hUiNYI20hUiNaI20hUiNeI20hUiNfI20hUiNhI20hUiNjI20hUiNsI20hUiNvI20hUiNzI20hUiN1I20hUiN6I20hUiN9I20hUiRQI20hUiVYI20hUiVvI20hUiVwI20hUiV0I20hUiV1I20hUiZaI20hUiZbI20hUiZdI20hUiZeI20hUiZfI20hUiZgI20hUiZhI20hUiZiI20hUiZjI20hUiZkI20hUiZlI20hUiZmI20hUiZnI20hUiZoI20hUiZpI20hUiZqI20hUiVaI20hUiVfI20hUn5PbzBjT3YwcU97Jnh5flAndk9WKlNPYSpUTyVxKlVPJXVXT2cmeWl+TyRTLWxPJVouVk8lXy5WT35PVi5hT2guX08hWC5eTyFdLmBPIWguWU8hcy5bTyF0LltPJXAuWE8ldVdPJlpdTyZbXU8mXV1PJl5dTyZfXU8mYF1PJmFdTyZiXU9+T28wY092MHFPeiRscSFXJGxxflAndk97LmZPeiRscSFXJGxxfk9vMGNPdjBxT3sqZ08hVyZYeX5QJ3ZPei5nTyFXJlh5fk9vMGNPdi5rT35QJ3ZPcy1zTyFUJWRPIVUlY09nJk95IVcmT3khWyZPeXomT3l+UCEvak97KGtPIVsubk9+T3soa08hWy5uTyFtLm9Pfk9WKlNPYSpUTyVxKlVPJXVXT35PaC50TyFmLnJPeiRUWCNbJFRYJWokVFhnJFRYfk9zJFRYeyRUWCFXJFRYIVskVFh+UCQtYk8lby52TyVwLnZPcyRVWHokVVh7JFVYI1skVVglaiRVWCFXJFVYZyRVWCFbJFVYfk8haC54T35Pei58TyNbL09PJWoueU9zJnxYeyZ8WCFXJnxYZyZ8WH5PYS9ST35QJCl6T2gudE9zJn1YeiZ9WHsmfVgjWyZ9WCVqJn1YIVcmfVhnJn1YIVsmfVh+T3MvVk97JGpPfk9vMGNPdjBxT3okbHkhVyRseX5QJ3ZPbzBjT3YwcU97KmdPIVcmWCFSflAndk96L1pPIVcmWCFSfk9nJlJYcyZSWCFUJlJYIVUmUlghVyZSWCFbJlJYeiZSWH5QIS9qT3Mtc08hVCVkTyFVJWNPZyZRYSFXJlFhIVsmUWF6JlFhfk97KGtPIVsvXk9+TyFmLnJPaCRbYXMkW2F6JFtheyRbYSNbJFthJWokW2EhVyRbYWckW2EhWyRbYX5PIWgvZU9+TyVvLnZPJXAudk9zJFVheiRVYXskVWEjWyRVYSVqJFVhIVckVWFnJFVhIVskVWF+TyVqLnlPcyRZYXokWWF7JFlhI1skWWEhVyRZYWckWWEhWyRZYX5PcyZ8YXsmfGEhVyZ8YWcmfGF+UCQpbk96L2pPcyZ8YXsmfGEhVyZ8YWcmfGF+TyFXL21Pfk9nL21Pfk97L29Pfk8hWy9wT35PbzBjT3YwcU97KmdPIVcmWCFaflAndk97L3NPfk8lei90T35QJC1iT3ovdU8jWy9PTyVqLnlPZydQWH5Pei91T2cnUFh+T2cvd09+TyFoL3hPfk8jWy9PT3MlU2F6JVNheyVTYSVqJVNhIVclU2FnJVNhIVslU2F+TyNbL09PJWoueU9zJVdheiVXYXslV2EhVyVXYWclV2F+T3MmfGl7JnxpIVcmfGlnJnxpflAkKW5Pei96TyNbL09PJWoueU8hWydPYX5PZydQYX5QJCluT3owU09nJ1Bhfk9hMFVPIVsnT2l+UCQpek96MFdPIVsnT2l+T3owV08jWy9PTyVqLnlPIVsnT2l+TyNbL09PJWoueU9nJGJpeiRiaX5PJXowWk9+UCQtYk8jWy9PTyVqLnlPZyVWYXolVmF+T2cnUGl+UCQpbk97MF5Pfk9hMFVPIVsnT3F+UCQpek96MGBPIVsnT3F+TyNbL09PJWoueU96JVVpIVslVWl+T2EwVU9+UCQpek9hMFVPIVsnT3l+UCQpek8jWy9PTyVqLnlPZyRjaXokY2l+TyNbL09PJWoueU96JVVxIVslVXF+T3orYU8jZyVoYSVbJWhhJV8laGEleiVoYX5QJVNPViZPT28wY092MHFPflAndk9uMGhPfk9vMGhPflAndk97MGlPfk90MGpPflAhL2pPJl0mWiZqJmgmaSZnJmYmZCZlJmMmYiZgJmEmXyZeJlsldX5cIixcbiAgZ290bzogXCIhPWonUVBQUFBQUCdSUCdaKnMrWyt0LF8seS1mUC5TUCdaLnIucidaUFBQJ1oyW1BQUFBQUDJbNVBQUDVQUDdiN2s9c1BQPXY+aD5rUFAnWidaUFA+elBQJ1onWlBQJ1onWidaJ1onWj9PP3cnWlA/elBAUURYR3VHeVBHfEhXSFsnWlBQUEhfSGsnUlAnUidSUCdSUCdSUCdSUCdSUCdSJ1InUlAnUlBQJ1JQUCdSUCdSUEhxSH1JVlBJXklkUEleUEleSV5QUFBJXlBLclBLe0xWTF1LclBJXkxmUEleUExtTHNQTHdNXU16TmVMd0x3TmtOeEx3THdMd0x3ISBeISBkISBnISBsISBvISB5ISFQISFdISFvISF1ISNQISNWISNzISN5ISRQISRaISRhISRnISR5ISVUISVaISVhISVrISVxISV3ISV9ISZUISZaISZlISZrISZ1ISZ7ISdVISdbISdrISdzISd9IShVUFBQUFBQUFBQUFAhKFshKF8hKGUhKG4hKHghKVRQUFBQUFBQUFBQUFAhLXUhL1ohM14hNm9QUCE2dyE3VyE3YSE4WSE4UCE4YyE4aSE4bCE4byE4ciE4eiE5alBQUFBQUFBQUFBQUFBQUFBQITltITlxITl3UCE6XSE6YSE6bSE6diE7UyE7aiE7bSE7cCE7diE7fCE8UyE8VlAhPF8hPGghPWQhPWddZU9uI2ckail0LFAnfWBPVFlaW2Fkbm9wcnR4eX0hUCFRIVIhVSFYIWMhZCFlIWYhZyFoIWkhayFvIXAhcSFzIXQheiNPI1MjVCNbI2QjZyN4I3kjeyN9JFEkZSRnJGgkaiRxJH0lUyVaJV4lYCVjJWclbCVuJXclfCZPJlomXyZoJmomayZ1JngmfCdQJ1cnWidsJ20ncCdyJ3Mndyd8KE8oUyhXKF0oXihkKGcocChyKHoofSleKWUpZylrKWwpcCl0KXoqTypZKmQqZypoKmsqcSpyKnQqdip5KnoqfStRK1UrVitZK2ErYytkK2sreCt5LFAsWCxZLF0sZyxoLGksayxsLG8scSxzLHUsdyx5LHotTy1kLWYtbS1wLXMuZi5nL1YvWi9zMGMwZDBlMGYwaDBpMGowazBsMG4wcnshY1EjYyNwJFIkZCRwJWUlaiVwJXEmYCdPJ2cocSh8KWoqbyp4K3csdjBnfSFkUSNjI3AkUiRkJHAkdSVlJWolcCVxJmAnTydnKHEofClqKm8qeCt3LHYwZyFQIWVRI2MjcCRSJGQkcCR1JHYlZSVqJXAlcSZgJ08nZyhxKHwpaipvKngrdyx2MGchUiFmUSNjI3AkUiRkJHAkdSR2JHclZSVqJXAlcSZgJ08nZyhxKHwpaipvKngrdyx2MGchVCFnUSNjI3AkUiRkJHAkdSR2JHckeCVlJWolcCVxJmAnTydnKHEofClqKm8qeCt3LHYwZyFWIWhRI2MjcCRSJGQkcCR1JHYkdyR4JHklZSVqJXAlcSZgJ08nZyhxKHwpaipvKngrdyx2MGchWiFoUSFuI2MjcCRSJGQkcCR1JHYkdyR4JHkkeiVlJWolcCVxJmAnTydnKHEofClqKm8qeCt3LHYwZyd9VE9UWVpbYWRub3BydHh5fSFQIVEhUiFVIVghYyFkIWUhZiFnIWghaSFrIW8hcCFxIXMhdCF6I08jUyNUI1sjZCNnI3gjeSN7I30kUSRlJGckaCRqJHEkfSVTJVolXiVgJWMlZyVsJW4ldyV8Jk8mWiZfJmgmaiZrJnUmeCZ8J1AnVydaJ2wnbSdwJ3Incyd3J3woTyhTKFcoXSheKGQoZyhwKHIoeih9KV4pZSlnKWspbClwKXQpeipPKlkqZCpnKmgqaypxKnIqdCp2Knkqeip9K1ErVStWK1krYStjK2Qrayt4K3ksUCxYLFksXSxnLGgsaSxrLGwsbyxxLHMsdSx3LHksei1PLWQtZi1tLXAtcy5mLmcvVi9aL3MwYzBkMGUwZjBoMGkwajBrMGwwbjByJmVWT1laW2RucHJ4eX0hUCFRIVUhaSFrIW8hcCFxIXMhdCNbI2QjZyN5I3sjfSRRJGgkaiR9JVMlWiVeJWAlZyVsJW4ldyV8JlomXyZqJmsmdSZ4J1AnVydaJ2wnbSdwJ3Incyd3KE8oVyheKGQoZyhwKHIoeileKWUpZylwKXQpeipPKlkqZCpnKmgqaypxKnIqdCp2Knkqeip9K1UrVitZK2ErZCtrLFAsWCxZLF0sZyxoLGksayxsLG8scSxzLHUsdyx5LHotTy1kLWYtbS1wLXMuZi5nL1YvWi9zMGMwZDBlMGYwaDBpMGowazBuMHIlb1hPWVpbZG5yeHl9IVAhUSFVIWkhayNbI2QjZyN5I3sjfSRRJGgkaiR9JVMlXiVgJWclbCVuJXclfCZaJl8maiZrJnUmeCdQJ1cnWidsJ20ncCdyJ3MndyhPKFcoXihkKGcocChyKHopXillKWcpcCl0KXoqTypZKmQqZypoKmsqcSp0KnYqeSp6Kn0rVStWK1krYStkK2ssUCxYLFksXSxnLGgsaSxrLGwsbyxzLHUsdyx5LHotTy1kLWYtbS1wLmYuZy9WL1owaTBqMGtRI3ZxUS9bLmtSMG8wcSd0YE9UWVpbYWRub3BydHh5fSFQIVEhUiFVIVghYyFkIWUhZiFnIWghayFvIXAhcSFzIXQheiNPI1MjVCNbI2QjZyN4I3kjeyN9JFEkZSRnJGgkaiRxJH0lUyVaJV4lYCVjJWclbCVuJXclfCZPJlomXyZoJmomayZ1JngmfCdQJ1cnWidsJ3AncidzJ3cnfChPKFMoVyhdKF4oZChnKHAocih6KH0pXillKWcpaylsKXApdCl6Kk8qWSpnKmgqaypxKnIqdCp2Knkqeip9K1ErVStWK1krYStjK2Qrayt4K3ksUCxYLFksXSxoLGksayxsLG8scSxzLHUsdyx5LHotTy1kLWYtbS1wLXMuZi5nL1YvWi9zMGMwZDBlMGYwaDBpMGowazBsMG4wcmgjamh6eyRXJFombCZxKVMpWCtmK2ctUlcjcnEmXS5rMHFRJF18USRhIU9RJG4hVlEkbyFXVyR8IWknbSpkLGdTJlsjcyN0USdTJGlRKHMmVVEpVSZuVSlZJnMpWitqVylhJncrbS1ULXtRKlEnXVcqUidfLGAtaC5UUStsKWBTLF8qUypUUS1RK2VRLV8sVFEtYyxXUS5SLWFsLlctbC5eLl8uYS56LnwvUi9qL28vdC95MFUwWjBeUS9TLmBRL2EudFEvbC9PVTBQL3UwUzBbWDBWL3owVzBfMGBSJlojciFfIXdZWiFQIVEhayVTJWAlZydwJ3IncyhPKFcpZypnKmgqaypxKnQqdixoLGksayxsLG8tbS1wLmYuZy9aUiVeIXZRIXtZUSV4I1tRJmQjfVEmZyRRUix7K1lULmotcy9zIVkhalEhbiNjI3AkUiRkJHAkdSR2JHckeCR5JHolZSVqJXAlcSZgJ08nZyhxKHwpaipvKngrdyx2MGdRJlgja1EnYyRvUipeJ2RSJ2wkfFElViFtUi9fLnInfF9PVFlaW2Fkbm9wcnR4eX0hUCFRIVIhVSFYIWMhZCFlIWYhZyFoIWkhayFvIXAhcSFzIXQheiNPI1MjVCNbI2QjZyN4I3kjeyN9JFEkZSRnJGgkaiRxJH0lUyVaJV4lYCVjJWclbCVuJXclfCZPJlomXyZoJmomayZ1JngmfCdQJ1cnWidsJ20ncCdyJ3Mndyd8KE8oUyhXKF0oXihkKGcocChyKHoofSleKWUpZylrKWwpcCl0KXoqTypZKmQqZypoKmsqcSpyKnQqdip5KnoqfStRK1UrVitZK2ErYytkK2sreCt5LFAsWCxZLF0sZyxoLGksayxsLG8scSxzLHUsdyx5LHotTy1kLWYtbS1wLXMuZi5nL1YvWi9zMGMwZDBlMGYwaDBpMGowazBsMG4wclMjYV8jYiFQLlstbC5eLl8uYC5hLnQuei58L1Ivai9vL3QvdS95L3owUzBVMFcwWjBbMF4wXzBgJ3xfT1RZWlthZG5vcHJ0eHl9IVAhUSFSIVUhWCFjIWQhZSFmIWchaCFpIWshbyFwIXEhcyF0IXojTyNTI1QjWyNkI2cjeCN5I3sjfSRRJGUkZyRoJGokcSR9JVMlWiVeJWAlYyVnJWwlbiV3JXwmTyZaJl8maCZqJmsmdSZ4JnwnUCdXJ1onbCdtJ3AncidzJ3cnfChPKFMoVyhdKF4oZChnKHAocih6KH0pXillKWcpaylsKXApdCl6Kk8qWSpkKmcqaCprKnEqcip0KnYqeSp6Kn0rUStVK1YrWSthK2MrZCtrK3greSxQLFgsWSxdLGcsaCxpLGssbCxvLHEscyx1LHcseSx6LU8tZC1mLW0tcC1zLmYuZy9WL1ovczBjMGQwZTBmMGgwaTBqMGswbDBuMHJUI2FfI2JUI15eI19SKG8leGEobCV4KG4obytgLHsteS16Lm9UK1soaytdUi16LHtRJFBzUStsKWFRLF4qUlItZSxfWCN9cyRPJFAmZlEmeSRhUSdhJG5RJ2Qkb1IpcydTUSliJndWLVMrbS1ULXtaZ09uJGopdCxQWGtPbil0LFBRJGshVFEmeiRiUSZ7JGNRJ14kbVEnYiRvUSlxJ1JRKXgnV1EpeydYUSl8J1lRKlonYFMqXSdjJ2RRK3MpZ1ErdSloUSt2KWlRK3opb1MrfClyKltRLFEpdlEsUil3UyxTKXkpelEsZCpeUS1WK3JRLVcrdFEtWSt7Uy1aK30sT1EtYCxVUS1iLFZRLXwtWFEuTy1bUS5QLV5RLlEtX1EucC19US5xLlJRL1cuZFIvci9YV2tPbil0LFBSI21qUSdgJG5TKXInUydhUixPKXNRLF0qUlItZixeUSpbJ2BRK30pclItWyxPWmlPam4pdCxQUSdmJHBSKmAnZ1QtaixlLWt1LmMtbC5eLl8uYS50LnoufC9SL2ovby90L3UveTBTMFUwWjBbMF50LmMtbC5eLl8uYS50LnoufC9SL2ovby90L3UveTBTMFUwWjBbMF5RL1MuYFgwVi96MFcwXzBgIVAuWi1sLl4uXy5gLmEudC56LnwvUi9qL28vdC91L3kvejBTMFUwVzBaMFswXjBfMGBRLncuWVIvZi54Zy56Ll0uey9iL2kvbi98ME8wUTBdMGEwYnUuYi1sLl4uXy5hLnQuei58L1Ivai9vL3QvdS95MFMwVTBaMFswXlgudS5XLmIvYTBQUi9jLnRWMFIvdTBTMFtSL1guZFFuT1Mjb24sUFIsUCl0USZeI3VSKHgmXlMlbSNSI3dTKF8lbShiVChiJXAmYFElYSF5USVoIX1XKFAlYSVoKFUoWVEoVSVlUihZJWpRJmkkUlIpTyZpUShlJXFRKnsoYFQrUihlKntRJ24lT1IqZSduUydxJVIlU1kqaSdxKmosbS1xLmhVKmoncidzJ3RVLG0qaypsKm1TLXEsbixvUi5oLXJRI1ldUiV0I1lRI19eUiV5I19RKGgldlMrVyhoK1hSK1goaVErXShrUix8K11RI2JfUiV7I2JRI2ViUSV9I2NXJlEjZSV9KHsrYlEoeyZjUitiMGdRJE9zUyZlJE8mZlImZiRQUSZ2JF9SKV8mdlEmViNqUih0JlZRJm0kVlMpVCZtK2hSK2gpVVEkWntSJnAkWlEmdCRdUilbJnRRK24pYlItVStuUSNoZlImUyNoUSlmJnpSK3EpZlEmfSRkUyltJn0pblIpbidPUSdWJGtSKXUnVlEnWyRsUypQJ1ssWlIsWipRUSxhKlZSLWksYVdqT24pdCxQUiNsalEtayxlUi5VLWtkLnsuXS9iL2kvbi98ME8wUTBdMGEwYlIvaC57VS5zLlcvYTBQUi9gLnNRL3svblMwWC97MFlSMFkvfFMvdi9iL2NSMFQvdlEufS5dUi9rLn1SIVpQWG1Pbil0LFBXbE9uKXQsUFInVCRqWWZPbiRqKXQsUFImUiNnW3NPbiNnJGopdCxQUiZkI30mZFFPWVpbZG5wcnh5fSFQIVEhVSFpIWshbyFwIXEhcyF0I1sjZCNnI3kjeyN9JFEkaCRqJH0lUyVaJV4lYCVnJWwlbiV3JXwmWiZfJmomayZ1JngnUCdXJ1onbCdtJ3AncidzJ3coTyhXKF4oZChnKHAocih6KV4pZSlnKXApdCl6Kk8qWSpkKmcqaCprKnEqcip0KnYqeSp6Kn0rVStWK1krYStkK2ssUCxYLFksXSxnLGgsaSxrLGwsbyxxLHMsdSx3LHksei1PLWQtZi1tLXAtcy5mLmcvVi9aL3MwYzBkMGUwZjBoMGkwajBrMG4wclEhblRRI2NhUSNwb1UkUnQlYyhTUyRkIVIkZ1EkcCFYUSR1IWNRJHYhZFEkdyFlUSR4IWZRJHkhZ1EkeiFoUSVlIXpRJWojT1ElcCNTUSVxI1RRJmAjeFEnTyRlUSdnJHFRKHEmT1UofCZoKH0rY1cpaiZ8KWwreCt5USpvJ3xRKngoXVErdylrUSx2K1FSMGcwbFEheVlRIX1aUSRiIVBRJGMhUVElUiFrUSd0JVNeJ3slYCVnKE8oVypxKnQqdl4qZidwKmgsayxsLXAuZy9aUSpsJ3JRKm0nc1ErdClnUSxqKmdRLG4qa1EtbixoUS1vLGlRLXIsb1EuZS1tUi9ZLmZbYk9uI2ckail0LFAhXiF2WVohUCFRIWslUyVgJWcncCdyJ3MoTyhXKWcqZypoKmsqcSp0KnYsaCxpLGssbCxvLW0tcC5mLmcvWlEjUltRI2ZkUyN3cnhRJFV5VyRffSRRJ1ApcFMkbCFVJGhXJHshaSdtKmQsZ1MldiNbK1lgJlAjZCV8KHAocih6K2EtTzBrUSZhI3lRJmIje1EmYyN9USdqJH1RJ3olXlcoWyVsKF4qeSp9UShgJW5RKGkld1EodiZaUyh5Jl8waVEpUCZqUSlRJmtVKV0mdSleK2tRKWQmeFEpeSdXWSl9J1oqTyxYLFktZFEqYidsUypuJ3cwalcrUChkKnoscyx3VytUKGcrVix5LHpRK3ApZVEsVSl6USxjKllRLHgrVVEtUCtkUS1lLF1RLXYsdVEuUy1mUi9xL1ZoVU9uI2QjZyRqJXwmXyd3KHAocil0LFAlVSF1WVpbZHJ4eX0hUCFRIVUhaSFrI1sjeSN7I30kUSRoJH0lUyVeJWAlZyVsJW4ldyZaJmomayZ1JngnUCdXJ1onbCdtJ3AncidzKE8oVyheKGQoZyh6KV4pZSlnKXApeipPKlkqZCpnKmgqaypxKnQqdip5KnoqfStVK1YrWSthK2QrayxYLFksXSxnLGgsaSxrLGwsbyxzLHUsdyx5LHotTy1kLWYtbS1wLmYuZy9WL1owaTBqMGtRI3FwVyVXIW8hczBkMG5RJVghcFElWSFxUSVbIXRRJWYwY1MndiVaMGhRJ3gwZVEneTBmUSxwKnJRLXUscVMuaS1zL3NSMHAwclUjdXEuazBxUih3Jl1bY09uI2ckail0LFBaIXhZI1sjfSRRK1lRI1dbUSN6clIkVHhRJWIheVElaSF9USVvI1JRJ2oke1EoViVlUShaJWpRKGMlcFEoZiVxUSp8KGBRLGYqYlEtdCxwUS5tLXVSL10ubFEkU3RRKFIlY1IqcyhTUS5sLXNSL30vc1IjUVpSI1ZbUiVRIWlRJU8haVYqYydtKmQsZyFaIWxRIW4jYyNwJFIkZCRwJHUkdiR3JHgkeSR6JWUlaiVwJXEmYCdPJ2cocSh8KWoqbyp4K3csdjBnUiVUIWtUI11eI19RJXgjW1IseytZUShtJXhTK18obihvUSx9K2BRLXgse1Mubi15LXpSL14ub1QrWihrK11RJGB9USZnJFFRKW8nUFIreylwUSRYelEpVyZxUitpKVhRJFh6USZvJFdRKVcmcVIraSlYUSNraFckVnokVyZxKVhRJFt7USZyJFpaKVImbClTK2YrZy1SUiRefFIpYyZ3WGxPbil0LFBRJGYhUlInUSRnUSRtIVVSJ1IkaFIqWCdfUSpWJ19WLWcsYC1oLlRRLmQtbFEvUC5eUi9RLl9VLl0tbC5eLl9RL1UuYVEvYi50US9nLnpVL2kufC9qL3lRL24vUlEvfC9vUTBPL3RVMFEvdTBTMFtRMF0wVVEwYTBaUjBiMF5SL1QuYFIvZC50XCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgRXNjYXBlIHsgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCApICggUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQmluYXJ5RXhwcmVzc2lvbiBvciBhbmQgQ29tcGFyZU9wIGluIG5vdCBpcyBVbmFyeUV4cHJlc3Npb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uIGlmIGVsc2UgTGFtYmRhRXhwcmVzc2lvbiBsYW1iZGEgUGFyYW1MaXN0IFZhcmlhYmxlTmFtZSBBc3NpZ25PcCAsIDogTmFtZWRFeHByZXNzaW9uIEFzc2lnbk9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBmcm9tIFR1cGxlRXhwcmVzc2lvbiBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBhc3luYyBmb3IgTGFtYmRhRXhwcmVzc2lvbiBdIFsgQXJyYXlFeHByZXNzaW9uIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gfSB7IERpY3Rpb25hcnlFeHByZXNzaW9uIERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEFyZ0xpc3QgQXNzaWduT3AgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBOdW1iZXIgU3RyaW5nIEZvcm1hdFN0cmluZyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRTZWxmRG9jIEZvcm1hdENvbnZlcnNpb24gRm9ybWF0U3BlYyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRTZWxmRG9jIENvbnRpbnVlZFN0cmluZyBFbGxpcHNpcyBOb25lIEJvb2xlYW4gVHlwZURlZiBBc3NpZ25PcCBVcGRhdGVTdGF0ZW1lbnQgVXBkYXRlT3AgRXhwcmVzc2lvblN0YXRlbWVudCBEZWxldGVTdGF0ZW1lbnQgZGVsIFBhc3NTdGF0ZW1lbnQgcGFzcyBCcmVha1N0YXRlbWVudCBicmVhayBDb250aW51ZVN0YXRlbWVudCBjb250aW51ZSBSZXR1cm5TdGF0ZW1lbnQgcmV0dXJuIFlpZWxkU3RhdGVtZW50IFByaW50U3RhdGVtZW50IFJhaXNlU3RhdGVtZW50IHJhaXNlIEltcG9ydFN0YXRlbWVudCBpbXBvcnQgYXMgU2NvcGVTdGF0ZW1lbnQgZ2xvYmFsIG5vbmxvY2FsIEFzc2VydFN0YXRlbWVudCBhc3NlcnQgVHlwZURlZmluaXRpb24gdHlwZSBUeXBlUGFyYW1MaXN0IFR5cGVQYXJhbSBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdCBNYXRjaFN0YXRlbWVudCBtYXRjaCBNYXRjaEJvZHkgTWF0Y2hDbGF1c2UgY2FzZSBDYXB0dXJlUGF0dGVybiBMaXRlcmFsUGF0dGVybiBBcml0aE9wIEFyaXRoT3AgQXNQYXR0ZXJuIE9yUGF0dGVybiBMb2dpY09wIEF0dHJpYnV0ZVBhdHRlcm4gU2VxdWVuY2VQYXR0ZXJuIE1hcHBpbmdQYXR0ZXJuIFN0YXJQYXR0ZXJuIENsYXNzUGF0dGVybiBQYXR0ZXJuQXJnTGlzdCBLZXl3b3JkUGF0dGVybiBLZXl3b3JkUGF0dGVybiBHdWFyZFwiLFxuICBtYXhUZXJtOiAyNzcsXG4gIGNvbnRleHQ6IHRyYWNrSW5kZW50LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC01LDQsNzEsNzIsNzMsNzcsXCJcIl0sXG4gICAgW1wiZ3JvdXBcIiwgLTE1LDYsODUsODcsODgsOTAsOTIsOTQsOTYsOTgsOTksMTAwLDEwMiwxMDUsMTA4LDExMCxcIlN0YXRlbWVudCBTdGF0ZW1lbnRcIiwtMjIsOCwxOCwyMSwyNSw0MCw0OSw1MCw1Niw1Nyw2MCw2MSw2Miw2Myw2NCw2Nyw3MCw3MSw3Miw3OSw4MCw4MSw4MixcIkV4cHJlc3Npb25cIiwtMTAsMTE0LDExNiwxMTksMTIxLDEyMiwxMjYsMTI4LDEzMywxMzUsMTM4LFwiU3RhdGVtZW50XCIsLTksMTQzLDE0NCwxNDcsMTQ4LDE1MCwxNTEsMTUyLDE1MywxNTQsXCJQYXR0ZXJuXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDIzLFwiKFwiLDU0LFwiW1wiLDU4LFwie1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCAyNCxcIilcIiw1NSxcIl1cIiw1OSxcIn1cIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtweXRob25IaWdobGlnaHRpbmddLFxuICBza2lwcGVkTm9kZXM6IFswLDRdLFxuICByZXBlYXROb2RlQ291bnQ6IDM0LFxuICB0b2tlbkRhdGE6IFwiITJ8flIhYE9YJVRYWSVvWVslVFtdJW9dcCVUcHElb3FyJ2FycylZc3QqeHR1JVR1dixkdnctaHd4LlV4eS90eXowW3p7MHJ7fDJTfH0ycH0hTzNXIU8hUDRfIVAhUTpaIVEhUjtrIVIhWz5fIVshXURvIV0hXkVzIV4hX0ZaIV8hYEdrIWAhYUhYIWEhYiVUIWIhY0lmIWMhZEpVIWQhZUteIWUhaEpVIWghaSEjZiFpIXRKVSF0IXUhLHwhdSF3SlUhdyF4IS50IXghfUpVIX0jTyEwUyNPI1AmbyNQI1EhMGojUSNSITFRI1IjU0pVI1MjVCVUI1QjVUpVI1UjVkteI1YjWUpVI1kjWiEjZiNaI2ZKVSNmI2chLHwjZyNpSlUjaSNqIS50I2ojb0pVI28jcCExbiNwI3EhMXMjcSNyITJhI3IjcyEyZiNzJGclVCRnOydTSlU7J1M7PWBLVzwlbE9KVWAlWVQmbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGAlbFA7PWA8JWwlVG8ldl0mbmAlY19PWCVUWFklb1lbJVRbXSVvXXAlVHBxJW9xI08lVCNPI1AmbyNQI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVG8mdFgmbmBPWSVUWVolb1pdJVRdXiVvXiNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRjJ2ZbJm5gTyFfJVQhXyFgKFshYCNUJVQjVCNVKHIjVSNmJVQjZiNnKHIjZyNoKHIjaCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRjKGNUbVImbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGMoeVQhbVImbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGspYVYmbmAmW1pPciVUcnMpdnMjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUayl7ViZuYE9yJVRycypicyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrKmlUJm5gJl5aTyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRvK1BaU18mbmBPWSp4WVolVFpdKnhdXiVUXiNvKngjbyNwK3IjcCNxKngjcSNyK3IjcjsnUyp4OydTOz1gLF48JWxPKnhfK3dUU19PWStyWl0rcl47J1MrcjsnUzs9YCxXPCVsTytyXyxaUDs9YDwlbCtybyxhUDs9YDwlbCp4aixrViVyUSZuYE8hXyVUIV8hYC1RIWAjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUai1YVCF4WSZuYE8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUai1vViVsUSZuYE8hXyVUIV8hYC1RIWAjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUay5dViZuYCZaWk93JVR3eC5yeCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrLndWJm5gT3clVHd4L154I28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGsvZVQmbmAmXVpPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGsve1RoWiZuYE8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUYzBjVGdSJm5gTyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrMHlYVlombmBPeiVUensxZnshXyVUIV8hYC1RIWAjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUazFtVmFSJm5gTyFfJVQhXyFgLVEhYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrMlpWJW9aJm5gTyFfJVQhXyFgLVEhYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRjMndUelImbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVG8zX1clcFombmBPIV8lVCFfIWAtUSFgIWEzdyFhI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGQ0T1Qme1MmbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGs0ZlghZlEmbmBPIU8lVCFPIVA1UiFQIVElVCFRIVs2VCFbI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGs1V1YmbmBPIU8lVCFPIVA1bSFQI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGs1dFQhclombmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk2W2EhaFgmbmBPIVElVCFRIVs2VCFbIWclVCFnIWg3YSFoIWwlVCFsIW05cyFtI1IlVCNSI1M2VCNTI1glVCNYI1k3YSNZI14lVCNeI185cyNfI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk3ZlombmBPeyVUe3w4WHx9JVR9IU84WCFPIVElVCFRIVs4cyFbI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk4XlYmbmBPIVElVCFRIVs4cyFbI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk4el0haFgmbmBPIVElVCFRIVs4cyFbIWwlVCFsIW05cyFtI1IlVCNSI1M4cyNTI14lVCNeI185cyNfI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk5elQhaFgmbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGs6YlglcVImbmBPIVAlVCFQIVE6fSFRIV8lVCFfIWAtUSFgI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGo7VVYlc1EmbmBPIV8lVCFfIWAtUSFgI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk7cm8haFgmbmBPIU8lVCFPIVA9cyFQIVElVCFRIVs+XyFbIWQlVCFkIWU/cSFlIWclVCFnIWg3YSFoIWwlVCFsIW05cyFtIXElVCFxIXJBXSFyIXolVCF6IXtCcSF7I1IlVCNSI1M+XyNTI1UlVCNVI1Y/cSNWI1glVCNYI1k3YSNZI14lVCNeI185cyNfI2MlVCNjI2RBXSNkI2wlVCNsI21CcSNtI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk9eFYmbmBPIVElVCFRIVs2VCFbI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk+ZmMhaFgmbmBPIU8lVCFPIVA9cyFQIVElVCFRIVs+XyFbIWclVCFnIWg3YSFoIWwlVCFsIW05cyFtI1IlVCNSI1M+XyNTI1glVCNYI1k3YSNZI14lVCNeI185cyNfI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGk/dlkmbmBPIVElVCFRIVJAZiFSIVNAZiFTI1IlVCNSI1NAZiNTI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGlAbVkhaFgmbmBPIVElVCFRIVJAZiFSIVNAZiFTI1IlVCNSI1NAZiNTI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGlBYlgmbmBPIVElVCFRIVlBfSFZI1IlVCNSI1NBfSNTI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGlCVVghaFgmbmBPIVElVCFRIVlBfSFZI1IlVCNSI1NBfSNTI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGlCdl0mbmBPIVElVCFRIVtDbyFbIWMlVCFjIWlDbyFpI1IlVCNSI1NDbyNTI1QlVCNUI1pDbyNaI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGlDdl0haFgmbmBPIVElVCFRIVtDbyFbIWMlVCFjIWlDbyFpI1IlVCNSI1NDbyNTI1QlVCNUI1pDbyNaI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVG9EdlZ7XyZuYE8hXyVUIV8hYEVdIWAjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUY0VkVCV7UiZuYE8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUa0V6VCNnWiZuYE8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUa0ZiWG1SJm5gTyFeJVQhXiFfRn0hXyFgKFshYCFhKFshYSNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRqR1VWJW1RJm5gTyFfJVQhXyFgLVEhYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrR3JWJXpaJm5gTyFfJVQhXyFgKFshYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrSGBXbVImbmBPIV8lVCFfIWAoWyFgIWFIeCFhI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGpJUFYlblEmbmBPIV8lVCFfIWAtUSFgI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGtJb1ZfUSN9UCZuYE8hXyVUIV8hYC1RIWAjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUb0pfXSZuYCZZUyV1Wk8hUSVUIVEhW0pVIVshYyVUIWMhfUpVIX0jUiVUI1IjU0pVI1MjVCVUI1Qjb0pVI3AjcSVUI3IkZyVUJGc7J1NKVTsnUzs9YEtXPCVsT0pVb0taUDs9YDwlbEpVb0tnZSZuYCZZUyV1Wk9yJVRycylZc3clVHd4LlV4IVElVCFRIVtKVSFbIWMlVCFjIXRKVSF0IXVMeCF1IX1KVSF9I1IlVCNSI1NKVSNTI1QlVCNUI2ZKVSNmI2dMeCNnI29KVSNwI3ElVCNyJGclVCRnOydTSlU7J1M7PWBLVzwlbE9KVW9NUmEmbmAmWVMldVpPciVUcnNOV3N3JVR3eCEgdnghUSVUIVEhW0pVIVshYyVUIWMhfUpVIX0jUiVUI1IjU0pVI1MjVCVUI1Qjb0pVI3AjcSVUI3IkZyVUJGc7J1NKVTsnUzs9YEtXPCVsT0pVa05fViZuYCZgWk9yJVRyc050cyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrTnlWJm5gT3IlVHJzISBgcyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrISBnVCZuYCZiWk8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUayEgfVYmbmAmX1pPdyVUd3ghIWR4I28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGshIWlWJm5gT3clVHd4ISNPeCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrISNWVCZuYCZhWk8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUbyEjb2UmbmAmWVMldVpPciVUcnMhJVFzdyVUd3ghJnB4IVElVCFRIVtKVSFbIWMlVCFjIXRKVSF0IXUhKGAhdSF9SlUhfSNSJVQjUiNTSlUjUyNUJVQjVCNmSlUjZiNnIShgI2cjb0pVI3AjcSVUI3IkZyVUJGc7J1NKVTsnUzs9YEtXPCVsT0pVayElWFYmbmAmZFpPciVUcnMhJW5zI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGshJXNWJm5gT3IlVHJzISZZcyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrISZhVCZuYCZmWk8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUayEmd1YmbmAmY1pPdyVUd3ghJ154I28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGshJ2NWJm5gT3clVHd4ISd4eCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrIShQVCZuYCZlWk8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUbyEoaWEmbmAmWVMldVpPciVUcnMhKW5zdyVUd3ghK154IVElVCFRIVtKVSFbIWMlVCFjIX1KVSF9I1IlVCNSI1NKVSNTI1QlVCNUI29KVSNwI3ElVCNyJGclVCRnOydTSlU7J1M7PWBLVzwlbE9KVWshKXVWJm5gJmhaT3IlVHJzISpbcyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrISphViZuYE9yJVRycyEqdnMjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUayEqfVQmbmAmalpPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGshK2VWJm5gJmdaT3clVHd4ISt6eCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRrISxQViZuYE93JVR3eCEsZngjbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUayEsbVQmbmAmaVpPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVG8hLVZpJm5gJllTJXVaT3IlVHJzTldzdyVUd3ghIHZ4IVElVCFRIVtKVSFbIWMlVCFjIWRKVSFkIWVMeCFlIWhKVSFoIWkhKGAhaSF9SlUhfSNSJVQjUiNTSlUjUyNUJVQjVCNVSlUjVSNWTHgjViNZSlUjWSNaIShgI1ojb0pVI3AjcSVUI3IkZyVUJGc7J1NKVTsnUzs9YEtXPCVsT0pVbyEufWEmbmAmWVMldVpPciVUcnMpWXN3JVR3eC5VeCFRJVQhUSFbSlUhWyFjJVQhYyF9SlUhfSNSJVQjUiNTSlUjUyNUJVQjVCNvSlUjcCNxJVQjciRnJVQkZzsnU0pVOydTOz1gS1c8JWxPSlVrITBaVCFYWiZuYE8jbyVUI3AjcSVUI3I7J1MlVDsnUzs9YCVpPCVsTyVUYyEwcVQhV1ImbmBPI28lVCNwI3ElVCNyOydTJVQ7J1M7PWAlaTwlbE8lVGohMVhWJWtRJm5gTyFfJVQhXyFgLVEhYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVR+ITFzTyFdfmshMXpWJWpSJm5gTyFfJVQhXyFgLVEhYCNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVR+ITJmTyFbfmkhMm1UJXRYJm5gTyNvJVQjcCNxJVQjcjsnUyVUOydTOz1gJWk8JWxPJVRcIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCBpbmRlbnRhdGlvbiwgbmV3bGluZXMsIHN0cmluZ3MsIDAsIDEsIDIsIDMsIDRdLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsNV19LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAyMjEsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogNzY2OFxufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/python/dist/index.js\n");

/***/ })

};
;